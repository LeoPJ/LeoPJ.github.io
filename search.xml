<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Butterfly3.6.2升级笔记</title>
      <link href="2021/02/10/update_butterfly_3.6.2/"/>
      <url>2021/02/10/update_butterfly_3.6.2/</url>
      
        <content type="html"><![CDATA[<p>在2021年春节无聊期间把博客升级了一下，参考<a href="https://butterfly.js.org/">官方文档</a>重新新建了一个blog文件夹升级到Butterfly3.6.2版，然后deploy到GitHub上直接覆盖了原来的blog文件夹实现。</p><p>并且做了部分在上一版中没有试过的美化/优化/魔改，参考了以下教程，特此记录：</p><ul><li><a href="https://imszz.com/p/ffb5990d/">Valine引用B站表情</a></li><li><a href="https://imszz.com/p/c4492888/">Valine添加自定义邮件提醒</a></li><li><a href="https://akilar.top/posts/d2222705/">Valine 评论添加 “博主，小伙伴，访客” 标签</a></li><li><a href="https://blog.zhheo.com/p/2e6bbbd0.html">Twikoo评论系统配置教程（基于腾讯云开发）</a></li><li><a href="https://snow.js.org/butterfly-aplayer/">Butterfly：添加全局吸底 Aplayer 播放器</a></li><li><a href="https://blog.slqwq.cn/2021/posts/bbr35lia">添加PACE加载进度条</a></li><li><a href="https://zfe.space/post/65396.html">教程：Butterfly主题的一图流和视频流背景修改方法</a></li><li><a href="https://www.antmoe.com/posts/7198453/index.html">Hexo 博客之 butterfly 主题优雅更换背景</a></li><li><a href="https://waline.js.org/quick-start.html">valine改用waline</a></li><li><a href="https://www.nesxc.com/post/hexocc.html">butterfly版权美化教程</a></li><li><a href="https://akilar.top/posts/bbf68ad4/">平滑升级魔改后的 Hexo 主题</a>（码一个，下次用）</li></ul><p>P.S. 在寻找教程过程中，从作者Jerry本人的友链里发现了一堆魔改的大佬，然后顺着这些大佬的友链欣赏了很多优化的优秀博客作品，以及在他们的友链里发现了更多的大佬。同时在这些大佬中也发现了不少已经成功跨过校招的独木桥拿到offer的同龄人，我觉得接下来的工作就是一个接着一个博客去膜（shi）拜（jian）学习一下了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode刷题——数据库专题（非会员题目合集）</title>
      <link href="2021/02/03/database_leetcode/"/>
      <url>2021/02/03/database_leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="175-组合两个表"><a href="#175-组合两个表" class="headerlink" title="175. 组合两个表"></a><a href="https://leetcode-cn.com/problems/combine-two-tables/">175. 组合两个表</a></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> FirstName, LastName, City, State</span><br><span class="line"><span class="keyword">from</span> Person</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">join</span> Address <span class="keyword">on</span> Person.PersonId <span class="operator">=</span> Address.PersonId</span><br></pre></td></tr></table></figure><h1 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176. 第二高的薪水"></a><a href="https://leetcode-cn.com/problems/second-highest-salary/">176. 第二高的薪水</a></h1><p>解1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> ifnull(</span><br><span class="line">               (<span class="keyword">select</span> Salary</span><br><span class="line">                <span class="keyword">from</span> (<span class="keyword">select</span> <span class="variable">@n</span> :<span class="operator">=</span> <span class="variable">@n</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">as</span> ranking, Salary</span><br><span class="line">                      <span class="keyword">from</span> (<span class="keyword">select</span> <span class="variable">@n</span> :<span class="operator">=</span> <span class="number">0</span>) <span class="keyword">as</span> a,</span><br><span class="line">                           (<span class="keyword">select</span> <span class="keyword">distinct</span> Salary <span class="keyword">from</span> Employee) <span class="keyword">as</span> b</span><br><span class="line">                      <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span>) <span class="keyword">as</span> c</span><br><span class="line">                <span class="keyword">where</span> c.ranking <span class="operator">=</span> <span class="number">2</span>), <span class="keyword">null</span>) <span class="keyword">as</span> SecondHighestSalary</span><br></pre></td></tr></table></figure><p>解2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> ifnull((<span class="keyword">select</span> <span class="keyword">distinct</span> Salary <span class="keyword">from</span> Employee <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span> limit <span class="number">1</span>,<span class="number">1</span>),<span class="keyword">null</span>) <span class="keyword">as</span> SecondHighestSalary</span><br></pre></td></tr></table></figure><p>错误解法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> IF(Salary <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>, Salary, <span class="keyword">null</span>) <span class="keyword">as</span> SecondHighestSalary</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="variable">@n</span> :<span class="operator">=</span> <span class="variable">@n</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">as</span> ranking, Id, Salary</span><br><span class="line">      <span class="keyword">from</span> (<span class="keyword">select</span> <span class="variable">@n</span> :<span class="operator">=</span> <span class="number">0</span>) a,</span><br><span class="line">           Employee b</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span>) <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">where</span> c.ranking <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">#返回的是&#123;&quot;headers&quot;: [&quot;SecondHighestSalary&quot;], &quot;values&quot;: []&#125;</span><br><span class="line">#而预期是&#123;&quot;headers&quot;: [&quot;SecondHighestSalary&quot;], &quot;values&quot;: [[null]]&#125;</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="为查询结果增加一个自增列"><a href="#为查询结果增加一个自增列" class="headerlink" title="为查询结果增加一个自增列"></a>为查询结果增加一个自增列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#两句</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@rownum</span><span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> (<span class="variable">@rownum</span>:<span class="operator">=</span><span class="variable">@rownum</span><span class="operator">+</span><span class="number">1</span>),colname <span class="keyword">from</span> [tablename <span class="keyword">or</span> (subquery) a];</span><br><span class="line"></span><br><span class="line">#合成一句</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@rownum</span>:<span class="operator">=</span><span class="variable">@rownum</span><span class="operator">+</span><span class="number">1</span>,colnum <span class="keyword">from</span> (<span class="keyword">select</span> <span class="variable">@rownum</span>:<span class="operator">=</span><span class="number">0</span>) a,[tablename <span class="keyword">or</span> (subquery) b];</span><br></pre></td></tr></table></figure><p>注：在自增列取别名时注意<code>rank</code>是关键字！<code>as rank</code>会报错！</p><h3 id="IF和IFNULL作为表达式用"><a href="#IF和IFNULL作为表达式用" class="headerlink" title="IF和IFNULL作为表达式用"></a><code>IF</code>和<code>IFNULL</code>作为表达式用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IF(expr1,expr2,expr3) </span><br></pre></td></tr></table></figure><p>如果 expr1 是TRUE (expr1 != 0 and expr1 != NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFNULL(expr1,expr2) </span><br></pre></td></tr></table></figure><p>假如expr1 不为 NULL，则 IFNULL() 的返回值为 expr1; 否则其返回值为 expr2。IFNULL()的返回值是数字或是字符串，具体情况取决于其所使用的语境。</p><p>参考：<a href="https://www.cnblogs.com/xuhaojun/p/9141396.html">SQL的IF语句</a></p><h3 id="limit与limit-offset选出排第n位的值"><a href="#limit与limit-offset选出排第n位的值" class="headerlink" title="limit与limit+offset选出排第n位的值"></a><code>limit</code>与<code>limit+offset</code>选出排第n位的值</h3><blockquote><p><code>limit</code>接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。</p></blockquote><p>SQL查询语句中的 limit 与 offset 的区别：</p><ul><li><code>limit y</code> 分句表示: 读取 y 条数据</li><li><code>limit x, y</code> 分句表示: 跳过 x 条数据，从第 x+1 条开始读取 y 条数据</li><li><code>limit y offset x</code> 分句表示: 跳过 x 条数据，从第 x+1 条开始读取 y 条数据</li></ul><p>所以查询排名第n位的值应该用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIMIT <span class="number">1</span> <span class="keyword">OFFSET</span> n<span class="number">-1</span></span><br><span class="line">或</span><br><span class="line">LIMIT n<span class="number">-1</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/cnwyt/article/details/81945663?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">SQL查询语句中的 limit 与 offset 的区别</a></p><h3 id="返回空表与返回NULL值（错解原因）"><a href="#返回空表与返回NULL值（错解原因）" class="headerlink" title="返回空表与返回NULL值（错解原因）"></a>返回空表与返回<code>NULL</code>值（错解原因）</h3><p>返回0条记录（空表，啥也没返回）和返回null（此时null是个值，是个结果返回）的区别：查询一个空表返回空（啥也没有），查询一个全是null无其他值的表返回null。</p><p>用<strong>子查询</strong>：子查询可以在任意地方使用，相当于查询的列。子查询数据作为虚表嵌套来查询虚表，查询不到返回null，因此解2可以优化为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> Salary <span class="keyword">from</span> Employee <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span> limit <span class="number">1</span>,<span class="number">1</span>) <span class="keyword">as</span> SecondHighestSalary</span><br></pre></td></tr></table></figure><p>验证：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p>返回的是NULL值。</p><h1 id="177-第N高的薪水"><a href="#177-第N高的薪水" class="headerlink" title="177. 第N高的薪水"></a><a href="https://leetcode-cn.com/problems/nth-highest-salary/">177. 第N高的薪水</a></h1><p>解1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">RETURN</span> (</span><br><span class="line">        # Write your MySQL query statement below.</span><br><span class="line">        <span class="keyword">select</span> ifnull(</span><br><span class="line">                       (<span class="keyword">select</span> Salary</span><br><span class="line">                        <span class="keyword">from</span> (<span class="keyword">select</span> <span class="variable">@n</span> :<span class="operator">=</span> <span class="variable">@n</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">as</span> ranking, Salary</span><br><span class="line">                              <span class="keyword">from</span> (<span class="keyword">select</span> <span class="variable">@n</span> :<span class="operator">=</span> <span class="number">0</span>) <span class="keyword">as</span> a,</span><br><span class="line">                                   (<span class="keyword">select</span> <span class="keyword">distinct</span> Salary <span class="keyword">from</span> Employee) <span class="keyword">as</span> b</span><br><span class="line">                              <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span>) <span class="keyword">as</span> c</span><br><span class="line">                        <span class="keyword">where</span> c.ranking <span class="operator">=</span> N), <span class="keyword">null</span>) <span class="keyword">as</span> getNthHighestSalary</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>解2（但是如果只能在return里作答的话，set那句加在了非答题区域）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SET</span> N <span class="operator">=</span> N <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">RETURN</span> (</span><br><span class="line">        # Write your MySQL query statement below.</span><br><span class="line">        <span class="keyword">select</span> ifnull((<span class="keyword">select</span> <span class="keyword">distinct</span> Salary <span class="keyword">from</span> Employee <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span> limit N,<span class="number">1</span>),</span><br><span class="line">                      <span class="keyword">null</span>) <span class="keyword">as</span> getNthHighestSalary</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><h3 id="limit子句不能跟计算式"><a href="#limit子句不能跟计算式" class="headerlink" title="limit子句不能跟计算式"></a><code>limit</code>子句不能跟计算式</h3><blockquote><p>参考<a href="https://leetcode-cn.com/problems/nth-highest-salary/solution/mysql-zi-ding-yi-bian-liang-by-luanz/">题解</a>：排名第N高意味着要跳过N-1个薪水，由于无法直接用limit N-1，所以需先在函数开头处理N为N=N-1。<br>注：这里不能直接用limit N-1是因为limit和offset字段后面只接受正整数（意味着0、负数、小数都不行）或者单一变量（意味着不能用表达式），也就是说想取一条，limit 2-1、limit 1.1这类的写法都是报错的。</p></blockquote><h1 id="178-分数排名"><a href="#178-分数排名" class="headerlink" title="178. 分数排名"></a><a href="https://leetcode-cn.com/problems/rank-scores/">178. 分数排名</a></h1><p>解1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> Score,<span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> Score <span class="keyword">desc</span>) <span class="keyword">as</span> `Rank` <span class="keyword">from</span> Scores</span><br></pre></td></tr></table></figure><p>解2（没有窗口函数时）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> Score,</span><br><span class="line">       (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> Score) <span class="keyword">from</span> Scores <span class="keyword">as</span> a <span class="keyword">where</span> a.Score <span class="operator">&gt;=</span> b.Score) <span class="keyword">as</span> `Rank`</span><br><span class="line"><span class="keyword">from</span> Scores <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Score <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><h3 id="MySQL-8-0的排名函数"><a href="#MySQL-8-0的排名函数" class="headerlink" title="MySQL 8.0的排名函数"></a>MySQL 8.0的排名函数</h3><p>参考上一题<a href="https://leetcode-cn.com/problems/nth-highest-salary/solution/mysql-zi-ding-yi-bian-liang-by-luanz/">题解</a>里的第六点：窗口函数</p><p>参考博文：<a href="https://blog.csdn.net/qq_41057885/article/details/109176014?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">MySQL rank() over、dense_rank() over、row_number() over 用法介绍</a></p><ul><li><code>rank()</code>：条件相同时排名相同，排名间断不连续，有跳级。</li><li><code>dense_rank()</code>：条件相同时排名相同，排名连续不间断，无跳级。</li><li><code>row_number()</code>：条件相同时排名不相同，排名连续不间断，相当于行号。</li></ul><p>必须要要与其搭档<code>over()</code>配套使用，<code>over()</code>中的参数常见的有两个，分别是：</p><ul><li><code>partition by</code>：按某字段切分。</li><li><code>order by</code>：与常规order by用法一致，也区分ASC(默认)和DESC，因为排名总得有个依据。</li></ul><h3 id="当MySQL没有8-0时怎么办"><a href="#当MySQL没有8-0时怎么办" class="headerlink" title="当MySQL没有8.0时怎么办"></a>当MySQL没有8.0时怎么办</h3><p>给一个分数X算出它的排名Rank——思路：先提取出大于等于X的所有分数集合H，将H去重后的元素个数就是X的排名。比如你考了99分，但最高的就只有99分，那么去重之后集合H里就只有99一个元素，个数为1，因此你的Rank为1。</p><p>参考<a href="https://leetcode-cn.com/problems/rank-scores/solution/fen-cheng-liang-ge-bu-fen-xie-hui-rong-yi-hen-duo-/">题解</a>。</p><h1 id="180-连续出现的数字"><a href="#180-连续出现的数字" class="headerlink" title="180. 连续出现的数字"></a><a href="https://leetcode-cn.com/problems/consecutive-numbers/">180. 连续出现的数字</a></h1><p>解1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> a.Num <span class="keyword">as</span> ConsecutiveNums</span><br><span class="line"><span class="keyword">from</span> `Logs` a,</span><br><span class="line">     `Logs` b,</span><br><span class="line">     `Logs` c</span><br><span class="line"><span class="keyword">where</span> (a.Id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> b.Id <span class="keyword">and</span> a.Num <span class="operator">=</span> b.Num)</span><br><span class="line">  <span class="keyword">and</span> (a.Id <span class="operator">+</span> <span class="number">2</span> <span class="operator">=</span> c.Id <span class="keyword">and</span> a.Num <span class="operator">=</span> c.Num)</span><br></pre></td></tr></table></figure><p>解2（利用lag和lead函数）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> Num <span class="keyword">as</span> ConsecutiveNums</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> Num, <span class="built_in">lag</span>(Num, <span class="number">1</span>) <span class="keyword">over</span> () <span class="keyword">as</span> front, <span class="built_in">lead</span>(Num, <span class="number">1</span>) <span class="keyword">over</span> () <span class="keyword">as</span> behind <span class="keyword">from</span> `Logs`) <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">where</span> Num <span class="operator">=</span> front</span><br><span class="line">  <span class="keyword">and</span> Num <span class="operator">=</span> behind</span><br></pre></td></tr></table></figure><p>评论里的一种利用case-when语句的方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> Num <span class="keyword">as</span> ConsecutiveNums</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">         <span class="keyword">select</span> Num,</span><br><span class="line">                <span class="keyword">case</span></span><br><span class="line">                    <span class="keyword">when</span> <span class="variable">@prev</span> <span class="operator">=</span> Num <span class="keyword">then</span> <span class="variable">@count</span> :<span class="operator">=</span> <span class="variable">@count</span> <span class="operator">+</span> <span class="number">1</span> #如果上一行已经给prev赋值了，这一行还是同一个Num的话，就会触发这一句<span class="keyword">when</span>，然后count<span class="operator">+</span><span class="number">1</span>计数</span><br><span class="line">                    <span class="keyword">when</span> (<span class="variable">@prev</span> :<span class="operator">=</span> Num) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="variable">@count</span> :<span class="operator">=</span> <span class="number">1</span> #给prev变量赋新值并且直接进入count<span class="operator">+</span><span class="number">1</span>计数，因为<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>默认为<span class="literal">true</span></span><br><span class="line">                    <span class="keyword">end</span> <span class="keyword">as</span> CNT</span><br><span class="line">         <span class="keyword">from</span> Logs,</span><br><span class="line">              (<span class="keyword">select</span> <span class="variable">@prev</span> :<span class="operator">=</span> <span class="keyword">null</span>, <span class="variable">@count</span> :<span class="operator">=</span> <span class="keyword">null</span>) <span class="keyword">as</span> t</span><br><span class="line">     ) <span class="keyword">as</span> temp</span><br><span class="line"><span class="keyword">where</span> temp.CNT <span class="operator">&gt;=</span> <span class="number">3</span> #<span class="number">3</span>换成任何值可以满足不同题目给出的连续N次出现的数字</span><br></pre></td></tr></table></figure><p>注：如果有三行连续的Num为1的话，中间select出来的(Num,CNT)结果应该是(1,1),(1,2),(1,3)，然后where语句就会选出第三行符合条件。</p><p>另一种采用两个表之间的关系比较的更牛的方法参考：<a href="https://leetcode-cn.com/problems/consecutive-numbers/solution/sql-server-jie-fa-by-neilsons/">题解</a>。</p><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><h3 id="MySQL-8-0：lag-和lead"><a href="#MySQL-8-0：lag-和lead" class="headerlink" title="MySQL 8.0：lag()和lead()"></a>MySQL 8.0：lag()和lead()</h3><p>The LAG() function is used to get value from row that precedes the current row.</p><p>The LEAD() function is used to get value from row that succedes the current row.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LEAD</span>(expr, N, <span class="keyword">default</span>) </span><br><span class="line">          <span class="keyword">OVER</span> (Window_specification <span class="operator">|</span> Window_name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">LAG</span>(expr, N, <span class="keyword">default</span>) </span><br><span class="line">          <span class="keyword">OVER</span> (Window_specification <span class="operator">|</span> Window_name)</span><br></pre></td></tr></table></figure><p>注：lag和lead后面必须跟over()，如果over()里参数为空则默认在所有行里操作。</p><p>参考：<a href="https://www.geeksforgeeks.org/mysql-lead-and-lag-function/">MySQL | LEAD() and LAG() Function</a></p><h1 id="181-超过经理收入的员工"><a href="#181-超过经理收入的员工" class="headerlink" title="181. 超过经理收入的员工"></a><a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/">181. 超过经理收入的员工</a></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> a.Name <span class="keyword">as</span> `Employee`</span><br><span class="line"><span class="keyword">from</span> Employee <span class="keyword">as</span> a</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">join</span> Employee <span class="keyword">as</span> b</span><br><span class="line">                   <span class="keyword">on</span> a.ManagerId <span class="operator">=</span> b.Id</span><br><span class="line"><span class="keyword">where</span> a.ManagerId <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">  <span class="keyword">and</span> a.Salary <span class="operator">&gt;</span> b.Salary</span><br></pre></td></tr></table></figure><p>注：where里一开始我还很仔细地加上了<code>b.ManagerId is null</code>的条件，结果用例里有一个套娃式的多层经理关系把我看傻了：<code>&quot;rows&quot;: &#123;&quot;Employee&quot;: [[1, &quot;Mark&quot;, 40000, 3], [3, &quot;Jack&quot;, 30000, 2], [2, &quot;Alan&quot;, 20000, null]]&#125;</code>，好家伙。</p><h1 id="182-查找重复的电子邮箱"><a href="#182-查找重复的电子邮箱" class="headerlink" title="182. 查找重复的电子邮箱"></a><a href="https://leetcode-cn.com/problems/duplicate-emails/">182. 查找重复的电子邮箱</a></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> Email</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">SELECT</span> Email, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num <span class="keyword">FROM</span> Person <span class="keyword">group</span> <span class="keyword">by</span> Email) <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">where</span> c.num <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>更好的解法，用<code>having</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> Email <span class="keyword">FROM</span> Person <span class="keyword">GROUP</span> <span class="keyword">BY</span> Email <span class="keyword">HAVING</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.runoob.com/sql/sql-having.html">SQL HAVING 子句</a></p><h1 id="183-从不订购的客户"><a href="#183-从不订购的客户" class="headerlink" title="183. 从不订购的客户"></a><a href="https://leetcode-cn.com/problems/customers-who-never-order/">183. 从不订购的客户</a></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> `Name` <span class="keyword">as</span> `Customers`</span><br><span class="line"><span class="keyword">from</span> Customers <span class="keyword">as</span> c</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">join</span> Orders <span class="keyword">as</span> o</span><br><span class="line">                   <span class="keyword">on</span> c.Id <span class="operator">=</span> o.CustomerId</span><br><span class="line"><span class="keyword">where</span> o.Id <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/customers-who-never-order/solution/tu-jie-sqlmian-shi-ti-cha-zhao-bu-zai-biao-li-de-s/">关于SQL里的join连接</a></p><h1 id="184-部门工资最高的员工"><a href="#184-部门工资最高的员工" class="headerlink" title="184. 部门工资最高的员工"></a><a href="https://leetcode-cn.com/problems/department-highest-salary/">184. 部门工资最高的员工</a></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> d.`Name` <span class="keyword">as</span> `Department`, b.`Name` <span class="keyword">as</span> `Employee`, b.Salary</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> a.`Name`, a.Salary, a.DepartmentId</span><br><span class="line">      <span class="keyword">from</span> Employee a</span><br><span class="line">               <span class="keyword">right</span> <span class="keyword">join</span></span><br><span class="line">           (<span class="keyword">select</span> DepartmentId, <span class="built_in">max</span>(Salary) <span class="keyword">as</span> max_s <span class="keyword">from</span> Employee <span class="keyword">group</span> <span class="keyword">by</span> DepartmentId) c</span><br><span class="line">           <span class="keyword">on</span> a.Salary <span class="operator">=</span> c.max_s <span class="keyword">and</span> a.DepartmentId <span class="operator">=</span> c.DepartmentId) b</span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span> Department <span class="keyword">as</span> d</span><br><span class="line">                    <span class="keyword">on</span> b.DepartmentId <span class="operator">=</span> d.Id</span><br></pre></td></tr></table></figure><p>P.S.<a href="https://leetcode-cn.com/problems/department-highest-salary/solution/bu-men-gong-zi-zui-gao-de-yuan-gong-by-leetcode/">官方题解</a>给出了一种<code>in</code>同时用在两个字段上的骚操作。</p><h1 id="185-部门工资前三高的所有员工"><a href="#185-部门工资前三高的所有员工" class="headerlink" title="185. 部门工资前三高的所有员工"></a><a href="https://leetcode-cn.com/problems/department-top-three-salaries/">185. 部门工资前三高的所有员工</a></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> Department, Employee, Salary</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> d.`Name`                                                           <span class="keyword">as</span> `Department`,</span><br><span class="line">             e.`Name`                                                           <span class="keyword">as</span> Employee,</span><br><span class="line">             e.Salary,</span><br><span class="line">             <span class="built_in">dense_rank</span>() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> DepartmentId <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span>) <span class="keyword">as</span> ranking</span><br><span class="line">      <span class="keyword">from</span> Employee e</span><br><span class="line">               <span class="keyword">inner</span> <span class="keyword">join</span> Department d</span><br><span class="line">                          <span class="keyword">on</span> e.DepartmentId <span class="operator">=</span> d.Id) a</span><br><span class="line"><span class="keyword">where</span> a.ranking <span class="operator">&lt;=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>题解里另一种<a href="https://leetcode-cn.com/problems/department-top-three-salaries/solution/185-bu-men-gong-zi-qian-san-gao-de-yuan-gong-by-li/">不用窗口函数的解法</a>。</p><h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h2><h3 id="over-函数里两个参数的使用语法"><a href="#over-函数里两个参数的使用语法" class="headerlink" title="over()函数里两个参数的使用语法"></a><code>over()</code>函数里两个参数的使用语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">over</span>（<span class="keyword">partition</span> <span class="keyword">by</span> columnname1 <span class="keyword">order</span> <span class="keyword">by</span> columnname2）</span><br></pre></td></tr></table></figure><p>参考<a href="https://www.cnblogs.com/ilookbo/p/4783439.html">SQL over的作用及用法</a>。</p><h1 id="196-删除重复的电子邮箱"><a href="#196-删除重复的电子邮箱" class="headerlink" title="196. 删除重复的电子邮箱"></a><a href="https://leetcode-cn.com/problems/delete-duplicate-emails/">196. 删除重复的电子邮箱</a></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">from</span> Person</span><br><span class="line"><span class="keyword">where</span> Id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> Id <span class="keyword">from</span> (<span class="keyword">select</span> <span class="built_in">min</span>(Id) <span class="keyword">as</span> `Id` <span class="keyword">from</span> Person <span class="keyword">group</span> <span class="keyword">by</span> Email) c)</span><br></pre></td></tr></table></figure><p>P.S.官方<a href="https://leetcode-cn.com/problems/delete-duplicate-emails/solution/shan-chu-zhong-fu-de-dian-zi-you-xiang-by-leetcode/">题解</a>采用多表联结删除的方法，有详细<a href="https://leetcode-cn.com/problems/delete-duplicate-emails/solution/dui-guan-fang-ti-jie-zhong-delete-he-de-jie-shi-by/">解释</a></p><h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h2><h3 id="You-can’t-specify-target-table-‘表名’-for-update-in-FROM-clause错误"><a href="#You-can’t-specify-target-table-‘表名’-for-update-in-FROM-clause错误" class="headerlink" title="You can’t specify target table ‘表名’ for update in FROM clause错误"></a>You can’t specify target table ‘表名’ for update in FROM clause错误</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Person <span class="keyword">where</span> Id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="built_in">min</span>(Id) <span class="keyword">as</span> `Id` <span class="keyword">from</span> Person <span class="keyword">group</span> <span class="keyword">by</span> Email)</span><br></pre></td></tr></table></figure><p>这个提交报如题错误，原因是在MySQL里不能先select一个表的记录，再按此条件进行更新和删除同一个表的记录。这时需要再通过中间表select一遍，规避错误。</p><p>参考<a href="https://blog.csdn.net/h996666/article/details/81699255">博客</a></p><h1 id="197-上升的温度"><a href="#197-上升的温度" class="headerlink" title="197. 上升的温度"></a><a href="https://leetcode-cn.com/problems/rising-temperature/">197. 上升的温度</a></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> w1.Id</span><br><span class="line"><span class="keyword">from</span> Weather w1,</span><br><span class="line">     Weather w2</span><br><span class="line"><span class="keyword">where</span> DATE_SUB(w1.recordDate, <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>) <span class="operator">=</span> w2.recordDate</span><br><span class="line">  <span class="keyword">and</span> w1.temperature <span class="operator">&gt;</span> w2.temperature</span><br></pre></td></tr></table></figure><h2 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h2><h3 id="SQL-DATE函数"><a href="#SQL-DATE函数" class="headerlink" title="SQL DATE函数"></a><a href="https://www.w3school.com.cn/sql/sql_dates.asp">SQL DATE函数</a></h3><h1 id="262-行程和用户"><a href="#262-行程和用户" class="headerlink" title="262. 行程和用户"></a><a href="https://leetcode-cn.com/problems/trips-and-users/">262. 行程和用户</a></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> Request_at                                                              <span class="keyword">as</span> `<span class="keyword">Day</span>`,</span><br><span class="line">       <span class="built_in">cast</span>(<span class="built_in">count</span>(Status <span class="operator">!=</span> <span class="string">&#x27;completed&#x27;</span> <span class="keyword">or</span> <span class="keyword">null</span>) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> <span class="type">decimal</span>(<span class="number">10</span>, <span class="number">2</span>)) <span class="keyword">as</span> `Cancellation Rate`</span><br><span class="line"><span class="keyword">from</span> Trips <span class="keyword">as</span> t,</span><br><span class="line">     (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Users <span class="keyword">where</span> Role <span class="operator">=</span> <span class="string">&#x27;client&#x27;</span>) <span class="keyword">as</span> cli,</span><br><span class="line">     (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Users <span class="keyword">where</span> Role <span class="operator">=</span> <span class="string">&#x27;driver&#x27;</span>) <span class="keyword">as</span> dri</span><br><span class="line"><span class="keyword">where</span> t.Client_Id <span class="operator">=</span> cli.Users_Id</span><br><span class="line">  <span class="keyword">and</span> t.Driver_Id <span class="operator">=</span> dri.Users_Id</span><br><span class="line">  <span class="keyword">and</span> cli.Banned <span class="operator">=</span> <span class="string">&#x27;No&#x27;</span></span><br><span class="line">  <span class="keyword">and</span></span><br><span class="line">  #dri.Banned<span class="operator">=</span><span class="string">&#x27;No&#x27;</span> <span class="keyword">and</span></span><br><span class="line">    t.Request_at <span class="keyword">between</span> <span class="string">&#x27;2013-10-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2013-10-03&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Request_at</span><br></pre></td></tr></table></figure><p>注：倒数第三行注释掉是因为中英文版力扣题意不一样，英文定义的非禁止用户原话是“unbanned users (<strong>both client and driver must not be banned</strong>)”，中文版翻译直接把括号部分忽略掉。忽略就算了吧我以为出题人只是语文不及格，结果有一个测试用例就是愉悦地在Users表里设置了3个Banned的司机，计算出来的非禁止用户生成订单也把这些司机的订单算进去了，Banned字段有效的仅仅是乘客，原来出题人思想道德也不及格，这道题“困难”水平是难在了这里，我直接给你妈拍手叫好。</p><h2 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h2><h3 id="保留两位小数"><a href="#保留两位小数" class="headerlink" title="保留两位小数"></a>保留两位小数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">round(number,<span class="number">2</span>) #四舍五入</span><br><span class="line"><span class="built_in">cast</span>(number <span class="keyword">as</span> <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>)) #仅保留前两位，去尾法</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/hyfstyle/article/details/90054298">Sql 保留两位小数</a></p><h3 id="count-里加上条件表达式一定要加or-NULL"><a href="#count-里加上条件表达式一定要加or-NULL" class="headerlink" title="count()里加上条件表达式一定要加or NULL"></a><code>count()</code>里加上条件表达式一定要加<code>or NULL</code></h3><p>count(‘任意内容’)都会统计出所有记录数，因为count只有在遇见null时不计数，即count(null)==0，因此前者单引号内不管输入什么值都会统计出所有记录数，所以如果要在count()函数里加上表达式的话一定要在后面加上<code>or NULL</code>。</p><p>参考：<a href="https://blog.csdn.net/qq_32719287/article/details/79513164">sql 语句中count()有条件的时候为什么要加上or null</a></p><h3 id="当需要count-的东西是二值化的时候改用avg"><a href="#当需要count-的东西是二值化的时候改用avg" class="headerlink" title="当需要count()的东西是二值化的时候改用avg()"></a>当需要<code>count()</code>的东西是二值化的时候改用<code>avg()</code></h3><p>在题解里看到一个<a href="https://leetcode-cn.com/problems/trips-and-users/solution/ci-ti-bu-nan-wei-fu-za-er-by-luanz/">拍案叫绝的方法</a>，原理：求多个0和1的平均，最后得到的就是1的比例</p><h1 id="595-大的国家"><a href="#595-大的国家" class="headerlink" title="595. 大的国家"></a><a href="https://leetcode-cn.com/problems/big-countries/">595. 大的国家</a></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">SELECT</span> name,population,area <span class="keyword">FROM</span> World <span class="keyword">WHERE</span> area<span class="operator">&gt;</span><span class="number">3000000</span> <span class="keyword">OR</span> population<span class="operator">&gt;</span><span class="number">25000000</span></span><br></pre></td></tr></table></figure><h1 id="596-超过5名学生的课"><a href="#596-超过5名学生的课" class="headerlink" title="596. 超过5名学生的课"></a><a href="https://leetcode-cn.com/problems/classes-more-than-5-students/">596. 超过5名学生的课</a></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> class <span class="keyword">from</span> courses <span class="keyword">group</span> <span class="keyword">by</span> class <span class="keyword">having</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> student)<span class="operator">&gt;=</span><span class="number">5</span></span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> class</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> class, <span class="built_in">count</span>(<span class="keyword">distinct</span> student) <span class="keyword">as</span> num <span class="keyword">from</span> courses <span class="keyword">group</span> <span class="keyword">by</span> class) c</span><br><span class="line"><span class="keyword">where</span> c.num <span class="operator">&gt;=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h1 id="601-体育馆的人流量"><a href="#601-体育馆的人流量" class="headerlink" title="601. 体育馆的人流量"></a><a href="https://leetcode-cn.com/problems/human-traffic-of-stadium/">601. 体育馆的人流量</a></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> f.Id <span class="keyword">as</span> id, f.visit_date, f.people</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">      <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span>, <span class="built_in">lead</span>(b.CNT, <span class="number">1</span>) <span class="keyword">over</span> () <span class="keyword">as</span> after</span><br><span class="line">            <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span>,</span><br><span class="line">                         <span class="keyword">case</span></span><br><span class="line">                             <span class="keyword">when</span> s.people <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">then</span> <span class="variable">@count</span> :<span class="operator">=</span> <span class="variable">@count</span> <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">                             <span class="keyword">when</span> s.id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="variable">@count</span> :<span class="operator">=</span> <span class="number">0</span></span><br><span class="line">                             <span class="keyword">end</span> <span class="keyword">as</span> CNT</span><br><span class="line">                  <span class="keyword">from</span> Stadium <span class="keyword">as</span> s,</span><br><span class="line">                       (<span class="keyword">select</span> <span class="variable">@count</span> :<span class="operator">=</span> <span class="number">0</span>) <span class="keyword">as</span> c) <span class="keyword">as</span> b) <span class="keyword">as</span> d</span><br><span class="line">      <span class="keyword">where</span> (d.after <span class="operator">=</span> <span class="number">0</span> <span class="keyword">or</span> d.after <span class="keyword">is</span> <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">and</span> d.CNT <span class="operator">&gt;=</span> <span class="number">3</span>) <span class="keyword">as</span> e,</span><br><span class="line">     Stadium <span class="keyword">as</span> f</span><br><span class="line"><span class="keyword">where</span> f.Id <span class="keyword">between</span> e.Id <span class="operator">-</span> e.CNT <span class="operator">+</span> <span class="number">1</span> <span class="keyword">and</span> e.Id</span><br></pre></td></tr></table></figure><p>评论区提到的利用窗口函数的另一种没这么笨重的方法（用了一个临时表）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> t2.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">         <span class="keyword">select</span> <span class="operator">*</span>,</span><br><span class="line">                <span class="built_in">lead</span>(people, <span class="number">1</span>) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> visit_date ) <span class="keyword">as</span> p2,</span><br><span class="line">                <span class="built_in">lead</span>(people, <span class="number">2</span>) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> visit_date ) <span class="keyword">as</span> p3</span><br><span class="line">         <span class="keyword">from</span> Stadium</span><br><span class="line">     ) t,</span><br><span class="line">     Stadium t2</span><br><span class="line"><span class="keyword">where</span> t.people <span class="operator">&gt;=</span> <span class="number">100</span></span><br><span class="line">  <span class="keyword">and</span> p2 <span class="operator">&gt;=</span> <span class="number">100</span></span><br><span class="line">  <span class="keyword">and</span> p3 <span class="operator">&gt;=</span> <span class="number">100</span></span><br><span class="line">  <span class="keyword">and</span> t2.id <span class="operator">&gt;=</span> t.id</span><br><span class="line">  <span class="keyword">and</span> t2.id <span class="operator">-</span> <span class="number">2</span> <span class="operator">&lt;=</span> t.id</span><br></pre></td></tr></table></figure><h1 id="620-有趣的电影"><a href="#620-有趣的电影" class="headerlink" title="620. 有趣的电影"></a><a href="https://leetcode-cn.com/problems/not-boring-movies/">620. 有趣的电影</a></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> id, movie, description, rating</span><br><span class="line"><span class="keyword">from</span> cinema</span><br><span class="line"><span class="keyword">where</span> description <span class="operator">!=</span> <span class="string">&#x27;boring&#x27;</span></span><br><span class="line">  <span class="keyword">and</span> id <span class="operator">%</span> <span class="number">2</span> <span class="operator">!=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> rating <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>就这么简单一道题还有人玩得骚，用位运算，奇数和1做&amp;操作得到1，偶数和1做&amp;操作得到0。：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">id,</span><br><span class="line">movie,</span><br><span class="line">description,</span><br><span class="line">rating</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">cinema</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">id <span class="operator">&amp;</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">AND</span> description <span class="operator">&lt;&gt;</span> <span class="string">&#x27;boring&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">rating <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h1 id="626-换座位"><a href="#626-换座位" class="headerlink" title="626. 换座位"></a><a href="https://leetcode-cn.com/problems/exchange-seats/">626. 换座位</a></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> id,</span><br><span class="line">       ifnull(<span class="keyword">case</span></span><br><span class="line">                  <span class="keyword">when</span> id <span class="operator">&amp;</span> <span class="number">1</span> <span class="keyword">then</span> <span class="built_in">lead</span>(student, <span class="number">1</span>) <span class="keyword">over</span> ()</span><br><span class="line">                  <span class="keyword">when</span> id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="built_in">lag</span>(student, <span class="number">1</span>) <span class="keyword">over</span> ()</span><br><span class="line">                  <span class="keyword">end</span>, student) <span class="keyword">as</span> `student`</span><br><span class="line"><span class="keyword">from</span> seat</span><br></pre></td></tr></table></figure><p>看了一圈答案发现大家都是换id然后最后再按id排一下序的（<a href="https://leetcode-cn.com/problems/exchange-seats/solution/jian-dan-yi-dong-xiao-lu-ji-bai-suo-you-by-fan-lu-/">用if交换id题解</a>），原来小丑是我自己。</p><h1 id="627-变更性别"><a href="#627-变更性别" class="headerlink" title="627. 变更性别"></a><a href="https://leetcode-cn.com/problems/swap-salary/">627. 变更性别</a></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">update salary</span><br><span class="line"><span class="keyword">set</span> sex<span class="operator">=</span></span><br><span class="line">        <span class="keyword">case</span></span><br><span class="line">            <span class="keyword">when</span> sex <span class="operator">=</span> <span class="string">&#x27;m&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;f&#x27;</span></span><br><span class="line">            <span class="keyword">when</span> sex <span class="operator">=</span> <span class="string">&#x27;f&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;m&#x27;</span></span><br><span class="line">            <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>评论区有用if来判断的，更简洁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update salary <span class="keyword">set</span> sex <span class="operator">=</span> if(sex <span class="operator">=</span> <span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;m&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="1179-重新格式化部门表"><a href="#1179-重新格式化部门表" class="headerlink" title="1179. 重新格式化部门表"></a><a href="https://leetcode-cn.com/problems/reformat-department-table/">1179. 重新格式化部门表</a></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> id,</span><br><span class="line">       <span class="built_in">SUM</span>(Jan_Revenue) <span class="keyword">as</span> <span class="string">&#x27;Jan_Revenue&#x27;</span>,</span><br><span class="line">       <span class="built_in">SUM</span>(Feb_Revenue) <span class="keyword">as</span> <span class="string">&#x27;Feb_Revenue&#x27;</span>,</span><br><span class="line">       <span class="built_in">SUM</span>(Mar_Revenue) <span class="keyword">as</span> <span class="string">&#x27;Mar_Revenue&#x27;</span>,</span><br><span class="line">       <span class="built_in">SUM</span>(Apr_Revenue) <span class="keyword">as</span> <span class="string">&#x27;Apr_Revenue&#x27;</span>,</span><br><span class="line">       <span class="built_in">SUM</span>(May_Revenue) <span class="keyword">as</span> <span class="string">&#x27;May_Revenue&#x27;</span>,</span><br><span class="line">       <span class="built_in">SUM</span>(Jun_Revenue) <span class="keyword">as</span> <span class="string">&#x27;Jun_Revenue&#x27;</span>,</span><br><span class="line">       <span class="built_in">SUM</span>(Jul_Revenue) <span class="keyword">as</span> <span class="string">&#x27;Jul_Revenue&#x27;</span>,</span><br><span class="line">       <span class="built_in">SUM</span>(Aug_Revenue) <span class="keyword">as</span> <span class="string">&#x27;Aug_Revenue&#x27;</span>,</span><br><span class="line">       <span class="built_in">SUM</span>(Sep_Revenue) <span class="keyword">as</span> <span class="string">&#x27;Sep_Revenue&#x27;</span>,</span><br><span class="line">       <span class="built_in">SUM</span>(Oct_Revenue) <span class="keyword">as</span> <span class="string">&#x27;Oct_Revenue&#x27;</span>,</span><br><span class="line">       <span class="built_in">SUM</span>(Nov_Revenue) <span class="keyword">as</span> <span class="string">&#x27;Nov_Revenue&#x27;</span>,</span><br><span class="line">       <span class="built_in">SUM</span>(Dec_Revenue) <span class="keyword">as</span> <span class="string">&#x27;Dec_Revenue&#x27;</span></span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> id,</span><br><span class="line">             <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="string">&#x27;Jan&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">end</span> <span class="keyword">as</span> <span class="string">&#x27;Jan_Revenue&#x27;</span>,</span><br><span class="line">             <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="string">&#x27;Feb&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">end</span> <span class="keyword">as</span> <span class="string">&#x27;Feb_Revenue&#x27;</span>,</span><br><span class="line">             <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="string">&#x27;Mar&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">end</span> <span class="keyword">as</span> <span class="string">&#x27;Mar_Revenue&#x27;</span>,</span><br><span class="line">             <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="string">&#x27;Apr&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">end</span> <span class="keyword">as</span> <span class="string">&#x27;Apr_Revenue&#x27;</span>,</span><br><span class="line">             <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="string">&#x27;May&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">end</span> <span class="keyword">as</span> <span class="string">&#x27;May_Revenue&#x27;</span>,</span><br><span class="line">             <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="string">&#x27;Jun&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">end</span> <span class="keyword">as</span> <span class="string">&#x27;Jun_Revenue&#x27;</span>,</span><br><span class="line">             <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="string">&#x27;Jul&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">end</span> <span class="keyword">as</span> <span class="string">&#x27;Jul_Revenue&#x27;</span>,</span><br><span class="line">             <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="string">&#x27;Aug&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">end</span> <span class="keyword">as</span> <span class="string">&#x27;Aug_Revenue&#x27;</span>,</span><br><span class="line">             <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="string">&#x27;Sep&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">end</span> <span class="keyword">as</span> <span class="string">&#x27;Sep_Revenue&#x27;</span>,</span><br><span class="line">             <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="string">&#x27;Oct&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">end</span> <span class="keyword">as</span> <span class="string">&#x27;Oct_Revenue&#x27;</span>,</span><br><span class="line">             <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="string">&#x27;Nov&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">end</span> <span class="keyword">as</span> <span class="string">&#x27;Nov_Revenue&#x27;</span>,</span><br><span class="line">             <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="string">&#x27;Dec&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">end</span> <span class="keyword">as</span> <span class="string">&#x27;Dec_Revenue&#x27;</span></span><br><span class="line">      <span class="keyword">from</span> Department) c</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> id</span><br></pre></td></tr></table></figure><p>参考思路：<a href="https://blog.csdn.net/aimomo007/article/details/103886375">SQL 语句题 | 重新格式化部门表</a>，可以SUM()和case合用精简语句。</p><h2 id="知识点-8"><a href="#知识点-8" class="headerlink" title="知识点"></a>知识点</h2><h3 id="group-by本质论"><a href="#group-by本质论" class="headerlink" title="group by本质论"></a><a href="https://leetcode-cn.com/problems/reformat-department-table/solution/group-byben-zhi-lun-by-loverxp-7mgy/"><code>group by</code>本质论</a></h3>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode刷题——shell专题（No.192-195）</title>
      <link href="2021/02/01/shell_leetcode/"/>
      <url>2021/02/01/shell_leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="192-统计词频"><a href="#192-统计词频" class="headerlink" title="192. 统计词频"></a><a href="https://leetcode-cn.com/problems/word-frequency/">192. 统计词频</a></h1><h2 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h2><p>解1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read from the file words.txt and output the word frequency list to stdout.</span></span><br><span class="line">awk <span class="string">&#x27;&#123;for(a=1;a&lt;=NF;a++) print $a&#125;&#x27;</span> words.txt | sort | uniq -c | sort -nr | awk <span class="string">&#x27;&#123;print $2,$1&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="awk分割出的每一行各字段分行打印"><a href="#awk分割出的每一行各字段分行打印" class="headerlink" title="awk分割出的每一行各字段分行打印"></a><code>awk</code>分割出的每一行各字段分行打印</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;for(a=1;a&lt;=NF;a++) print $a&#125;&#x27;</span> words.txt</span><br></pre></td></tr></table></figure><p>注：<code>awk</code>里的<code>print</code>默认打印之后输出一个换行，若不换行用<code>printf</code>。</p><h3 id="统计文本文件中重复出现的行列"><a href="#统计文本文件中重复出现的行列" class="headerlink" title="统计文本文件中重复出现的行列"></a>统计文本文件中重复出现的行列</h3><p><code>uniq</code>+<code>sort</code>结合使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort test.txt | uniq -c</span><br></pre></td></tr></table></figure><p>注：-c原理是接下来的字符串相同则加一，如果不进行<code>sort</code>排序的话将无法统计数目。</p><h3 id="降序排列"><a href="#降序排列" class="headerlink" title="降序排列"></a>降序排列</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -r</span><br></pre></td></tr></table></figure><h1 id="193-有效电话号码"><a href="#193-有效电话号码" class="headerlink" title="193. 有效电话号码"></a><a href="https://leetcode-cn.com/problems/valid-phone-numbers/">193. 有效电话号码</a></h1><h2 id="提交记录-1"><a href="#提交记录-1" class="headerlink" title="提交记录"></a>提交记录</h2><p>解1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read from the file file.txt and output all valid phone numbers to stdout.</span></span><br><span class="line">awk <span class="string">&#x27;/(^[0-9]&#123;3&#125;-[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$)|(^\([0-9]&#123;3&#125;\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$)/&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><p>解2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read from the file file.txt and output all valid phone numbers to stdout.</span></span><br><span class="line">sed -n -r <span class="string">&#x27;/(^[0-9]&#123;3&#125;-[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$)|(^\([0-9]&#123;3&#125;\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$)/p&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><p>解3：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read from the file file.txt and output all valid phone numbers to stdout.</span></span><br><span class="line">sed -n -r <span class="string">&#x27;/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/p&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><h3 id="正则表达式实现或运算"><a href="#正则表达式实现或运算" class="headerlink" title="正则表达式实现或运算"></a>正则表达式实现或运算</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(PatternA|PatternB)</span><br></pre></td></tr></table></figure><p>注意：如果是需要完全匹配PatternA或是完全匹配PattenB，则<code>^</code>和<code>$</code>在两个Pattern语句里都需要写，而不是写在括号外面。</p><p>参考：<a href="https://blog.csdn.net/weixin_41584545/article/details/83585963">正则表达式实现与或非</a></p><h3 id="正则表达式空格匹配"><a href="#正则表达式空格匹配" class="headerlink" title="正则表达式空格匹配"></a>正则表达式空格匹配</h3><p>若要匹配任何空白字符，包括空格、制表符、换页符等等：<code>\s</code>，等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</p><p>若只需要匹配单个空格，直接输入空格即可：<code> </code></p><h3 id="正则表达式中的-d在awk里无法识别"><a href="#正则表达式中的-d在awk里无法识别" class="headerlink" title="正则表达式中的\d在awk里无法识别"></a>正则表达式中的<code>\d</code>在<code>awk</code>里无法识别</h3><p>改为<code>[0-9]</code></p><h3 id="sed使用扩展类正则"><a href="#sed使用扩展类正则" class="headerlink" title="sed使用扩展类正则"></a><code>sed</code>使用扩展类正则</h3><p>必须加上参数<code>-r</code></p><h3 id="正则表达式学习参考"><a href="#正则表达式学习参考" class="headerlink" title="正则表达式学习参考"></a>正则表达式学习参考</h3><p><a href="https://leetcode-cn.com/problems/valid-phone-numbers/solution/zheng-ze-biao-da-shi-zhong-xian-ding-fu-yu-ding-we/">一篇搞定：正则表达式中限定符与定位符的灵活使用</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647520125&idx=1&sn=603752dddb5aca7ffdd7d9077e7016b1&chksm=87d24c7eb0a5c568f2a89f9a6cf7b763340787ec4348b8cf6cd66b7509711ea318542d245c3a&scene=21#wechat_redirect">SHELL编程正则表达式，这一篇就够了</a></p><p><a href="http://c.runoob.com/front-end/854">在线测试工具&amp;常用正则表达式</a></p><h1 id="194-转置文件"><a href="#194-转置文件" class="headerlink" title="194. 转置文件"></a><a href="https://leetcode-cn.com/problems/transpose-file/">194. 转置文件</a></h1><h2 id="提交记录-2"><a href="#提交记录-2" class="headerlink" title="提交记录"></a>提交记录</h2><p>解1（<strong>逻辑没问题，但是超出时间限制</strong>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Read from the file file.txt and print its transposed content to stdout.</span></span><br><span class="line">M=`awk <span class="string">&#x27;&#123;print NR&#125;&#x27;</span> file.txt | tail -n 1` <span class="comment">#获取行数</span></span><br><span class="line">N=`awk <span class="string">&#x27;&#123;print NF&#125;&#x27;</span> file.txt | tail -n 1` <span class="comment">#获取列数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$M</span> -eq 1 ];<span class="keyword">then</span></span><br><span class="line">        awk <span class="string">&#x27;&#123;for(a=1;a&lt;=NF;a++) print $a&#125;&#x27;</span> file.txt</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> ((i=1;i&lt;=<span class="variable">$N</span>;i++))</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                <span class="keyword">for</span> ((j=1;j&lt;=<span class="variable">$M</span>;j++))</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                        awk -v J=<span class="variable">$j</span> -v I=<span class="variable">$i</span> <span class="string">&#x27;NR==J&#123;printf $I&#125;&#x27;</span> file.txt</span><br><span class="line">                        <span class="keyword">if</span> [ <span class="variable">$j</span> -lt <span class="variable">$M</span> ];<span class="keyword">then</span></span><br><span class="line">                                <span class="built_in">echo</span> -e <span class="string">&#x27; \c&#x27;</span></span><br><span class="line">                        <span class="keyword">fi</span></span><br><span class="line">                <span class="keyword">done</span></span><br><span class="line">                <span class="built_in">echo</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>解2（<strong>利用<code>awk</code>数组</strong>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read from the file file.txt and print its transposed content to stdout.</span></span><br><span class="line">awk <span class="string">&#x27;&#123;for(a=1;a&lt;=NF;a++) array[NR,a]=$a;&#125; END&#123;for(i=1;i&lt;=NF;i++) &#123;for(j=1;j&lt;NR;j++) printf array[j,i]&quot; &quot;; print array[j,i];&#125; &#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><p>解3（主要是<code>xargs</code>跟这道题的格式绝配）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read from the file file.txt and print its transposed content to stdout.</span></span><br><span class="line">N=`awk <span class="string">&#x27;&#123;print NF&#125;&#x27;</span> file.txt | tail -n 1` <span class="comment">#获取列数</span></span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;=<span class="variable">$N</span>;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        cut -d <span class="string">&quot; &quot;</span> -f <span class="variable">$i</span> file.txt | xargs</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><h3 id="echo输出不换行"><a href="#echo输出不换行" class="headerlink" title="echo输出不换行"></a><code>echo</code>输出不换行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&#x27;输出的内容&#x27;</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;输出的内容\c&#x27;</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/wteruiycbqqvwt/article/details/98988462">echo不换行输出的两种方式</a></p><h3 id="把shell变量传给awk"><a href="#把shell变量传给awk" class="headerlink" title="把shell变量传给awk"></a>把shell变量传给<code>awk</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -v var=value ... <span class="comment">#value可以调用前面shell中定义的变量，用上$</span></span><br></pre></td></tr></table></figure><p>注：一个<code>-v</code>后接一个变量赋值，若要传多个变量值，需要接着用多个<code>-v</code>。</p><h3 id="awk流程控制（if和for循环）"><a href="#awk流程控制（if和for循环）" class="headerlink" title="awk流程控制（if和for循环）"></a><code>awk</code>流程控制（<code>if</code>和<code>for</code>循环）</h3><p>参考：<a href="https://blog.csdn.net/weixin_30764771/article/details/95272685?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">linux shell awk 流程控制语句（if,for,while,do)详细介绍</a></p><h3 id="awk数组"><a href="#awk数组" class="headerlink" title="awk数组"></a><code>awk</code>数组</h3><p>注：<code>awk</code>数组创建时的下标可以直接调用awk脚本里的变量作为索引，不用加引号变为字符串，读数组值时同理。</p><p>参考：<a href="https://blog.csdn.net/dghggij/article/details/83654642">linux awk 数组和循环</a>、<a href="https://www.runoob.com/w3cnote/awk-arrays.html">菜鸟教程：AWK 数组</a></p><h3 id="awk参考学习"><a href="#awk参考学习" class="headerlink" title="awk参考学习"></a><code>awk</code>参考学习</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647520143&idx=1&sn=57dac34308c59e40ea37ef66c9fdba07&chksm=87d24c8cb0a5c59a6caff4ff62a119021f80f8d00ef012059a4786e9b44d43a1ad321aae65d3&scene=21#wechat_redirect">号称三剑客之首的awk，开始秀！</a></p><h3 id="xargs：把多行打印到一行里"><a href="#xargs：把多行打印到一行里" class="headerlink" title="xargs：把多行打印到一行里"></a><code>xargs</code>：把多行打印到一行里</h3><p>参考：<a href="https://www.runoob.com/linux/linux-comm-xargs.html">菜鸟教程：Linux xargs 命令</a></p><h1 id="195-第十行"><a href="#195-第十行" class="headerlink" title="195. 第十行"></a><a href="https://leetcode-cn.com/problems/tenth-line/">195. 第十行</a></h1><h2 id="提交记录-3"><a href="#提交记录-3" class="headerlink" title="提交记录"></a>提交记录</h2><p>解1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read from the file file.txt and output the tenth line to stdout.</span></span><br><span class="line">line=`awk <span class="string">&#x27;&#123;print NR&#125;&#x27;</span> file.txt | tail -n 1`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$line</span> -lt 10 ];<span class="keyword">then</span></span><br><span class="line">    :</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    sed -n <span class="string">&#x27;10p&#x27;</span> file.txt</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>解2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read from the file file.txt and output the tenth line to stdout.</span></span><br><span class="line">line=`awk <span class="string">&#x27;&#123;print NR&#125;&#x27;</span> file.txt | tail -n 1`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$line</span> -lt 10 ];<span class="keyword">then</span></span><br><span class="line">    :</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    awk <span class="string">&#x27;NR==10&#x27;</span> file.txt</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><h3 id="健全性"><a href="#健全性" class="headerlink" title="健全性"></a>健全性</h3><p>原题里的说明里有一句话：“如果文件少于十行，你应当输出什么？”，因此需要一个<code>if</code>来判断文件行数是否少于10行</p><h3 id="获取文件行数"><a href="#获取文件行数" class="headerlink" title="获取文件行数"></a>获取文件行数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print NR&#125;&#x27;</span> file.txt | tail -n 1</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.jb51.net/article/61943.htm">Shell脚本统计文件行数的8种方法</a></p><h3 id="把命令结果作为值赋给自定义变量（两种方式）"><a href="#把命令结果作为值赋给自定义变量（两种方式）" class="headerlink" title="把命令结果作为值赋给自定义变量（两种方式）"></a>把命令结果作为值赋给自定义变量（两种方式）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全程没有空格，变量名左边不用加$</span></span><br><span class="line">变量名=`命令`</span><br><span class="line">变量名=$(命令)</span><br></pre></td></tr></table></figure><blockquote><p>虽然上述两种方式都可以在Shell脚本中得到命令运行的结果，但是有一点是不一样的，那就是反引号执行命令不支持嵌套，不能实现反引号中再出现反引号，而 <code>$(command)</code>的方式是支持嵌套的。</p></blockquote><p>参考：<a href="https://blog.csdn.net/albertsh/article/details/107274490">Shell脚本中获取命令运行结果、特殊变量使用、条件判断等常用操作</a></p><h3 id="condition-打印出条件判断的结果"><a href="#condition-打印出条件判断的结果" class="headerlink" title="[ condition ]打印出条件判断的结果"></a><code>[ condition ]</code>打印出条件判断的结果</h3><p>在终端里执行完<code>[ condition ]</code>之后执行<code>echo $?</code>，若打印出0则结果为true，打印出1则结果为false。</p><h3 id="echo不打印任何信息"><a href="#echo不打印任何信息" class="headerlink" title="echo不打印任何信息"></a><code>echo</code>不打印任何信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">: <span class="comment">#单个冒号，不执行任何操作，相当于终端里摁下enter键</span></span><br><span class="line"><span class="built_in">echo</span> <span class="comment">#echo后面不加任何变量，打印出一个空行</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.cnblogs.com/ssc4469/p/4094336.html">shell不打印</a></p><h3 id="输出文件中的第10行"><a href="#输出文件中的第10行" class="headerlink" title="输出文件中的第10行"></a>输出文件中的第10行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;10p&#x27;</span> file.txt</span><br><span class="line">awk <span class="string">&#x27;NR==10&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><h1 id="参考思路"><a href="#参考思路" class="headerlink" title="参考思路"></a>参考思路</h1><p><a href="https://mp.weixin.qq.com/s/EI63RZZcPzJT4c0zl8XQSA">LeetCode上稀缺的四道shell编程题解析</a></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记（九）——异常</title>
      <link href="2021/01/30/Java_Exception/"/>
      <url>2021/01/30/Java_Exception/</url>
      
        <content type="html"><![CDATA[<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://docs.oracle.com/javase/8/docs/api/">JDK8帮助文档</a></p><p><a href="https://www.bilibili.com/video/BV12J41137hu">狂神说Java视频</a></p><h1 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h1><p>异常指程序运行中出现的不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等，异常发生在程序运行期间，它影响了正常的程序执行流程。</p><p>三种类型：</p><ul><li>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li><li>运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li>错误（<strong>ERROR</strong>）：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到。</li></ul><h1 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h1><p>Java把异常当作对象来处理，并定义一个基类<code>java.lang.Throwable</code>作为所有异常的超类。在Java API中已经定义了许多异常类，这些异常类分为两大类——错误（Error）和异常（Exception）。</p><p><img src="http://img.cuper.top/java20210130231059.png" alt="QQ截图20210130231041"></p><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。</p><p>Java虚拟机运行错误（Virtual MachineError），当JVM不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时。Java虛拟机（JVM）一般会选择线程终止；</p><p>还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError） 、链接错误（LinkageError）。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。                                                </p><h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>在Exception分支中有一个重要的子类RuntimeException（运行时异常）：</p><ul><li>ArrayIndexOutOfBoundsException（数组下标越界）</li><li>NullPointerException（空指针异常）</li><li>ArithmeticException（算术异常）</li><li>MissingResourceException（丢失资源）</li><li>ClassNotFoundException（找不到类）</li><li>等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。</li></ul><p>这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><blockquote><p>Error和Exception的区别：</p><p>Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虛拟机（JVM）一般会选择终止线程。</p><p>Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能地去处理这些异常。</p></blockquote><h1 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h1><p>异常处理五个关键字：<code>try</code>、<code>catch</code>、<code>finally</code>、<code>throw</code>、<code>throws</code></p><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//try监控区域</span></span><br><span class="line">            System.out.println(a/b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;<span class="comment">//catch捕获异常，括号内为想要捕获的异常类型，最高级别为Throwable</span></span><br><span class="line">            <span class="comment">//若程序出现catch异常的话就执行这个代码块</span></span><br><span class="line">            System.out.println(<span class="string">&quot;程序出现异常，变量b不能为0&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;<span class="comment">//处理善后工作，可以不用，一般用于IO流、资源的关闭工作</span></span><br><span class="line">            <span class="comment">//不管有没有出现异常，最终都会执行这个代码块</span></span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若要捕获多个异常：需要从小到大</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(a/b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Error e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;<span class="comment">//前一个catch异常级别必须要比后一个低或同级，否则报错：Exception &#x27;java.lang.xxx&#x27; has already been caught</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Throwable&quot;</span>);</span><br><span class="line">        &#125;<span class="comment">//多个catch只会执行从上往下碰到的第一个符号的抛出程序</span></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Test().a();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (StackOverflowError e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;StackOverflowError&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">////快捷键生成：Ctrl+Alt+T</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(a/b);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();<span class="comment">//打印错误的栈信息</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;b();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;a();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IDEA生成try…catch代码快捷键：选中某一行代码，Ctrl+Alt+T，打开可包裹的代码块，选中try/catch或try/catch/finally即可。</p></blockquote><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test().test(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">new</span> Test().test2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b==<span class="number">0</span>)&#123;<span class="comment">//关键字throw：主动抛出异常，一般在方法中使用</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把sout代码注释掉也会在屏幕中打印错误的栈信息：</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Exception in thread &quot;main&quot; java.lang.ArithmeticException</span></span><br><span class="line"><span class="comment">    at Exception.Test.test(Test.java:16)</span></span><br><span class="line"><span class="comment">    at Exception.Test.main(Test.java:10)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//System.out.println(a/b);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设这个方法中处理不了这个异常，则需要在方法上抛出异常，关键字：throws</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> ArithmeticException</span>&#123;</span><br><span class="line">        System.out.println(a/b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>throws</code>：用来声明一个方法可能产生的所有异常，不做任何处理而是将异常往上传，谁调用我我就抛给谁。</strong></p><p> 用在方法声明后面，跟的是异常类名<br> 可以跟多个异常类名，用逗号隔开<br> 表示抛出异常，由该方法的调用者来处理<br> throws表示出现异常的一种可能性，并不一定会发生这些异常</p><p><strong><code>throw</code>：则是用来抛出一个具体的异常类型。</strong></p><p>用在方法体内，跟的是异常对象名<br> 只能抛出一个异常对象名<br> 表示抛出异常，由方法体内的语句处理<br> throw则是抛出了异常，执行throw则一定抛出了某种异常</p></blockquote><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>除了使用Java内置的异常类描述大部分异常情况之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可。</p><p>步骤：</p><ol><li>创建自定义异常类。</li><li>在方法中通过<code>throw</code>抛出异常对象。</li><li>如果在当前抛出异常的方法中处理异常，可以使用try/catch语句捕获并处理；否则在方法的声明处通过<code>throws</code>指明要抛出给方法调用者的异常，继续进行下一步操作。</li><li>在出现异常的方法的调用者中捕获并处理异常。</li></ol><p>自定义异常类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义异常类：传递的数字如果大于10就抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> detail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.detail = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了打印出这个信息</span></span><br><span class="line">    <span class="comment">//重要方法：toString()</span></span><br><span class="line">    <span class="comment">// Alt+inset可以快捷插入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyException&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;detail=&quot;</span> + detail +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常：&quot;</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可能会存在异常的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> MyException </span>&#123;<span class="comment">//抛出异常后，被main方法里的catch捕获到，执行sout语句</span></span><br><span class="line">        System.out.println(<span class="string">&quot;传递的参数为&quot;</span>+a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a&gt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(a);<span class="comment">//抛出</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实际应用中的经验总结"><a href="#实际应用中的经验总结" class="headerlink" title="实际应用中的经验总结"></a>实际应用中的经验总结</h1><ul><li>处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理</li><li>在多重catch块后面，可以加一个最大的<code>catch (Exception)</code>来处理可能会被遗漏的异常</li><li>对于不确定的代码，也可以加上try-catch，处理潜在的异常</li><li>尽量去处理异常，切忌只是简单地调用<code>printStackTrace()</code>去打印输出</li><li>具体如何处理异常，要根据不同的业务需求和异常类型去决定</li><li>尽量添加<code>finally</code>语句块去释放占用的资源</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程 </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记（八）——面向对象（static、抽象类、接口、内部类）</title>
      <link href="2021/01/27/Java_OOP_other/"/>
      <url>2021/01/27/Java_OOP_other/</url>
      
        <content type="html"><![CDATA[<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://docs.oracle.com/javase/8/docs/api/">JDK8帮助文档</a></p><p><a href="https://www.bilibili.com/video/BV12J41137hu">狂神说Java视频</a></p><h1 id="static总结"><a href="#static总结" class="headerlink" title="static总结"></a><code>static</code>总结</h1><h2 id="静态变量与静态方法"><a href="#静态变量与静态方法" class="headerlink" title="静态变量与静态方法"></a>静态变量与静态方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age;<span class="comment">//静态变量，在类中只有一个，对所有对象是共享的（多线程里常用）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> score;<span class="comment">//非静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;<span class="comment">//非静态方法</span></span><br><span class="line">        go();<span class="comment">//非静态方法里可以直接访问静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;<span class="comment">//静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        System.out.println(Student.age);<span class="comment">//静态变量推荐使用类名直接访问</span></span><br><span class="line">        <span class="comment">//System.out.println(Student.score);报错：Non-static field &#x27;score&#x27; cannot be referenced from a static context</span></span><br><span class="line">        System.out.println(s1.age);</span><br><span class="line">        System.out.println(s1.score);</span><br><span class="line"></span><br><span class="line">        s1.run();<span class="comment">//非静态方法需要通过对象调用</span></span><br><span class="line">        s1.go();</span><br><span class="line">        Student.go();<span class="comment">//静态方法直接用类名调用</span></span><br><span class="line">        go();<span class="comment">//在本类里可以</span></span><br><span class="line">        <span class="comment">//Student.run();报错：Non-static method &#x27;run()&#x27; cannot be referenced from a static context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//No.2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//代码块（匿名代码块），程序在执行时并不能调用主动调用</span></span><br><span class="line">        <span class="comment">//在创建对象的时候已经自动创建，且在构造器之前</span></span><br><span class="line">        <span class="comment">//一般用来赋初始值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;匿名代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//No.1</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//静态代码块，类一加载就执行且永久执行一次</span></span><br><span class="line">        <span class="comment">//可加载一些初始化的数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//No.3</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">静态代码块</span><br><span class="line">匿名代码块</span><br><span class="line">构造方法</span><br><span class="line">=================</span><br><span class="line">匿名代码块</span><br><span class="line">构造方法</span><br></pre></td></tr></table></figure><h2 id="静态导入包"><a href="#静态导入包" class="headerlink" title="静态导入包"></a>静态导入包</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import java.lang.Math.random;报错：Cannot resolve symbol &#x27;random&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.random;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.PI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Math.random());</span><br><span class="line">        System.out.println(random());<span class="comment">//静态导入包后可以直接使用方法</span></span><br><span class="line">        System.out.println(PI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p><code>abstract</code>修饰符可以用来修饰方法——抽象方法，或者修饰类——抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类，不能使用new来创建对象，是用来让子类继承的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象方法，只有方法声明没有方法实现，是用来让子类实现的</span></span><br><span class="line">    <span class="comment">//抽象方法必须要在抽象类里，否则报错：Abstract method in non-abstract class</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//抽象类中可以写普通方法，继承的子类也不需要一定重写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Action</span></span>&#123;</span><br><span class="line">    <span class="comment">//提示：Class &#x27;A&#x27; must either be declared abstract or implement abstract method &#x27;doSomething()&#x27; in &#x27;Action&#x27;</span></span><br><span class="line">    <span class="comment">//继承了抽象类的子类必须实现原抽象类里的所有抽象方法，除非这个继承类也是一个抽象类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>不能<code>new</code>抽象类，只能靠子类去实现，抽象类仅作为一种约束。</li><li>抽象类中可以写普通方法</li><li>抽象方法必须在抽象类中</li><li>意义：提高开放效率&amp;可扩展性</li></ol><blockquote><p>类是单继承的，接口是多继承的——所以抽象类其实用得不多</p></blockquote><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul><li>普通类：只有具体实现</li><li>抽象类：具体实现和规范（抽象方法）都有</li><li>接口：只有规范（声明定义），自己无法写方法，约束和实现分离（生产环境惯例：<strong>面向接口编程</strong>）</li></ul><blockquote><p>接口就是规范，定义的是一组规则，体现了现实世界里“如果你是……则必须能……”的思想。</p><p>接口的本质是契约，正如人类的法律一样制定好后大家都遵守。</p><p>OO的精髓是对对象的抽象——最能体现这一点的正是接口。</p></blockquote><p><strong>声明类的关键字是<code>class</code>，声明接口的关键字是<code>interface</code>。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接口中所有的属性默认都是public static final的，全局静态常量</span></span><br><span class="line">    <span class="comment">//直接写属性变量类型+名字+值即可</span></span><br><span class="line">    <span class="comment">//一般不会在接口里定义常量</span></span><br><span class="line">    <span class="keyword">int</span> AGE = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接口中所有的方法默认都是public abstract的</span></span><br><span class="line">    <span class="comment">//直接写返回值类型+方法名+形参即可</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimeService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">timer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口都需要有实现类</span></span><br><span class="line"><span class="comment">//类 implements 接口</span></span><br><span class="line"><span class="comment">//实现了接口的类就必须要重写接口的所有方法</span></span><br><span class="line"><span class="comment">//抽象类extends只能单继承，接口可以多继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span>,<span class="title">TimeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>接口作为约束</li><li>定义一些方法，让不同的人实现</li><li>接口不能被实例化，因为接口里没有构造方法</li><li><code>implements</code>可以实现多个接口，从而实现多继承</li><li>接口的实现类必须要重写接口中的所有方法</li></ul><blockquote><p>IDEA重写接口方法快捷键：Ctrl+I或Alt+insert选择Implement method。</p></blockquote><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>内部类：在一个类的内部再定义一个类。（若A类中定义了一个B类，那么B类相对于A类来说就称为内部类，A类相对于B类来说称为外部类。）</p><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外部类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是内部类方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//内部类可以直接访问外部类的私有变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getID</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">//通过外部类的实例化对象来实例化内部类</span></span><br><span class="line">        Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        inner.in();</span><br><span class="line">        inner.getID();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外部类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是内部类方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加上static之后的静态内部类无法访问外部类的非静态、私有变量</span></span><br><span class="line">        <span class="comment">//因为该内部类实例化在对象之前</span></span><br><span class="line">        <span class="comment">//以下方法报错：</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public void getID()&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(id);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">//Outer.Inner inner = outer.new Inner();报错Qualified new of static class，意为你能直接new一个静态内部类，就别通过外部类的实例了。</span></span><br><span class="line">        <span class="comment">//通过外部类直接实例化静态内部类</span></span><br><span class="line">        Outer.Inner inner = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">        inner.in();</span><br><span class="line">        <span class="comment">//inner.getID();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//局部内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//匿名内部类：没有名字初始化类，不用把实例保存到变量中</span></span><br><span class="line">        <span class="keyword">new</span> Apple().eat();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> UserService()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> OOP </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据可视化技术调研报告</title>
      <link href="2021/01/24/big_data_vis/"/>
      <url>2021/01/24/big_data_vis/</url>
      
        <content type="html"><![CDATA[<h1 id="功能需求（拟定）"><a href="#功能需求（拟定）" class="headerlink" title="功能需求（拟定）"></a>功能需求（拟定）</h1><ul><li>实时监控并展示服务器中的Hadoop集群运行状况，包括节点进程的运行与通信日志（报错的捕捉与报警）、存储空间的变化、配置文件信息等。</li><li>数据信息的图形化展示，展示数据库与数据表的信息（比如），</li><li>交互式的数据分析，封装好一些常用的SQL查询，能够在图形化界面操作直接展示表格与图形结果；封装一些数据分析算法并提供数据输入和参数设定的接口，能根据不同的数据源和参数选择实时运行出不同的实验结果。</li><li>提供自定义代码入口，在以后的研究中可以随时添加尚未封装进去的新的数据分析功能。</li></ul><h1 id="大数据VS传统可视化"><a href="#大数据VS传统可视化" class="headerlink" title="大数据VS传统可视化"></a>大数据VS传统可视化</h1><ul><li><p>面向的数据对象：大数据可视化工具必须能够处理半结构化和非结构化数据（大数据通常具有这种格式）</p></li><li><p>维度选择：需要做到精确，如果减小维度以使可视化程度降低，则可能最终会丢失有用的模式，但是如果使用所有维度，最终可能会导致可视化过于密集而无法用于可视化。</p></li><li><p>实时性：必须适应大数据的爆炸式增长需求，必须快速地收集分析数据、并对数据信息进行实时更新。</p></li><li><p>多种数据集成支持方式：大数据的数据来源不仅仅局限于数据库，数据可视化工具需要能够支持团队协作数据、数据仓库、文本等多种方式，并能够通过互联网进行展现。</p></li></ul><h1 id="数据可视化工具"><a href="#数据可视化工具" class="headerlink" title="数据可视化工具"></a>数据可视化工具</h1><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><p><a href="https://iclient.supermap.io/web/books/modern-web-gis-in-action/da-shu-ju-ke-shi-hua-ji-zhu/da-shu-ju-ke-shi-hua-chang-yong-gong-ju.html">参考来源</a></p><table><thead><tr><th align="left">开源工具</th><th align="left">商业工具</th></tr></thead><tbody><tr><td align="left">Processing</td><td align="left">Tableau</td></tr><tr><td align="left">Many Eyes</td><td align="left">Spotfire（TIBCO）</td></tr><tr><td align="left">D3.js</td><td align="left">QlikView</td></tr><tr><td align="left">R（基础包、lattice、ggplot2）</td><td align="left">FineBI</td></tr><tr><td align="left">ECharts</td><td align="left">SAS Visual Analytics</td></tr><tr><td align="left">Google Charts</td><td align="left">Adobe Illustrator</td></tr><tr><td align="left">Flot</td><td align="left">HighCharts</td></tr><tr><td align="left">Gephi</td><td align="left">iCharts</td></tr><tr><td align="left">Envision.js</td><td align="left">Jolicharts</td></tr><tr><td align="left">Prefuse</td><td align="left">Dundas Chart</td></tr><tr><td align="left">Arbor.js</td><td align="left">LightningChart</td></tr><tr><td align="left">Chart.js</td><td align="left">Microsoft Excel</td></tr><tr><td align="left">Paper.js</td><td align="left"></td></tr><tr><td align="left">NodeBox</td><td align="left"></td></tr></tbody></table><h2 id="部分开源工具"><a href="#部分开源工具" class="headerlink" title="部分开源工具"></a>部分开源工具</h2><h3 id="D3-js"><a href="#D3-js" class="headerlink" title="D3.js"></a><a href="https://d3js.org/">D3.js</a></h3><p>优点：免费的JavaScript库，可以将任意数据连接到HTML的文档对象模型（DOM），然后将数据驱动的转换应用于文档，通过DOM编程API可以将文档作为对象访问。支持用于交互和动画的大型数据集和动态行为，开发时可以通过浏览器的内置元素检查器进行调试。</p><p>缺点：入门需要花费的时间较多</p><p>适用于擅长JavaScript，SVG或DOM的开发人员。</p><h3 id="plotly"><a href="#plotly" class="headerlink" title="plotly"></a><a href="https://plotly.com/">plotly</a></h3><p>优点：用于创建图表和基于浏览器的开源Python图形库。可称为高级图表库，因为它是内置于D3.js库的顶部。可以使用该工具通过上载CSV文件或连接到SQL数据库来创建D3.js图表和地图。导出图片的质量较高，图形界面完全交互式。Plotly可以提供比较少见的图表，比如等高线图、烛台图（K线图）和3D图表，而大多数工具都没有这些图表。此外，Plotly的团队还维护着增长飞快的R、Python以及JavaScript的开源可视化库。</p><p>缺点：它不涉及jQuery，仅限于原始的JavaScript，需要API密钥和注册而不是pip安装。</p><p>适用于擅长Python的开发人员</p><h3 id="RawGraphs"><a href="#RawGraphs" class="headerlink" title="RawGraphs"></a><a href="https://rawgraphs.io/">RawGraphs</a></h3><p>优点：目标是构建电子表格和矢量图形编辑器之间的链接，可以可视化TSV，CSV，DSV或JSON数据，有助于将数据转换为图表。数据导入的过程像复制粘贴一样简单，上传到RAW的数据将仅由Web浏览器处理，保证数据安全。</p><p>缺点：大多数图表的目的不明确（没有基本的线条图），需要开发人员来开发自定义图表。</p><h3 id="Candela"><a href="#Candela" class="headerlink" title="Candela"></a><a href="https://candela.readthedocs.io/en/latest/">Candela</a></h3><p>带有一个标准化API，可用于实际数据科学应用程序，并且可以通过Resonant平台使用。</p><h3 id="Sigmajs"><a href="#Sigmajs" class="headerlink" title="Sigmajs"></a><a href="http://sigmajs.org/">Sigmajs</a></h3><p>Sigmajs是一个交互式可视化JavaScript函数库，专门用于制作关系网络图。Sigmajs可以在网页上显示社交关系脉络，在大数据社交网络可视化中非常重要。Sigmajs还支持展示从Gephi导出的图表，可以使用Sigmajs将这些图表直接展示在网页上。</p><h3 id="AntV"><a href="#AntV" class="headerlink" title="AntV"></a><a href="https://antv.gitee.io/zh">AntV</a></h3><p>是蚂蚁集团研发的一个可视化控件解决方案，包括了可视化图形语法、可视化引擎、图分析工具和地理空间数据的可视化框架等。从它的官网可以了解到现在阿里系的产品（支付宝、淘宝等）里的可视化都基于AntV开发。</p><h3 id="ECharts"><a href="#ECharts" class="headerlink" title="ECharts"></a><a href="https://echarts.apache.org/zh/index.html">ECharts</a></h3><p>基于Canvas的纯Javascript的图表库，提供直观、生动、可交互、可个性化定制的数据可视化图表。ECharts 提供了常规的<a href="https://echarts.apache.org/zh/option.html#series-line">折线图</a>、<a href="https://echarts.apache.org/zh/option.html#series-bar">柱状图</a>、<a href="https://echarts.apache.org/zh/option.html#series-scatter">散点图</a>、<a href="https://echarts.apache.org/zh/option.html#series-pie">饼图</a>、<a href="https://echarts.apache.org/zh/option.html#series-candlestick">K线图</a>，用于统计的<a href="https://echarts.apache.org/zh/option.html#series-boxplot">盒形图</a>，用于地理数据可视化的<a href="https://echarts.apache.org/zh/option.html#series-map">地图</a>、<a href="https://echarts.apache.org/zh/option.html#series-heatmap">热力图</a>、<a href="https://echarts.apache.org/zh/option.html#series-lines">线图</a>，用于关系数据可视化的<a href="https://echarts.apache.org/zh/option.html#series-graph">关系图</a>、<a href="https://echarts.apache.org/zh/option.html#series-treemap">treemap</a>、<a href="https://echarts.apache.org/zh/option.html#series-sunburst">旭日图</a>，多维数据可视化的<a href="https://echarts.apache.org/zh/option.html#series-parallel">平行坐标</a>，还有用于 BI 的<a href="https://echarts.apache.org/zh/option.html#series-funnel">漏斗图</a>，<a href="https://echarts.apache.org/zh/option.html#series-gauge">仪表盘</a>，并且支持图与图之间的混搭。并且有深度的交互式数据探索，可以对数据进行多维度数据筛取、视图缩放、展示细节等交互操作。与D3.js相比，ECharts由百度团队研发，中文文档比较清晰，相对来说上手难度更低一点。</p><h3 id="D3-js与ECharts的对比"><a href="#D3-js与ECharts的对比" class="headerlink" title="D3.js与ECharts的对比"></a>D3.js与ECharts的对比</h3><p>这两个工具是目前各大公司的大数据平台最流行使用的图形库。</p><h4 id="D3-js（基于SVG）"><a href="#D3-js（基于SVG）" class="headerlink" title="D3.js（基于SVG）"></a>D3.js（基于SVG）</h4><ul><li><p>太底层，学习成本大</p></li><li><p>兼容到IE9以上以及所有的主流浏览器</p></li><li><p>D3通过svg来绘制图形</p></li><li><p>可以自定义事件</p></li><li><p>SVG：不依赖分辨率；基于xml绘制图形，可以操作dom；支持事件处理器；但复杂度高，会减慢页面的渲染速度。</p></li></ul><h4 id="ECharts（基于canvas）"><a href="#ECharts（基于canvas）" class="headerlink" title="ECharts（基于canvas）"></a>ECharts（基于canvas）</h4><ul><li>封装好的方法直接调用</li><li>兼容到ie6以及以上的所有主流浏览器</li><li>echarts通过canvas来绘制图形</li><li>封装好的，直接用，不能修改</li><li>canvas：依赖分辨率；基于js绘制图形；不支持事件处理器；能以png或者jpg的格式保存图片</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一般的数据交互，后台返回数据，前端将数据通过图表的形式展示给用户，对于这种只是展示数据的话较常用的是ECharts。而像一些鼠标、键盘、触屏事件操作的话，是用D3.js实现的。</p><h1 id="部分互联网公司的商用产品"><a href="#部分互联网公司的商用产品" class="headerlink" title="部分互联网公司的商用产品"></a>部分互联网公司的商用产品</h1><h2 id="RayData"><a href="#RayData" class="headerlink" title="RayData"></a><a href="https://cloud.tencent.com/product/raydata">RayData</a></h2><p>腾讯开发的大数据可视交互系统，核心技术基于<a href="https://www.ventuz.com/">Ventuz</a>开发。</p><h2 id="Sugar"><a href="#Sugar" class="headerlink" title="Sugar"></a><a href="https://cloud.baidu.com/product/sugar.html">Sugar</a></h2><p>百度开发的自助BI报表分析和制作可视化数据大屏的强大工具，组件丰富，无需SQL和任何编码。</p><h2 id="DataV"><a href="#DataV" class="headerlink" title="DataV"></a><a href="https://www.alibabacloud.com/zh/product/datav">DataV</a></h2><p>阿里开发的用于实时数据大屏追踪业务全貌的可视化产品，属于拖拽式可视化工具，专精于业务数据与地理信息融合的大数据可视化。核心技术采用了Blink（是阿里巴巴内部的Apache Flink版本代号）。在GitHub上有同款的开源的<a href="https://github.com/DataV-Team/DataV">Vue数据可视化组件库</a>。</p><h2 id="网易有数"><a href="#网易有数" class="headerlink" title="网易有数"></a><a href="https://youdata.163.com/">网易有数</a></h2><p>网易研发的面向企业客户的可视化敏捷BI产品，在网易系产品里有使用。</p><h2 id="FineBI"><a href="#FineBI" class="headerlink" title="FineBI"></a><a href="https://www.finebi.com/">FineBI</a></h2><h3 id="技术架构："><a href="#技术架构：" class="headerlink" title="技术架构："></a>技术架构：</h3><p>Java开发</p><p>后端：spring mvc + Hibernate</p><p>前端：fineui</p><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li>开发/数据人员准备好数据，数据人员/业务人员分析。</li><li>业务人员完全可自行分析、制作可视化。整个数据分析流程分工明确。</li></ul><h3 id="可视化水平"><a href="#可视化水平" class="headerlink" title="可视化水平"></a>可视化水平</h3><ul><li>支持的图表类型多，达47种</li><li>图表可视化选项少，例如，数据格式选项偏少，如需添加，需要修改配置文件</li><li>可在看板中添加筛选框，支持在不同条件下查看</li><li>不支持图表和看板分组管理</li><li>没有提供图表的下钻功能，不支持多图表间的复杂联动</li><li>不支持跨库的表关联查询</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>互联网公司的商用产品均大同小异，均有常用的图表和地理信息图。</p><p>百度的Sugar提供的行业模板很少，支持的数据源类型较少，尤其不支持静态数据，不方便调试；操作的便捷性上有很多细节需要完善，如不支持元素多选、对齐等操作，无法去掉表格的表头等。在3D方面尚有不足，没有阿里云DataV、腾讯RayData的3D效果突出，但是有ECharts的加持，报表渲染比较流畅。</p><p>阿里的DataV常用于数据大屏展示，若没有这个方面需求的话该优势可以忽略。相比之下RayData的大屏产品能力较弱，但有原厂服务+框架服务，优势在于三维城市场景方面。</p><h1 id="基于Hadoop的开源可视化项目"><a href="#基于Hadoop的开源可视化项目" class="headerlink" title="基于Hadoop的开源可视化项目"></a>基于Hadoop的开源可视化项目</h1><h2 id="Superset"><a href="#Superset" class="headerlink" title="Superset"></a><a href="https://superset.apache.org/">Superset</a></h2><p>Apache系列里的基于web的开源BI工具，基于python开发的，所以也算是python生态的一员。它的三大特点是：开源、轻量级、图表丰富，需要在网页上创建看板，然后在看板中创建图表，支持连接SQL查询结果来实时展示图形化结果。</p><h3 id="数据库支持"><a href="#数据库支持" class="headerlink" title="数据库支持"></a>数据库支持</h3><p>Superset 是基于 Druid.io 设计的，但是又支持横向到像 SQLAlchemy 这样的常见Python ORM框架上面。</p><p>Druid 是一个基于分布式的快速列式存储，也是一个为BI设计的开源数据存储查询工具。Druid提供了一种实时数据低延迟的插入、灵活的数据探索和快速数据聚合。现有的Druid已经可以支持扩展到TB级别的事件和PB级的数据了，Druid是BI应用的最佳搭档。跟类似产品Hive相比，速度快了很多。</p><p>在数据源上：支持各种数据源，包括Hive、Kylin等。</p><h3 id="产品结构"><a href="#产品结构" class="headerlink" title="产品结构"></a>产品结构</h3><p><img src="https://upload-images.jianshu.io/upload_images/5064459-2537cacc9c47e3b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"></p><h3 id="开发架构"><a href="#开发架构" class="headerlink" title="开发架构"></a>开发架构</h3><p>整个项目的后端是基于Python的，用到了Flask、Pandas、SqlAlchemy。</p><h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><ul><li>Flask App Builder(鉴权、CRUD、规则）</li><li>Pandas（分析）</li><li>SqlAlchemy（数据库ORM）<h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4></li><li>借助 FAB 来生成大部分管理界面，而图表或是 SQL 编辑器等对交互性要求很高的界面，则由 React + Redux 来实现</li><li>Web 服务器是一个标准的 WSGI 应用</li><li>用到了npm、react、webpack，意味着可以在手机也可以流畅使用。</li><li>d3 (数据可视化)</li><li>nvd3.org(可重用图表)<h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4></li><li>Superset的可视化目前只支持每次可视化一张表，对于多表join的情况还无能为力</li><li>依赖于数据库的快速响应，如果数据库本身太慢Superset也没什么办法</li><li>语义层的封装还需要完善，因为druid原生只支持部分SQL</li><li>页面样式简单，页面的灵活度不高，不能实现二级联动，调用api接口</li></ul><h3 id="可视化水平-1"><a href="#可视化水平-1" class="headerlink" title="可视化水平"></a>可视化水平</h3><ul><li>支持的图表类型多，达47种</li><li>图表可视化选项少，例如，数据格式选项偏少，如需添加，需要修改配置文件</li><li>可在看板中添加筛选框，支持在不同条件下查看</li><li>不支持图表和看板分组管理</li><li>没有提供图表的下钻功能，不支持多图表间的复杂联动</li><li>不支持跨库的表关联查询</li><li>支持其他图标库扩展</li></ul><h3 id="支持文档"><a href="#支持文档" class="headerlink" title="支持文档"></a>支持文档</h3><ul><li>安装部署和快速入门方面的文档详细</li><li>但具体功能和图表制作方面的介绍文档需要搜索资料</li><li>整体文档资料相当简陋</li></ul><h3 id="适用范围-1"><a href="#适用范围-1" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li>开发/分析人员做好看板，业务人员浏览看板数据</li><li>业务人员可自行编辑图表，查看满足条件的结果</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.datadriven.top/2018/01/17/Apache%20Superset/index.html">Apache Superset</a></p><p><a href="https://segmentfault.com/a/1190000005083953">解密Airbnb 自助BI神器：Superset 颠覆 Tableau</a></p><p><a href="https://blog.csdn.net/qq_26437925/article/details/86550053">企业对SuperSet的改进</a></p><p><a href="https://blog.csdn.net/python_tty/article/details/87865360">superset整体介绍</a></p><h2 id="Metabase"><a href="#Metabase" class="headerlink" title="Metabase"></a><a href="https://www.metabase.com/">Metabase</a></h2><p>metabase是一款易用、开源、技术成熟、不断并快速迭代的报表系统。使用metabase可以省去很多前后端的开发工作，只需要进行数据清洗计算转存等相关开发。在目前无开发人力的情况下，这是较为完美的BI系统解决方案。适合查看运行数据，业务人员自己就可以做数据分析。</p><h3 id="开发架构-1"><a href="#开发架构-1" class="headerlink" title="开发架构"></a>开发架构</h3><h4 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h4><p>React + Redux等相关框架写的单页应用，基于yarn的开发环境，webpack构建，加上D3.js作图。</p><h4 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h4><p>Clojure + RING（中间件） + Compojure（路由框架） + Toucan（ORM框架）</p><h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><p>支持数据源少（12种），不支持Hive、Kylin（硬伤）</p><h3 id="可视化水平-2"><a href="#可视化水平-2" class="headerlink" title="可视化水平"></a>可视化水平</h3><ul><li>支持的图表类型不如superset多，仅14种</li><li>图表可视化选项多，例如，提供数据格式多，设置灵活</li><li>可在看板中添加筛选框，支持在不同条件下查看</li><li>通过创建集合，支持图表、看板、定时任务分组管理</li><li>提供图表的简单钻取功能，不支持图表间的复杂联动</li><li>不支持跨库的表关联查询</li></ul><h3 id="适用范围-2"><a href="#适用范围-2" class="headerlink" title="适用范围"></a>适用范围</h3><p> 界面漂亮、友好，使用体验好，适合业务人员使用。</p><h3 id="用户评价"><a href="#用户评价" class="headerlink" title="用户评价"></a>用户评价</h3><p>Metabase 的系统切分与模块化做得非常出色，在前端架构方面 Metabase 较为占优。</p><p>提供完整 API 文档的项目，这使得开发者即使完全不会 Clojure，依然可以凭借丰富的 API 与文档完成许多二次开发。</p><p>部署方面，Metabase 提供了 Jar 文件，Mac 应用程序，Docker 镜像等方式可以让使用者在本地快速尝试该项目。而在生产环境中，它提供了如何在 AWS、Heroku、Kubernetes 上部署的详尽文档，资料较为完善。</p><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="https://dumplingbao.github.io/2019/11/04/metabase-bi-dev/">Metabase-BI系列01：二次开发环境(windows)搭建</a></p><h2 id="Redash"><a href="#Redash" class="headerlink" title="Redash"></a><a href="https://redash.io/">Redash</a></h2><h3 id="开发架构-2"><a href="#开发架构-2" class="headerlink" title="开发架构"></a>开发架构</h3><p><a href="http://www.dazdata.com/2020/12/02/develope-1/">官方文档</a>里的原话是：Redash采用最新的React和Python Flask技术开发，要求开发人员具备React和Python Flask基础；另外由于后台查询运行在RQ异步队列之上，开发人员必须对RQ和Redis有所了解；OLAP采用的是Postgresql分析型数据库；另外对于开发工具，前端React基本都采用VSCODE，后端可以选择VSCODE或PyCharm，开发人员必须对这些IDE有一定的了解。</p><h4 id="后端-2"><a href="#后端-2" class="headerlink" title="后端"></a>后端</h4><p>后端逻辑：</p><p><img src="https://pic3.zhimg.com/80/v2-50c3f04b9772f0f8f6d3c740a3794b56_720w.jpg"></p><p>Redash 的服务器端是用 Python 来写的，Web 框架以 Flask 为基础，并充分利用了 Flask 的插件生态圈，主要用了以下的组件：</p><ul><li>API 框架：Flask-RESTful </li><li>数据库：Flask-SQLAlchemy </li><li>认证：Flask-Login</li></ul><h4 id="前端-2"><a href="#前端-2" class="headerlink" title="前端"></a>前端</h4><p>Redash 的前端是一个纯的单页应用，用 AngularJS（1.5）实现，结构清晰，代码整洁。但众所周知，AngularJS 在 v2 之后做了巨大的架构调整，所以 AngularJS v1的处境就有些尴尬。这和目前 Python 2 的处境类似。短期内不会有问题，长期来讲是个隐患。</p><h3 id="数据源-1"><a href="#数据源-1" class="headerlink" title="数据源"></a>数据源</h3><p>支持数据源比superset少，不支持Kylin</p><h3 id="可视化水平-3"><a href="#可视化水平-3" class="headerlink" title="可视化水平"></a>可视化水平</h3><ul><li>支持的图表类型不如Superset多，仅12种</li><li>图表可视化选项多</li><li>不支持在看板种添加筛选框</li><li>不支持图表和看板分组管理</li><li>没有提供图表的下钻功能，不支持多图表间的复杂联动</li><li>不支持跨库的表关联查询</li></ul><h3 id="适用范围-3"><a href="#适用范围-3" class="headerlink" title="适用范围"></a>适用范围</h3><p>由于是对SQL查询结果进行可视化，需要开发/分析人员做好看板，业务人员浏览看板数据。</p><p>技术架构：Python + Flask + AngularJS + SQLAlchemy</p><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><p><a href="https://my.oschina.net/u/4016785/blog/4422743">Redash——一个开源Flask项目</a></p><p><a href="http://guzhenping.com/2019/02/14/Redash-%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/index.html">Redash 二次开发入门</a></p><p><a href="https://zhuanlan.zhihu.com/p/31292944">浅析数据查询与可视化工具–Redash</a></p><h2 id="Zeppelin"><a href="#Zeppelin" class="headerlink" title="Zeppelin"></a><a href="http://zeppelin.apache.org/">Zeppelin</a></h2><p>支持数据驱动、交互式数据分析、协作式文档等特性的基于Web的交互式应用开发引擎，应用以Notebook形式表示，支持Scala、Python、SQL、Markdown、shell等多种语言。严格意义上说，Zeppelin更像是一notebook，而不是一个单纯的BI工具，来自Apache项目。</p><h3 id="开发技术架构"><a href="#开发技术架构" class="headerlink" title="开发技术架构"></a>开发技术架构</h3><p> 交互式数据分析开源框架，支持多种语言， 包括Scala、Python、SparkSQL、Hive、Markdown、Shell等</p><h3 id="适用范围-4"><a href="#适用范围-4" class="headerlink" title="适用范围"></a>适用范围</h3><p>更适合开发人员</p><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>不支持sql查询</p><h1 id="可视化思路总结"><a href="#可视化思路总结" class="headerlink" title="可视化思路总结"></a>可视化思路总结</h1><ul><li>可以根据开源项目直接进行二次开发，或者仿照开源项目的源码结构自行搭建。</li><li>在开源工具基础上自制工具需要先决定整个页面展现的形式，建议基于一个后台管理系统型界面，加入用户权限管理。</li><li>Hadoop集群运行状况页面：可以采用HUE里的框架，集成服务器里的Hadoop进程的运行状态，在同一个页面里展示。</li><li>数据信息的图形化展示页面：参考vue-big-screen里集成DataV的思路，采用ECharts工具，把生成的图表展示到VUE的一个页面里。</li><li>交互式的数据分析页面：参考Superset里把SQL查询结果图形化的思路，设定调用SQL的时间间隔并持续更新展示在前端的图表。</li><li>自定义代码的功能输入页面：设定一个统一的代码格式，规定输入为xxx数据源，输出为xxx格式的数据表或其他数据结构，在系统中开设一个自定义函数入口。</li></ul><h1 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.hackerearth.com/blog/developers/20-free-and-open-source-data-visualization-tools/">20 free and open source data visualization tools</a></li><li><a href="https://www.finereport.com/en/data-visualization/best-data-visualization-software-free-and-commercial.html">Top 20 Best Data Visualization Software in 2021: Free and Commercial</a></li><li><a href="https://chn.oversea.cnki.net/KCMS/detail/detail.aspx?dbcode=SCPD&dbname=SCPD2021&filename=CN110110002B&v=sGbyHldQIbsvOQdDmzf65wvZOf0CDKDTROUPXi4q962n3Z2XtIpmFWXsnpmmJcRu">专利：大数据可视化交互系统</a></li><li><a href="https://chn.oversea.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201701&filename=1016756637.nh&v=YkiL79FbSE6jK3gn9sf1NApfLEp5SIXo94SHNIVinz0JpZUPnRvaJ3t9unIC81ru">基于Hadoop和Django的大数据可视化分析Web系统</a></li><li><a href="https://chn.oversea.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201602&filename=1016184899.nh&v=G15Yc8rSoa2FFWPWVTRd2gUfSjR%25mmd2Bd28Hp7aelz9YzE2JCAGocSpyxoaw%25mmd2F6mUeAlF">基于Hadoop的数据可视化技术研究与应用</a></li><li><a href="https://chn.oversea.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201801&filename=1017710746.nh&v=5lfRsn5LXOazdc%25mmd2BiriN6Hkms9VVou2N0GPj532V%25mmd2BPNzhQTjRI7OgF2aPfpwWTbFO">基于Hadoop和D3.JS的互联网+博物馆可视化平台的研究与实现</a></li><li><a href="https://chn.oversea.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201602&filename=1016121522.nh&v=k%25mmd2F%25mmd2BsH9iAIA7QJqVk27iZzynbhRNWvG7GtpEhFuKNI556Du2fOMqRnydXUN6%25mmd2BZn4q">基于hadoop的网站用户行为分析系统设计与实现</a></li><li><a href="https://ieeexplore.ieee.org/document/9262724">The Trend, Hotspots, Frontier and Path of Big Data Visualization Research in China——Based on the Knowledge Graph Analysis of Citespace5.5.R2</a></li><li><a href="https://ieeexplore.ieee.org/document/7918044">Big data visualization: Tools and challenges</a></li><li><a href="https://www.cnblogs.com/felixzh/p/9094700.html">数据可视化的开源方案: Superset vs Redash vs Metabase</a></li><li><a href="https://dumplingbao.github.io/2019/11/03/metabase-bi-datav/">BI、数据可视化工具浅析整理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop组件端口汇总</title>
      <link href="2021/01/22/Hadoop_ports/"/>
      <url>2021/01/22/Hadoop_ports/</url>
      
        <content type="html"><![CDATA[<h1 id="各组件版本"><a href="#各组件版本" class="headerlink" title="各组件版本"></a>各组件版本</h1><ul><li>Hadoop 3.3.0</li><li>ZooKeeper 3.5.8</li><li>HBase 2.2.6</li><li>Hive 3.1.2</li></ul><h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><p><a href="http://hadoop.apache.org/docs/current3/hadoop-project-dist/hadoop-common/core-default.xml">core-site.xml</a></p><p><a href="http://hadoop.apache.org/docs/current3/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml">hdfs-site.xml</a></p><table><thead><tr><th>节点</th><th>默认端口</th><th>配置项</th><th>用途说明</th></tr></thead><tbody><tr><td>NameNode</td><td>9000</td><td>hadoop/etc/hadoop/core-site.xml中的fs.defaultFS</td><td>接收Client连接的RPC端口，用于获取文件系统metadata信息</td></tr><tr><td>NameNode</td><td>9870</td><td>hadoop/etc/hadoop/hdfs-site.xml中的dfs.namenode.http-address</td><td>http服务的端口</td></tr><tr><td>DataNode</td><td>9866</td><td>hadoop/etc/hadoop/hdfs-site.xml中的dfs.datanode.address</td><td>datanode服务端口，用于数据传输</td></tr><tr><td>DataNode</td><td>9867</td><td>hadoop/etc/hadoop/hdfs-site.xml中的dfs.datanode.ipc.address</td><td>datanode ipc服务的端口</td></tr><tr><td>DataNode</td><td>9864</td><td>hadoop/etc/hadoop/hdfs-site.xml中的dfs.datanode.http.address</td><td>datanode http服务的端口</td></tr><tr><td>SecondaryNameNode</td><td>9868</td><td>hadoop/etc/hadoop/hdfs-site.xml中的dfs.namenode.secondary.http-address</td><td>SecondaryNameNode的http服务的端口</td></tr></tbody></table><p>目前开放端口：</p><p>NameNode：9000</p><p>DataNode：9866、9867</p><h1 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h1><p><a href="http://hadoop.apache.org/docs/current3/hadoop-yarn/hadoop-yarn-common/yarn-default.xml">yarn-site.xml</a></p><p><a href="http://hadoop.apache.org/docs/current3/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml">mapred-site.xml</a></p><table><thead><tr><th>组件</th><th>节点</th><th>默认端口</th><th>配置项</th><th>用途说明</th></tr></thead><tbody><tr><td>YARN</td><td>JobHistoryServer</td><td>10020</td><td>hadoop/etc/hadoop/mapred-site.xml中的mapreduce.jobhistory.address</td><td>JobHistoryServer的IPC端口</td></tr><tr><td>YARN</td><td>JobHistoryServer</td><td>19888</td><td>hadoop/etc/hadoop/mapred-site.xml中的mapreduce.jobhistory.webapp.address</td><td>JobHistoryServer的Web UI端口</td></tr><tr><td>YARN</td><td>JobHistoryServer</td><td>10033</td><td>hadoop/etc/hadoop/mapred-site.xml中的mapreduce.jobhistory.admin.address</td><td>HistoryServer的admin端口</td></tr><tr><td>YARN</td><td>ResourceManager</td><td>8030</td><td>hadoop/etc/hadoop/yarn-site.xml中的yarn.resourcemanager.scheduler.address</td><td>scheduler组件的IPC端口</td></tr><tr><td>YARN</td><td>ResourceManager</td><td>8031</td><td>hadoop/etc/hadoop/yarn-site.xml中的yarn.resourcemanager.resource-tracker.address</td><td>IPC</td></tr><tr><td>YARN</td><td>ResourceManager</td><td>8032</td><td>hadoop/etc/hadoop/yarn-site.xml中的yarn.resourcemanager.address</td><td>RM的applications manager(ASM)端口</td></tr><tr><td>YARN</td><td>ResourceManager</td><td>8033</td><td>hadoop/etc/hadoop/yarn-site.xml中的yarn.resourcemanager.admin.address</td><td>admin IPC</td></tr><tr><td>YARN</td><td>ResourceManager</td><td>8088</td><td>hadoop/etc/hadoop/yarn-site.xml中的yarn.resourcemanager.webapp.address</td><td>http服务端口</td></tr><tr><td>YARN</td><td>NodeManager</td><td>8040</td><td>hadoop/etc/hadoop/yarn-site.xml中的yarn.nodemanager.localizer.address</td><td>NM的localizer IPC</td></tr><tr><td>YARN</td><td>NodeManager</td><td>8042</td><td>hadoop/etc/hadoop/yarn-site.xml中的yarn.nodemanager.webapp.address</td><td>http服务端口</td></tr><tr><td>YARN</td><td>NodeManager</td><td>13562</td><td>hadoop/etc/hadoop/mapred-site.xml中的mapreduce.shuffle.port</td><td>ShuffleHandler的运行端口</td></tr><tr><td>YARN</td><td>NodeManager</td><td>随机端口（已统一改成13579）</td><td>hadoop/etc/hadoop/yarn-site.xml中的yarn.nodemanager.address</td><td>NM的container manager端口</td></tr></tbody></table><p>目前开放端口：</p><p>JobHistoryServer  ：10020、10033</p><p>ResourceManager：8030、8031、8032、8033</p><p>NodeManager：8040、13562、13579</p><h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><p><a href="https://hbase.apache.org/book.html#hbase_default_configurations">官方配置文档</a></p><table><thead><tr><th>组件</th><th>节点</th><th>默认端口</th><th>配置项</th><th>用途说明</th></tr></thead><tbody><tr><td>HBase</td><td>HMaster</td><td>16000</td><td>hbase/conf/hbase-site.xml中的hbase.master.port</td><td>HMaster绑定的端口</td></tr><tr><td>HBase</td><td>HMaster</td><td>16010</td><td>hbase/conf/hbase-site.xml中的hbase.master.info.port</td><td>Http服务端口，访问HMaster的Web UI</td></tr><tr><td>HBase</td><td>HRegionServer</td><td>16020</td><td>hbase/conf/hbase-site.xml中的hbase.regionserver.port</td><td>HRegionServer绑定的端口</td></tr><tr><td>HBase</td><td>HRegionServer</td><td>16030</td><td>hbase/conf/hbase-site.xml中的hbase.regionserver.info.port</td><td>Http服务端口，访问HRegionServer的Web UI</td></tr></tbody></table><p>目前开放端口：</p><p>HMaster：16000</p><p>HRegionServer：16020</p><h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><p><a href="https://zookeeper.apache.org/doc/r3.5.9/zookeeperAdmin.html">官方配置文档</a></p><table><thead><tr><th>组件</th><th>节点</th><th>默认端口</th><th>配置项</th><th>用途说明</th></tr></thead><tbody><tr><td>ZooKeeper</td><td>Server</td><td>2181</td><td>zookeeper/conf/zoo.cfg中的clientPort</td><td>对客户端提供服务的端口</td></tr><tr><td>ZooKeeper</td><td>Server</td><td>2888</td><td>zookeeper/conf/zoo.cfg中server.x=[hostname]:<strong>nnnnn</strong>[:nnnnn]</td><td>Follower与集群中的 Leader交换信息的端口，只在Leader上监听该端口。（但是三个节点都要开，因为不知道重新选举后Leader会是谁）</td></tr><tr><td>ZooKeeper</td><td>Server</td><td>3888</td><td>zookeeper/conf/zoo.cfg中server.x=[hostname]:nnnnn[:<strong>nnnnn</strong>]</td><td>万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</td></tr><tr><td>ZooKeeper</td><td>Server</td><td>8080</td><td>zookeeper/conf/zoo.cfg中的admin.serverPort</td><td>Zookeeper3.5的新特性，Zookeeper AdminServer默认使用8080端口</td></tr><tr><td>ZooKeeper</td><td>Server</td><td>随机生成</td><td><a href="https://my.oschina.net/csp277/blog/4312406">参考1</a>、<a href="https://blog.csdn.net/weixin_33921089/article/details/91923344">参考2</a></td><td>JMX端口，建议关闭，参考<a href="https://zookeeper.apache.org/doc/r3.5.9/zookeeperJMX.html">官方JMX文档</a></td></tr></tbody></table><p>目前开放端口：</p><p>ALL：2181、2888、3888、8080</p><h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><p><a href="https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties">官方配置文档</a></p><table><thead><tr><th>组件</th><th>节点</th><th>默认端口</th><th>配置项</th><th>用途说明</th></tr></thead><tbody><tr><td>Hive</td><td>HiveServer2</td><td>10000</td><td>hive/conf/hive-site.xml中的hive.server2.thrift.port</td><td>对客户端提供服务的TCP监听端口</td></tr><tr><td>Hive</td><td>HiveServer2</td><td>10002</td><td>hive/conf/hive-site.xml中的hive.server2.webui.port</td><td>HiveServer2访问Web UI的端口</td></tr></tbody></table><p>目前开放端口：10000、10002</p><h1 id="目前进程"><a href="#目前进程" class="headerlink" title="目前进程"></a>目前进程</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@cpu-node1 ~]$ jps</span><br><span class="line">3216 NameNode</span><br><span class="line">22451 Jps</span><br><span class="line">3861 NodeManager</span><br><span class="line">4967 HMaster</span><br><span class="line">3384 DataNode</span><br><span class="line">4269 QuorumPeerMain</span><br><span class="line">5197 HRegionServer</span><br><span class="line">4125 JobHistoryServer</span><br><span class="line"></span><br><span class="line">[hadoop@cpu-node2 ~]$ jps</span><br><span class="line">31936 ResourceManager</span><br><span class="line">32098 NodeManager</span><br><span class="line">675 HRegionServer</span><br><span class="line">19027 Jps</span><br><span class="line">31657 DataNode</span><br><span class="line">10713 QuorumPeerMain</span><br><span class="line"></span><br><span class="line">[hadoop@cpu-node3 ~]$ jps</span><br><span class="line">30769 SecondaryNameNode</span><br><span class="line">31779 HRegionServer</span><br><span class="line">30581 DataNode</span><br><span class="line">552 Jps</span><br><span class="line">31357 QuorumPeerMain</span><br><span class="line">30926 NodeManager</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq_31102103/article/details/90599373">hadoop大数据各个组件常用的端口</a></p><p><a href="https://www.cnblogs.com/niuben/p/13882092.html">Linux防火墙开发端口命令</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 端口 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记（七）——面向对象（封装、继承、多态）</title>
      <link href="2021/01/21/Java_OOP_The3/"/>
      <url>2021/01/21/Java_OOP_The3/</url>
      
        <content type="html"><![CDATA[<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://docs.oracle.com/javase/8/docs/api/">JDK8帮助文档</a></p><p><a href="https://www.bilibili.com/video/BV12J41137hu">狂神说Java视频</a></p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>程序设计要求：<strong>高内聚，低耦合</strong></p><ul><li>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</li><li>低耦合：尽量暴露少量的方法给外部使用</li></ul><p><strong>封装</strong>（数据的隐藏）：通常应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏。</p><p>REMEMBER：<strong>属性私有，get/set</strong></p><p>关键字：<code>private</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性私有，利用修饰符关键字private</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一些可以操作private属性的方法：</span></span><br><span class="line">    <span class="comment">//public的get&amp;set方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//get：获得属性数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set：给这个属性数据设置值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过set方法可以规避不合法的值</span></span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">120</span> || age &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = <span class="number">3</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main方法测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">//不能通过s1.name操作name属性，</span></span><br><span class="line">        <span class="comment">//如果是public String name;就可以</span></span><br><span class="line">        s1.setName(<span class="string">&quot;Messi&quot;</span>);</span><br><span class="line">        System.out.println(s1.getName());</span><br><span class="line"></span><br><span class="line">        s1.setAge(<span class="number">999</span>);</span><br><span class="line">        System.out.println(s1.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IDEA生成get&amp;set方法<strong>快捷键</strong>：Alt+insert，选择Getter&amp;Setter，再选择需要生成get&amp;set方法的属性名称。</p></blockquote><p>封装的<strong>意义</strong>：</p><ol><li>提高程序安全性，保护数据。</li><li>隐藏代码的实现细节</li><li>统一接口</li><li>提高系统可维护性</li></ol><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承的本质：对某一批类的抽象，从而实现对现实世界更好的建模。</p><p>关键字：<code>extends</code></p><ul><li><strong>Java中类只有单继承，没有多继承。</strong>即一个子类只能有一个父类（只能直接继承一个类），一个父类可以有多个子类。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/java-extends-2020-12-08.png"></p><ul><li>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。</li><li>继承关系的两个个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字<code>extends</code>来表示。</li><li>子类和父类之间，从意义上讲应该具有“is a”的关系。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//人：父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> money = <span class="number">10_0000_0000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;说话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生 is 人 派生类：子类</span></span><br><span class="line"><span class="comment">//子类继承了父类，就会拥有父类的全部非 private 的属性、方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Classmate</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Classmate classmate = <span class="keyword">new</span> Classmate();</span><br><span class="line">        classmate.say();</span><br><span class="line">        System.out.println(classmate.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>若一个类有<code>final</code>修饰符则不能被继承，<code>final</code>属于断子绝孙修饰符。</p></blockquote><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p><strong>在Java中所有的类都默认直接或间接继承Object类</strong></p><blockquote><p>IDEA打开继承树快捷键：Ctrl+H</p></blockquote><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//人：父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name = <span class="string">&quot;Person&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类Human构造无参执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//球员 继承 Human类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;Player&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name);<span class="comment">//输出传入的实参</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);<span class="comment">//输出本类的属性name</span></span><br><span class="line">        System.out.println(<span class="keyword">super</span>.name);<span class="comment">//输出父类的属性name</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shoot&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        say();<span class="comment">//调用本类里的say方法</span></span><br><span class="line">        <span class="keyword">this</span>.say();<span class="comment">//调用本类里的say方法</span></span><br><span class="line">        <span class="keyword">super</span>.say();<span class="comment">//调用父类里的say方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//首先调用父类的无参构造，有一句隐藏代码：super();</span></span><br><span class="line">        <span class="comment">//该调用必须放在子类构造器的第一行，否则报错</span></span><br><span class="line">        <span class="comment">// Call to &#x27;super()&#x27; must be first statement in constructor body</span></span><br><span class="line">        <span class="comment">//如果父类采用了有参构造后没有写无参构造，</span></span><br><span class="line">        <span class="comment">// 子类构造器里必须用带参的super方法显式调用父类的有参构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类Player构造无参执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在new的过程中，首先调用父类构造器，再调用子类构造器</span></span><br><span class="line">        Player player = <span class="keyword">new</span> Player();</span><br><span class="line"></span><br><span class="line">        player.test1(<span class="string">&quot;Messi&quot;</span>);</span><br><span class="line">        player.test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="super注意点："><a href="#super注意点：" class="headerlink" title="super注意点："></a><code>super</code>注意点：</h3><ol><li><code>super</code>调用父类的构造方法，必须在构造方法的第一个</li><li><code>super</code>必须只能出现在子类的方法或者构造方法中</li><li><code>super</code>和<code>this</code>不能同时调用构造方法</li></ol><h3 id="superVSthis："><a href="#superVSthis：" class="headerlink" title="superVSthis："></a><code>super</code>VS<code>this</code>：</h3><ul><li>代表的对象不同：<ul><li><code>this</code>：本身调用者的这个对象</li><li><code>super</code>：代表父类对象的引用</li></ul></li><li>前提不同：<ul><li><code>this</code>：没有继承也可以使用</li><li><code>super</code>：只能在继承条件下才可以使用</li></ul></li><li>构造方法不同：<ul><li><code>this()</code>：本类的构造器</li><li><code>super()</code>：父类的构造器</li></ul></li></ul><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p><strong>重写都是方法，和属性无关</strong></p><ul><li>静态方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B-&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A-&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方法的调用只和左边定义的数据类型有关</span></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.test();<span class="comment">//A-&gt;test()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//父类的引用指向了子类对象</span></span><br><span class="line">        B b = <span class="keyword">new</span> A();</span><br><span class="line">        b.test();<span class="comment">//B-&gt;test()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>非静态方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="comment">//IDEA左侧有向下箭头提示“Is overridden in A”</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B-&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Override 重写</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//注解：有功能的注释</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;<span class="comment">//IDEA左侧有向上箭头提示“Overrides method in B”</span></span><br><span class="line">        <span class="comment">//默认调用父类方法：super.test();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A-&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IDEA生成get&amp;set方法<strong>快捷键</strong>：Alt+insert，选择Override Method，或者直接Ctrl+O。</p></blockquote><p>main测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.test();<span class="comment">//A-&gt;test()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//父类的引用指向了子类对象</span></span><br><span class="line">        B b = <span class="keyword">new</span> A();<span class="comment">//子类重写了父类的方法</span></span><br><span class="line">        b.test();<span class="comment">//A-&gt;test()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态与非静态方法的区别：</p><ul><li><p><strong>静态方法是类的方法，非静态方法是对象的方法。</strong></p></li><li><p>静态方法：方法的调用只和左边定义的数据类型有关，<strong>静态方法可以被继承，但是不能被覆盖，即不能重写。</strong></p></li><li><p>非静态方法：可以重写，名字、参数一模一样，且方法修饰符必须是<code>public</code>。</p></li></ul><blockquote><p><strong>只有普通的方法调用可以是多态的</strong>。</p></blockquote><p>重写总结：</p><ul><li>前提：需要有继承关系，是面向一个方法来说的，子类重写父类的方法。</li><li>方法名必须相同</li><li>参数列表必须相同（不同则为<strong>重载</strong>）</li><li>修饰符：范围可以扩大但不能缩小，public&gt;protected&gt;default&gt;private</li><li>抛出的异常：范围可以被缩小但不能扩大，例如ClassNotFoundException&lt;Exception</li><li>子类的方法和父类必须一致，方法体不同</li></ul><p>重写的意义：</p><ul><li>父类的功能子类不一定需要或不一定满足</li></ul><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：即同一方法可以根据发送对象的不同而采用多种不同的行为方式</p><p>核心思想：一个对象的实际类型是确定的，但可以指向对象的引用类型有很多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;People RUN&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Worker RUN&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Worker EAT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个对象的实际类型是确定的</span></span><br><span class="line">        <span class="comment">//new People();</span></span><br><span class="line">        <span class="comment">//new Worker();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//指向的引用类型不确定【需要有继承关系】</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Worker能调用的方法都是自己的或者是继承于父类的</span></span><br><span class="line">        Worker w1 = <span class="keyword">new</span> Worker();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//People可以指向子类，但是不能调用子类独有的方法</span></span><br><span class="line">        People w2 = <span class="keyword">new</span> Worker();<span class="comment">//父类的引用指向子类的类型</span></span><br><span class="line"></span><br><span class="line">        Object w3 = <span class="keyword">new</span> Worker();</span><br><span class="line">        <span class="comment">//引用类型      实际类型</span></span><br><span class="line"></span><br><span class="line">        w1.run();</span><br><span class="line">        w2.run();</span><br><span class="line">        <span class="comment">//在子类重写之前均输出People RUN，</span></span><br><span class="line">        <span class="comment">// 重写之后均输出Worker RUN</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接写w2.eat();报错</span></span><br><span class="line">        <span class="comment">//证明：能执行哪些方法主要看左边的引用类型，</span></span><br><span class="line">        <span class="comment">// 与右边实际类型关系不大</span></span><br><span class="line">        ((Worker) w2).eat();<span class="comment">//高转低，需要强制转换类型，然后就可以调用子类独有的方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态注意事项：</p><ul><li>多态是<strong>方法</strong>的多态，属性没有多态</li><li>需要有父类和子类的继承关系，没有的话会报类型转换异常(ClassCastException)</li><li>存在条件：继承关系，方法被需要重写，父类引用指向子类对象：<code>Father f1 = new Son()</code></li><li>无法重写的方法：<code>static</code>（属于类不属于实例）、<code>final</code>（常量）、<code>private</code></li></ul><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h2><p>二元操作符，测试它左边的对象是否是它右边的类的实例，返回boolean的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Object-&gt;People-&gt;Worker</span></span><br><span class="line">        <span class="comment">//Object-&gt;People-&gt;Teacher</span></span><br><span class="line">        <span class="comment">//Object-&gt;String</span></span><br><span class="line">        Object o = <span class="keyword">new</span> Worker();</span><br><span class="line"></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> People);<span class="comment">//true</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Worker);<span class="comment">//true</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Teacher);<span class="comment">//false</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> String);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        People p = <span class="keyword">new</span> Worker();</span><br><span class="line">        System.out.println(p <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">        System.out.println(p <span class="keyword">instanceof</span> People);<span class="comment">//true</span></span><br><span class="line">        System.out.println(p <span class="keyword">instanceof</span> Worker);<span class="comment">//true</span></span><br><span class="line">        System.out.println(p <span class="keyword">instanceof</span> Teacher);<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//System.out.println(p instanceof String);报错：Inconvertible types; cannot cast &#x27;OOP.Polymorphism.People&#x27; to &#x27;java.lang.String&#x27;</span></span><br><span class="line"></span><br><span class="line">        Worker w = <span class="keyword">new</span> Worker();</span><br><span class="line">        System.out.println(w <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">        System.out.println(w <span class="keyword">instanceof</span> People);<span class="comment">//true</span></span><br><span class="line">        System.out.println(w <span class="keyword">instanceof</span> Worker);<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//System.out.println(w instanceof Teacher);报错</span></span><br><span class="line">        <span class="comment">//System.out.println(w instanceof String);报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>System.out.println(X instanceof Y);</code>能否编译通过看<strong>左边</strong>的引用类型X与Y有没有继承关系，实际判断结果看<strong>右边</strong>的实际类型里X是不是Y的实例（子类或本类）。</p><blockquote><p><strong>OOP：编译看左，运行看右。</strong></p></blockquote><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>父类：高，子类：低。从高到低需要强制转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;People RUN&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Worker GO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//高：父类            低：子类</span></span><br><span class="line">        People obj = <span class="keyword">new</span> Worker();</span><br><span class="line">        <span class="comment">//obj.go();报错：Cannot resolve method &#x27;go&#x27; in &#x27;People&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将这个obj强制转换为Worker类型就可以使用Worker里的独有方法</span></span><br><span class="line">        <span class="comment">//从People转到Worker：从高到低，需要强制转换</span></span><br><span class="line">        ((Worker) obj).go();</span><br><span class="line"></span><br><span class="line">        Worker w = <span class="keyword">new</span> Worker();</span><br><span class="line">        w.go();</span><br><span class="line">        <span class="comment">//从低转高：不用强制转换</span></span><br><span class="line">        People p = w;</span><br><span class="line">        <span class="comment">//p.go();报错：子类转换为父类有可能丢失自己本来独有的方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型转换总结：</p><ul><li>存在条件：父类引用指向子类的对象</li><li>把<strong>子类</strong>转换为<strong>父类</strong>：向上转型，不用强制转换，丢失子类中可直接调用的<strong>独有</strong>的方法</li><li>把<strong>父类</strong>转换为<strong>子类</strong>：向下转型，<strong>需要强制转换</strong>，丢失父类被子类<strong>重写</strong>掉的方法。</li><li>意义：方便方法的调用，减少重复的代码，使代码更简洁。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> OOP </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记（六）——面向对象（基础部分）</title>
      <link href="2021/01/15/Java_OOP_basic/"/>
      <url>2021/01/15/Java_OOP_basic/</url>
      
        <content type="html"><![CDATA[<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://docs.oracle.com/javase/8/docs/api/">JDK8帮助文档</a></p><p><a href="https://www.bilibili.com/video/BV12J41137hu">狂神说Java视频</a></p><h1 id="面向过程VS面向对象"><a href="#面向过程VS面向对象" class="headerlink" title="面向过程VS面向对象"></a>面向过程VS面向对象</h1><p><strong>面向过程思想：</strong></p><ul><li>步骤清晰简单，第一步做什么，第二步做什么……</li><li>面对过程适合处理一些较为简单的问题</li></ul><p><strong>面向对象思想：</strong></p><ul><li>物以类聚，<strong>分类</strong>的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。</li><li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题</li></ul><p>对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</p><h1 id="面向对象概念"><a href="#面向对象概念" class="headerlink" title="面向对象概念"></a>面向对象概念</h1><p>面向对象编程（Object-Oriented Programming，OOP）本质：<strong>以类的方式组织代码，以对象的形式封装数据。</strong></p><p>抽象：把对象的相似点抽取出来，组成一个类</p><p>三大特性：</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><blockquote><p>从认识论角度考虑：先有对象后有类。对象是具体的事物，类是对对象的抽象。</p><p>从代码运行角度考虑：先有类后有对象，类是对象的模板。</p></blockquote><h1 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h1><ul><li>类是一种抽象的数据类型，它是对某一类事物整体描述定义，但是并不能代表某一个具体的事物。</li><li>对象是抽象概念的具体实例。</li></ul><h1 id="创建与初始化对象"><a href="#创建与初始化对象" class="headerlink" title="创建与初始化对象"></a>创建与初始化对象</h1><p>使用<code>new</code>关键字创建对象：创建时除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="comment">//一个类里只能存在属性和方法这两种东西</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性：字段</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;学生在学习&quot;</span>);<span class="comment">//this关键字代表当前这个类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main方法里测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一个项目只存在一个main方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对抽象的类进行实例化</span></span><br><span class="line">        <span class="comment">//类实例化后会返回一个自己的对象</span></span><br><span class="line">        <span class="comment">//student对象就是一个Student类的具体实例</span></span><br><span class="line">        Student Messi = <span class="keyword">new</span> Student();</span><br><span class="line">        Student Suarez = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        Messi.name = <span class="string">&quot;Messi&quot;</span>;</span><br><span class="line">        Messi.age = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(Messi.age);</span><br><span class="line">        System.out.println(Messi.name);</span><br><span class="line">        System.out.println(Suarez.age);<span class="comment">//默认0</span></span><br><span class="line">        System.out.println(Suarez.name);<span class="comment">//默认null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>类中的构造器：也叫构造方法，是在进行创建对象的时候必须要调用的，并且有以下两个<strong>特点</strong>：</p><ul><li>必须和类的名字相同</li><li>必须没有返回类型，也不加<code>void</code></li></ul><p>新建一个空的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法里实例化这个类并编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用IDEA打开out文件夹下面生成的Person.class文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> OOP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>证明：<strong>一个类即使什么都不写，它也会存在一个方法，即为构造方法（构造器）</strong></p><p>构造器的<strong>作用</strong>：</p><ul><li>使用<code>new</code>实例化对象的时候，本质是在调用构造器（有参构造/无参构造）</li><li>用来初始化对象的值</li></ul><h3 id="有参构造与无参构造"><a href="#有参构造与无参构造" class="headerlink" title="有参构造与无参构造"></a>有参构造与无参构造</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无参构造：可显式或隐式定义</span></span><br><span class="line">    <span class="comment">//显式定义作用为实例化初始值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;Player&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造</span></span><br><span class="line">    <span class="comment">//**一旦定义了有参构造，无参构造就必须显式定义**</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;Messi&quot;</span>);</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<strong>一旦定义了有参构造，无参构造就必须显式定义</strong></p><p>IDEA在一个类里生成构造器的<strong>快捷键</strong>：</p><ul><li>Alt+insert选择Constructor，直接点OK：有参构造</li><li>Alt+insert选择Constructor，选“Select None”：无参构造</li></ul><h1 id="创建对象的内存分析"><a href="#创建对象的内存分析" class="headerlink" title="创建对象的内存分析"></a>创建对象的内存分析</h1><p>详情参考<a href="https://www.bilibili.com/video/BV12J41137hu?p=65">视频讲解</a></p><p><img src="http://img.cuper.top/java20210120172257.png" alt="QQ截图20210120172145"></p><h1 id="OOP基础小结"><a href="#OOP基础小结" class="headerlink" title="OOP基础小结"></a>OOP基础小结</h1><ol><li>类与对象：类是一个抽象的模板，对象是一个具体的实例</li><li>方法：定义与调用</li><li>对应的引用：相对于八大基本类型——对象为引用类型，通过引用来操作，从栈中指向堆</li><li>属性：字段（Field，成员变量），会默认初始化，定义：<code>修饰符 属性类型 属性名 = 属性值</code></li><li>对象的创建和使用：<ol><li>必须使用<code>new</code>关键字创建对象</li><li>对象的属性调用：<code>对象名.属性</code></li><li>对象的方法调用：<code>对象名.方法</code></li></ol></li><li>类：<ol><li>静态的属性——属性</li><li>动态的行为——方法</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> OOP </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记（五）——数组</title>
      <link href="2021/01/04/Java_Array/"/>
      <url>2021/01/04/Java_Array/</url>
      
        <content type="html"><![CDATA[<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://docs.oracle.com/javase/8/docs/api/">JDK8帮助文档</a></p><p><a href="https://www.bilibili.com/video/BV12J41137hu">狂神说Java视频</a></p><h1 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h1><ul><li>数组是相同类型数据的有序集合。</li><li>数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。</li><li>其中,每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问它们。</li></ul><h1 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar;<span class="comment">//首选方法</span></span><br><span class="line">或</span><br><span class="line">dataType arrayRefVar[];<span class="comment">//效果相同，不是首选</span></span><br></pre></td></tr></table></figure><p>Java使用<code>new</code>来创建数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arratSize];</span><br></pre></td></tr></table></figure><p>获取数组长度：<code>arrays.length</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Create</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义的通式：变量类型 变量名字 = 变量的值;</span></span><br><span class="line">        <span class="comment">//数组类型：基本类型[]</span></span><br><span class="line">        <span class="keyword">int</span>[] nums1;<span class="comment">//定义</span></span><br><span class="line">        <span class="keyword">int</span> nums2[];<span class="comment">//C++风格</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums;<span class="comment">//1.声明一个数组</span></span><br><span class="line">        nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//2.创建一个数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//声明+定义一句话搞定</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.给数组元素赋值</span></span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        nums[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        nums[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        nums[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        nums[<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算所有元素的和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li>存放new的对象和数组</li><li>可以被所有线程共享，不会存放别的对象引用</li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li>存放基本变量类型（会包含这个基本类型的具体数值）</li><li>引用对象的变量（会存放这个引用在堆里的具体地址）</li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul><li>可以被所有线程共享</li><li>包含了所有的class和static变量</li></ul><h1 id="数组的三种初始化状态"><a href="#数组的三种初始化状态" class="headerlink" title="数组的三种初始化状态"></a>数组的三种初始化状态</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Init</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态初始化：创建+赋值</span></span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(a[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态初始化：包含默认初始化</span></span><br><span class="line">        <span class="comment">//默认初始化：数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。</span></span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//已经默认初始化10个值均为0</span></span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        System.out.println(b[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(b[<span class="number">1</span>]);<span class="comment">//b[1]默认为int的默认值：0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组的特点"><a href="#数组的特点" class="headerlink" title="数组的特点"></a>数组的特点</h1><ul><li>其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。</li><li>其元素必须是相同类型，不允许出现混合类型。</li><li>数组中的元素可以是任何数据类型，包括基本类型和引用类型。</li><li>数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，<strong>数组对象本身是在堆中的</strong>。</li></ul><h1 id="数组边界"><a href="#数组边界" class="headerlink" title="数组边界"></a>数组边界</h1><p>下标的合法边界：[0, length-1]，若越界会报错<code>ArrayIndexOutOfBoundsException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ArrayIndexOutOfBoundsException: <span class="number">11</span></span><br><span class="line">at Array.Init.main(Init.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure><ul><li>数组是相同数据类型（数据类型可以为任意类型）的有序集合。</li><li>数组也是对象，数组元素相当于对象的成员变量。</li><li>数组长度是确定的，不可变的。如果越界，则报: ArrayIndexOutofBounds。</li></ul><h1 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Usage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arrays = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//For-Each循环，没有下标</span></span><br><span class="line">        <span class="comment">//打印全部数组元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> array : arrays) &#123;</span><br><span class="line">            System.out.println(array);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组作为方法入参</span></span><br><span class="line">        printArray(arrays);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组作为返回值</span></span><br><span class="line">        <span class="keyword">int</span>[] reverse = reverse(arrays);</span><br><span class="line">        printArray(reverse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印数组元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arrays)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> array:arrays)&#123;</span><br><span class="line">            System.out.print(array+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reverse(<span class="keyword">int</span>[] arrays)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arrays.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转的操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = result.length-<span class="number">1</span>; i &lt; arrays.length; i++, j--) &#123;</span><br><span class="line">            result[j] = arrays[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p>多维数组：数组的数组</p><p>二维数组：特殊的一维数组，每一个元素都是一个一维数组</p><p>二维数组的定义（一个两行五列的数组）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">5</span>]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//[4][2]</span></span><br><span class="line">        <span class="keyword">int</span>[][] array = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] arr:array)&#123;</span><br><span class="line">            printArray(arr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">                System.out.println(array[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印数组元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arrays)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> array:arrays)&#123;</span><br><span class="line">            System.out.print(array+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><p>数组的工具类：<code>java.util.Arrays</code></p><p>由于数组对象本身并没有什么方法可以供我们调用，但API中提供了一个工具类Arrays供我们使用，从而可以对数据对象进行一些基本的操作。</p><p>Arrays类中的方法都是<code>static</code>修饰的静态方法，在使用的时候可以直接使用类名进行调用，而<strong>不用</strong>使用对象来调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4534</span>,<span class="number">2432</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">5938</span>,<span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印数组元素</span></span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对数组进行排序</span></span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组填充</span></span><br><span class="line">        Arrays.fill(a,<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用功能：</p><ul><li>给数组赋值：通过<code>fill</code>方法。</li><li>对数组排序：通过<code>sort</code>方法，升序。</li><li>比较数组：通过<code>equals</code>方法比较数组中元素值是否相等。</li><li>查找数组元素：通过<code>binarySearch</code>方法能对排序好的数组进行二分查找法操作。</li></ul><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4534</span>,<span class="number">2432</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">5938</span>,<span class="number">20</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(sort(a)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//冒泡排序  时间复杂度：O(n²)</span></span><br><span class="line">    <span class="comment">//1.比较数组中两个相邻的元素，如果第一个比第二个数大，则交换它们的位置</span></span><br><span class="line">    <span class="comment">//2.每一次比较都会产生一个最大（按升序的话，把最大的扔到最后面）或者最小（按降序的话，把最小的扔到最后面）的数字</span></span><br><span class="line">    <span class="comment">//3.下一轮则可以少一个排序</span></span><br><span class="line">    <span class="comment">//4.依次循环直到结束</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">        <span class="comment">//外层循环，判断要走多少次(length长的数组只需循环length-1次)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//通过标识位减少没有意义的比较</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//内层循环，比较判断两个数，如果第一个比第二个数大，则交换位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++) &#123; <span class="comment">//第i次比较过后已经产生了i个最大或最小的数，不需要进行下一轮比较</span></span><br><span class="line">                <span class="keyword">if</span> (array[j + <span class="number">1</span>] &lt; array[j])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                    array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;<span class="comment">//当没有进入j循环的相邻比较环节，证明已经排好序了，直接结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h1><p>当一个数组中大部分元素为0，或者为同一个值，可以使用稀疏数组来保存该数组。</p><p>稀疏数组的处理方式是：</p><ul><li>记录数组一共有几行几列，有多少个不同值（存放在稀疏数组的第一行）</li><li>把具有不同值的元素的行列&amp;值记录在一个小规模数组中</li></ul><p>示例：</p><p><img src="http://img.cuper.top/java20210105201113.png" alt="QQ截图20210105201040"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建11*11的二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] array1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        array1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        array1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//输出原始数组</span></span><br><span class="line">        printArray(array1);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转换为稀疏数组</span></span><br><span class="line">        <span class="comment">//1.获取有效值个数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array1[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array1[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;有效值个数：&quot;</span>+sum);</span><br><span class="line">        <span class="comment">//2.创建一个稀疏数组的数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] array2= <span class="keyword">new</span> <span class="keyword">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];<span class="comment">//sum+1是因为第一行存的是原数组的行、列、有效值个数</span></span><br><span class="line"></span><br><span class="line">        array2[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;array1.length, array1[<span class="number">0</span>].length, sum&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历二维数组，将非零值存放到稀疏数组中</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array1[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array1[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    array2[count][<span class="number">0</span>] = i;</span><br><span class="line">                    array2[count][<span class="number">1</span>] = j;</span><br><span class="line">                    array2[count][<span class="number">2</span>] = array1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出稀疏数组</span></span><br><span class="line">        printArray(array2);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从稀疏数组还原成原始数组</span></span><br><span class="line">        <span class="comment">//1.读取稀疏数组值</span></span><br><span class="line">        <span class="keyword">int</span>[][] array3 = <span class="keyword">new</span> <span class="keyword">int</span>[array2[<span class="number">0</span>][<span class="number">0</span>]][array2[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">//2.给其中的元素还原值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array2.length; i++) &#123;</span><br><span class="line">            array3[array2[i][<span class="number">0</span>]][array2[i][<span class="number">1</span>]] = array2[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.打印还原数组</span></span><br><span class="line">        printArray(array3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印二维数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[][] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : array) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记（四）——方法</title>
      <link href="2020/12/30/Java_method/"/>
      <url>2020/12/30/Java_method/</url>
      
        <content type="html"><![CDATA[<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://docs.oracle.com/javase/8/docs/api/">JDK8帮助文档</a></p><p><a href="https://www.bilibili.com/video/BV12J41137hu">狂神说Java视频</a></p><h1 id="方法的概念"><a href="#方法的概念" class="headerlink" title="方法的概念"></a>方法的概念</h1><p><img src="http://img.cuper.top/java20201230213511.png" alt="QQ截图20201230213450"></p><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">//main方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = add(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//实参在此</span></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//形参在此</span></span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与C中函数的区别：函数（function）是面向过程的叫法，方法（method）是面向对象的叫法。</p><h1 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">    ...</span><br><span class="line">    方法体</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修饰符：可选，告诉编译器如何调用该方法。定义了该方法的访问类型。</li><li>返回值类型：方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。</li><li>方法名：是方法的实际名称。方法名和参数表共同构成方法签名。</li><li>参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。<ul><li>形参：在方法被调用时用于接收外界输入的数据。<strong>用来定义作用的。</strong></li><li>实参：调用方法时<strong>实际传给方法的数据</strong>。</li><li><strong>实际参数和形式参数的类型要对应！</strong></li></ul></li><li>方法体：方法体包含具体的语句，定义该方法的功能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1==num2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//常用于终止方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2)&#123;</span><br><span class="line">            <span class="keyword">return</span> num1;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>break与return的区别：</p><ul><li>break：跳出switch，结束循环</li><li>return：结束方法，返回一个结果</li></ul></blockquote><h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.方法名(实参列表)</span><br></pre></td></tr></table></figure><p>根据方法是否有返回值，有两种调用方法的方式：</p><ul><li>返回一个值时，方法调用被当作一个值，定义一个变量去接收这个值；</li><li>返回值是void时，方法调用一定是一条语句。</li></ul><h2 id="静态方法与非静态方法的调用"><a href="#静态方法与非静态方法的调用" class="headerlink" title="静态方法与非静态方法的调用"></a>静态方法与非静态方法的调用</h2><p>调用另一个类里的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticLearn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态方法：直接调用</span></span><br><span class="line">        Student.static_say();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//非静态方法：需要先实例化方法所属的这个类（通过new关键字）</span></span><br><span class="line">        <span class="comment">//对象类型 对象名 = 对象值</span></span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.unstatic_say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态说话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unstatic_say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非静态说话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同一个类里的互相调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//和类一起加载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//不可以在这里直接调用b方法：b();    ×</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       因为static关键字的静态方法随类一起加载，</span></span><br><span class="line"><span class="comment">       非静态方法需要在类实例化后才加载，</span></span><br><span class="line"><span class="comment">       一个已经存在的东西调用一个不存在的东西会报错</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类实例化后才存在</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/lovelyangel2008/article/details/70195549">CSDN博客：静态方法和非静态方法的区别是什么</a></p><h2 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h2><p><strong>Java中方法参数传递方式永远是值传递</strong></p><blockquote><p>如果参数是基本类型，传递的是基本类型的字面量值的拷贝。<br>如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。</p></blockquote><p><a href="https://www.journaldev.com/3884/java-is-pass-by-value-and-not-pass-by-reference">Java is Pass by Value and Not Pass by Reference</a></p><p><a href="https://www.zhihu.com/question/31203609">知乎：Java到底是值传递还是引用传递</a></p><p>证明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Value</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        Value.change(a);</span><br><span class="line">        System.out.println(a);<span class="comment">//仍然输出1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;<span class="comment">//改的是形参的值，不是实参</span></span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用传递：传递的是对象，本质还是值传递</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Refer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(person.name);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        Refer.change(person);</span><br><span class="line">        System.out.println(person.name);<span class="comment">//Messi</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="comment">//person是一个对象，指向Person person = new Person();是一个具体的人，可以修改属性</span></span><br><span class="line">        person.name = <span class="string">&quot;Messi&quot;</span>;<span class="comment">//在改下面Person类里的name的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了一个Person类，有一个name属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引用传递传递的是对象的地址。</strong></p><h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><p>重载：在一个类中有相同的函数名称，但形参不同的函数。</p><p>重载规则：</p><ul><li>方法名称必须相同。</li><li>参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等都算不同）。</li><li>方法的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同不足以成为方法的重载。</li></ul><p>实现理论：方法名称相同时，编译器会根据调用方法的<strong>参数个数、参数类型等去逐个匹配</strong>（匹配完全看参数列表，不管调用方法时用于接收返回值的变量类型），以选择对应的方法，如果匹配失败，则编译器报错。</p><h1 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandLine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; args.length; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;args[&quot;</span>+i+<span class="string">&quot;]: &quot;</span>+args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行一个程序时再传递给它消息，要靠传递命令行参数给main()函数实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D:\Java\code\JavaSE_learning\grammar\src\method&gt;javac CommandLine.java</span><br><span class="line"></span><br><span class="line">D:\Java\code\JavaSE_learning\grammar\src\method&gt;cd ..</span><br><span class="line"></span><br><span class="line">D:\Java\code\JavaSE_learning\grammar\src&gt;java method.CommandLine</span><br><span class="line"></span><br><span class="line">D:\Java\code\JavaSE_learning\grammar\src&gt;java method.CommandLine this is GOAT</span><br><span class="line">args[0]: this</span><br><span class="line">args[1]: is</span><br><span class="line">args[2]: GOAT</span><br></pre></td></tr></table></figure><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><ul><li>JDK1.5之后支持：传递同类型的可变参数给一个方法</li><li>在方法声明中，在指定参数类型后加一个省略号(…)</li><li>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数，任何普通参数必须在它之前声明。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VariableArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VariableArgs variableArgs = <span class="keyword">new</span> VariableArgs();</span><br><span class="line">        variableArgs.test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出最大值</span></span><br><span class="line">        printMax(<span class="number">33</span>,<span class="number">434</span>,<span class="number">11</span>,<span class="number">34.2</span>,<span class="number">8.4</span>,<span class="number">123.3</span>,<span class="number">0.34</span>);</span><br><span class="line">        printMax(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">1</span>, <span class="number">2.3</span>, <span class="number">41</span>, <span class="number">2.4</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>... i)</span></span>&#123;</span><br><span class="line">        System.out.println(i[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(i[<span class="number">2</span>]);</span><br><span class="line">        System.out.println(i[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMax</span><span class="params">(<span class="keyword">double</span>... numbers)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No argument passed.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//代表结束当前方法，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> result = numbers[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &gt; result)&#123;</span><br><span class="line">                result = numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;The max value is &quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归：方法自己调用自己</p><p>用处：利用递归可以用简单的程序来解决一些复杂的问题。 它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。</p><p>递归结构：</p><ul><li>递归头：什么时候不调用自身方法。如果没有头，将陷入死循环。</li><li>递归体：什么时候需要调用自身方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recursion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(f(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归求阶乘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n*f(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="https://www.cnblogs.com/xh_Blog/p/6382604.html">慎用Java递归调用</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程 </tag>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记（三）——流程控制类语法</title>
      <link href="2020/12/29/Java_process_control/"/>
      <url>2020/12/29/Java_process_control/</url>
      
        <content type="html"><![CDATA[<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://docs.oracle.com/javase/8/docs/api/">JDK8帮助文档</a></p><p><a href="https://www.bilibili.com/video/BV12J41137hu">狂神说Java视频</a></p><h1 id="Scanner对象"><a href="#Scanner对象" class="headerlink" title="Scanner对象"></a>Scanner对象</h1><p>通过java.util.Scanner类来获取用户的输入。基本语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure><p>获取输入的字符串：<code>next()</code>和<code>nextLine()</code>方法</p><p>判断是否还有输入的数据：<code>hasNext()</code>和<code>hasNextLine()</code>方法</p><p><img src="http://img.cuper.top/java20201229111637.png" alt="QQ截图20201229111613"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个扫描器对象用于接收键盘数据</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用next方式接收：&quot;</span>);</span><br><span class="line">        <span class="comment">//判断用户有没有输入字符串</span></span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNext())&#123;</span><br><span class="line">            String str = scanner.next();<span class="comment">//程序会等待用户输入完毕</span></span><br><span class="line">            System.out.println(<span class="string">&quot;输出的内容：&quot;</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个扫描器对象用于接收键盘数据</span></span><br><span class="line">        Scanner scanner2 = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用nextLine方式接收：&quot;</span>);</span><br><span class="line">        <span class="comment">//判断是否还有输入</span></span><br><span class="line">        <span class="keyword">if</span> (scanner2.hasNextLine())&#123;</span><br><span class="line">            String str2 = scanner2.nextLine();<span class="comment">//程序会等待用户输入完毕</span></span><br><span class="line">            System.out.println(<span class="string">&quot;输出的内容：&quot;</span>+str2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//凡是属于IO流的类如果不关闭会一直占用资源，要养成良好习惯用完就关掉</span></span><br><span class="line">        scanner.close();</span><br><span class="line">        scanner2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进阶：判断小数与整数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">extern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从键盘接收数据</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> f = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入整数：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNextInt())&#123;</span><br><span class="line">            i = scanner.nextInt();</span><br><span class="line">            System.out.println(<span class="string">&quot;整数数据：&quot;</span>+i);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的不是整数数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入小数：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNextFloat())&#123;</span><br><span class="line">            f = scanner.nextFloat();</span><br><span class="line">            System.out.println(<span class="string">&quot;小数数据：&quot;</span>+f);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的不是小数数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进阶：输入多个数字求其总和与平均值，每输入一个数字用回车确认，通过输入非数字来结束输入并输出执行结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">count</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//输入多个数字求其总和与平均值，每输入一个数字用回车确认，通过输入非数字来结束输入并输出执行结果</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//和</span></span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算输入了多少个数字</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入数据：&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过循环判断是否还有输入，并在里面对每一次进行求和和统计</span></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextDouble())&#123;</span><br><span class="line">            <span class="keyword">double</span> x = scanner.nextDouble();</span><br><span class="line">            m++;</span><br><span class="line">            sum+=x;</span><br><span class="line">            System.out.println(<span class="string">&quot;你输入了第&quot;</span>+m+<span class="string">&quot;个数，当前总和为：&quot;</span>+sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(m+<span class="string">&quot;个数的和为：&quot;</span>+sum);</span><br><span class="line">        System.out.println(m+<span class="string">&quot;个数的平均值为：&quot;</span>+(sum/m));</span><br><span class="line"></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h1><p><img src="http://img.cuper.top/java20201229153121.png" alt="QQ截图20201229153053"></p><h1 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h1><h2 id="if选择结构"><a href="#if选择结构" class="headerlink" title="if选择结构"></a>if选择结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式1为true将执行的语句</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式2为true将执行的语句</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式3为true将执行的语句</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果以上布尔表达式都不为true将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch选择结构"><a href="#switch选择结构" class="headerlink" title="switch选择结构"></a>switch选择结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value:</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">case</span> value:</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//可选</span></span><br><span class="line">    <span class="comment">//可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span>:<span class="comment">//可选</span></span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>switch</code>中的变量类型支持byte、short、int、char、String</li><li><code>case</code>标签必须为字符串变量或者字面量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Switch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> grade = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">        <span class="comment">//case穿透    switch匹配一个具体的值</span></span><br><span class="line">        <span class="keyword">switch</span> (grade)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">                <span class="comment">//break;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;再接再厉&quot;</span>);</span><br><span class="line">                <span class="comment">//break;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;挂科&quot;</span>);</span><br><span class="line">                <span class="comment">//break;</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;未知等级&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK7后新特性：switch表达式可以是String类型变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">&quot;Messi&quot;</span>;</span><br><span class="line">        <span class="comment">//JDK7后的新特性，switch表达式可以是String类型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (name)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Messi&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;GOAT&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Suarez&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Shooter&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用IDEA（其实是一个反编译工具）直接打开.class文件，可以看到对应的switch语句<code>switch(name.hashCode())</code>和<code>case -1807693272:</code>，说明<strong>一切字符的本质还是数字</strong>。</p><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(布尔表达式)&#123;</span><br><span class="line">    <span class="comment">//循环内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当布尔表达式为true，循环会一直执行下去</li><li>为了让循环停下来，一般需要一个让表达式失效的方式来结束循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">While</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//输出1-100</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;<span class="number">100</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式)</span><br></pre></td></tr></table></figure><p>与while循环的区别：</p><ul><li>while先判断后执行，do-while先执行后判断</li><li>do-while总是保证循环体会被至少执行一次</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoWhile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">while</span> (i&lt;=<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;<span class="keyword">while</span> (a&lt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化; 布尔表达式; 更新)&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最先执行初始化步骤。可以声明一种类型， 但可初始化一个或多个循环控制变量，也可以是空语句。</li><li>然后，检测布尔表达式的值。如果为true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</li><li>执行一次循环后，更新循环控制变量（迭代因子控制循环变量的增减）。</li><li>再次检测布尔表达式。循环执行上面的过程。</li></ul><p>死循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(; ; )&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">For</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;<span class="comment">//在IDEA里输入100.for自动生成这一行</span></span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算0-100之间的奇数和偶数的和</span></span><br><span class="line">        <span class="keyword">int</span> oddSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> evenSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                oddSum+=i;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                evenSum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;奇数的和：&quot;</span>+oddSum);</span><br><span class="line">        System.out.println(<span class="string">&quot;偶数的和：&quot;</span>+evenSum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出1-1000之间能被5整除的数，并且每行输出3个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i%(<span class="number">5</span>*<span class="number">3</span>)==<span class="number">0</span>)&#123;<span class="comment">//每行</span></span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="comment">//System.out.print(&quot;\n&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//println：输出完会换行</span></span><br><span class="line">        <span class="comment">//print：输出完不会换行</span></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印九九乘法表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(j+<span class="string">&quot;×&quot;</span>+i+<span class="string">&quot;=&quot;</span>+j*i+<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明语句 : 表达式)&#123;</span><br><span class="line">    <span class="comment">//代码句子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</li><li>表达式：表达式是要访问的数组名，或者是返回值为数组的方法。</li></ul><p>主要用于数组或者集合中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x:numbers)&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break&amp;continue"></a>break&amp;continue</h2><ul><li>break：强行退出循环</li><li>continue：终止某次循环过程，跳过循环体中尚未执行的语句而接着进行下一次循环的判定</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreakContinue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;<span class="number">100</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">30</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;<span class="number">100</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印三角形"><a href="#打印三角形" class="headerlink" title="打印三角形"></a>打印三角形</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTriangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//打印三角形 5行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">5</span>; j &gt;= i; j--) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i; k++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; i; m++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记（二）——入门基础语法</title>
      <link href="2020/12/21/Java_grammar/"/>
      <url>2020/12/21/Java_grammar/</url>
      
        <content type="html"><![CDATA[<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://docs.oracle.com/javase/8/docs/api/">JDK8帮助文档</a></p><p><a href="https://www.bilibili.com/video/BV12J41137hu">狂神说Java视频</a></p><h1 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h1><p><img src="http://img.cuper.top/bigdata20201222203849.png" alt="QQ截图20201222200026"></p><h1 id="HelloWorld、注释、标识符"><a href="#HelloWorld、注释、标识符" class="headerlink" title="HelloWorld、注释、标识符"></a>HelloWorld、注释、标识符</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;<span class="comment">//类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//方法</span></span><br><span class="line">        <span class="comment">//单行注释</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        多行注释</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        String $hello=<span class="string">&quot;World&quot;</span>;<span class="comment">//变量</span></span><br><span class="line">        String _hello=<span class="string">&quot;World&quot;</span>;<span class="comment">//标识符大小写敏感</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="所有的关键字"><a href="#所有的关键字" class="headerlink" title="所有的关键字"></a>所有的关键字</h1><p><img src="http://img.cuper.top/java20201226153004.png" alt="fiyfyi"></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p><img src="http://img.cuper.top/java20201226183419.png" alt="变量类型"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">type</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//八大基本数据类型</span></span><br><span class="line">        <span class="comment">//整数</span></span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">10</span>;<span class="comment">//最常用</span></span><br><span class="line">        <span class="keyword">byte</span> num2=<span class="number">20</span>;</span><br><span class="line">        <span class="keyword">short</span> num3=<span class="number">30</span>;</span><br><span class="line">        <span class="keyword">long</span> num4=<span class="number">30L</span>;<span class="comment">//long类型要在数字后面加L</span></span><br><span class="line">        <span class="comment">//浮点数</span></span><br><span class="line">        <span class="keyword">float</span> num5=<span class="number">50.1F</span>;<span class="comment">//浮点数默认为double，用float要用F区分一下</span></span><br><span class="line">        <span class="keyword">double</span> num6=<span class="number">3.1415926</span>;</span><br><span class="line">        <span class="comment">//字符</span></span><br><span class="line">        <span class="keyword">char</span> name =<span class="string">&#x27;鸟&#x27;</span>;</span><br><span class="line">        <span class="comment">//字符串，String不是关键字，是一个类</span></span><br><span class="line">        String str=<span class="string">&quot;asuka&quot;</span>;<span class="comment">//IDEA里Ctrl+Alt+鼠标左键单击String，跳转到定义</span></span><br><span class="line">        <span class="comment">//布尔值</span></span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><p><img src="http://img.cuper.top/java20201226183428.png" alt="字节"></p><h2 id="数据类型的扩展（面试题）"><a href="#数据类型的扩展（面试题）" class="headerlink" title="数据类型的扩展（面试题）"></a>数据类型的扩展（面试题）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">type_extern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//整数扩展</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i2=<span class="number">010</span>;<span class="comment">//八进制用0开头</span></span><br><span class="line">        <span class="keyword">int</span> i3=<span class="number">0x10</span>;<span class="comment">//十进制用0x开头</span></span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(i2);<span class="comment">//八进制的10是十进制的8</span></span><br><span class="line">        System.out.println(i3);<span class="comment">//十六进制的10是十进制的16</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;******************************************************&quot;</span>);</span><br><span class="line">        <span class="comment">//浮点扩展</span></span><br><span class="line">        <span class="keyword">float</span> f=<span class="number">0.1f</span>;</span><br><span class="line">        <span class="keyword">double</span> d=<span class="number">1.0</span>/<span class="number">10</span>;</span><br><span class="line">        System.out.println(f==d);<span class="comment">//false</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> e1=<span class="number">1231231231133f</span>;</span><br><span class="line">        <span class="keyword">float</span> e2=e1+<span class="number">1</span>;</span><br><span class="line">        System.out.println(e1==e2);<span class="comment">//true</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        原因：由于浮点数有限、离散，存在舍入误差，存在大约接近但不等于的情况</span></span><br><span class="line"><span class="comment">        *************最好完全避免使用浮点数进行比较*************</span></span><br><span class="line"><span class="comment">        要用一个类：BigDecimal 数学工具类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;******************************************************&quot;</span>);</span><br><span class="line">        <span class="comment">//字符扩展</span></span><br><span class="line">        <span class="keyword">char</span> c1=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">char</span> c2=<span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println((<span class="keyword">int</span>) c1);<span class="comment">//强制转换</span></span><br><span class="line">        System.out.println((<span class="keyword">int</span>) c2);</span><br><span class="line">        <span class="comment">//**所有的字符本质还是数字</span></span><br><span class="line">        <span class="comment">//char的编码用Unicode表，范围是0-2^16(65536)</span></span><br><span class="line">        <span class="keyword">char</span> c3=<span class="string">&#x27;\u0061&#x27;</span>;</span><br><span class="line">        System.out.println(c3);<span class="comment">//用\\u转义十六进制编码0061=十进制97，即为字母a</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从内存分析对象</span></span><br><span class="line">        String str_a=<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        String str_b=<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(str_a==str_b);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        String str_c=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String str_d=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(str_c==str_d);<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//面试题基于此问==与equals的区别</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;******************************************************&quot;</span>);</span><br><span class="line">        <span class="comment">//布尔值扩展</span></span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//以下两行代码意义及效果一样</span></span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="keyword">true</span>)&#123;&#125;<span class="comment">//新手</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;&#125;<span class="comment">//老手</span></span><br><span class="line">        <span class="comment">//Less is More</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><img src="http://img.cuper.top/java20201226203844.png" alt="QQ截图20201226203756"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">type_change</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">byte</span> b=(<span class="keyword">byte</span>) i;<span class="comment">//byte最大值127，内存溢出，补码为-128</span></span><br><span class="line">        <span class="keyword">double</span> c=i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//高→低 需要强制转换  (类型)变量名</span></span><br><span class="line">        <span class="comment">//低→高 自动转换  直接=变量名</span></span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        注：</span></span><br><span class="line"><span class="comment">        1.不能对布尔值进行转换</span></span><br><span class="line"><span class="comment">        2.不能把对象类型转换为不相干的类型</span></span><br><span class="line"><span class="comment">        3.在把高容量转换到低容量的时候，强制转换</span></span><br><span class="line"><span class="comment">        4.转换的时候可能存在内存溢出或者精度问题</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println((<span class="keyword">int</span>)<span class="number">23.7</span>);</span><br><span class="line">        System.out.println((<span class="keyword">int</span>) -<span class="number">45.89f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c1=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> d=c1+<span class="number">1</span>;</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) d);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*********************************************&quot;</span>);</span><br><span class="line">        <span class="comment">//操作比较大的数的时候注意溢出问题</span></span><br><span class="line">        <span class="comment">//JDK7新特性：数字之间可以用下划线分割</span></span><br><span class="line">        <span class="keyword">int</span> money=<span class="number">10_0000_0000</span>;</span><br><span class="line">        System.out.println(money);</span><br><span class="line">        <span class="keyword">int</span> year=<span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> total=money*year;<span class="comment">//计算的时候溢出了</span></span><br><span class="line">        System.out.println(total);</span><br><span class="line">        <span class="keyword">long</span> total2=money*year;<span class="comment">//默认是int，转换之前计算两个int相乘的结果时已经溢出</span></span><br><span class="line">        System.out.println(total2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> total3=money*((<span class="keyword">long</span>)year);<span class="comment">//先把一个数转换为long</span></span><br><span class="line">        System.out.println(total3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变量、常量、作用域"><a href="#变量、常量、作用域" class="headerlink" title="变量、常量、作用域"></a>变量、常量、作用域</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type varName [=value] [&#123;,varName[=value]&#125;];</span><br><span class="line"><span class="comment">//数据类型 变量名 = 值; 可以使用逗号隔开来声明多个同类型的变量。</span></span><br></pre></td></tr></table></figure><ul><li>Java作为一种强类型语言，每个变量都必须声明其类型；</li><li>Java变量是程序中最基本的存储单元，其要素包括变量名、变量类型和作用域。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性：变量，分为类变量、实例变量和局部变量三种</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类变量：需要关键字static，方法里可以直接调用，不用new</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> salary=<span class="number">2500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    实例变量：从属于对象；如果不进行初始化，会赋予这个类型的默认值，</span></span><br><span class="line"><span class="comment">    数字类型是0，布尔值默认false，</span></span><br><span class="line"><span class="comment">    除了基本类型其余都是null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//常量</span></span><br><span class="line">    <span class="comment">//修饰符不存在先后顺序</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> Pi = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//main方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//局部变量；必须声明和初始化值，只在本括号内有用</span></span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//变量类型 变量名字 = new var();</span></span><br><span class="line">        <span class="keyword">var</span> var2 = <span class="keyword">new</span> <span class="keyword">var</span>();</span><br><span class="line">        System.out.println(var2.age);</span><br><span class="line">        System.out.println(var2.name);</span><br><span class="line"></span><br><span class="line">        System.out.println(salary);</span><br><span class="line"></span><br><span class="line">        System.out.println(PI);</span><br><span class="line">        System.out.println(Pi);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> 常量名 = 值;</span><br></pre></td></tr></table></figure><ul><li>值设定之后在程序运行过程中不允许被改变</li><li>常量名一般用大写字符</li></ul><h2 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h2><ul><li>所有变量、方法、类名：见名知意</li><li>类成员变量：首字母小写和驼峰原则: monthSalary，即除了第一个单词以外，后面的单词首字母大写</li><li>局部变量：首字母小写和驼峰原则</li><li>常量：大写字母和下划线: MAX_ VALUE</li><li>类名：首字母大写和驼峰原则: Man, GoodMan</li><li>方法名：首字母小写和驼峰原则: run(), runRun()</li></ul><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><img src="http://img.cuper.top/java20201227142609.png" alt="QQ截图20201227142547"></p><h2 id="算术、关系运算、自增自减"><a href="#算术、关系运算、自增自减" class="headerlink" title="算术、关系运算、自增自减"></a>算术、关系运算、自增自减</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//算术运算符</span></span><br><span class="line">        <span class="keyword">long</span> a=<span class="number">1234131121L</span>;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">123</span>;</span><br><span class="line">        <span class="keyword">short</span> c=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">byte</span> d=<span class="number">8</span>;</span><br><span class="line">        System.out.println(a+b+c+d);<span class="comment">//运算中若有一个为long类型变量参与，结果为long类型</span></span><br><span class="line">        System.out.println(b+c+d);</span><br><span class="line">        System.out.println(c+d);<span class="comment">//若没有long类型变量参与，默认结果均为int类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//关系运算符返回一个布尔值</span></span><br><span class="line">        <span class="keyword">int</span> e=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">20</span>;</span><br><span class="line">        System.out.println(e==f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//++ --:自增自减——一元运算符</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> j=i++;<span class="comment">//执行完这一行代码后，先给j赋值，i再自增</span></span><br><span class="line">        <span class="comment">//相当于在这里隐藏了一句i=i+1;</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="comment">//相当于在这里隐藏了一句i=i+1;</span></span><br><span class="line">        <span class="keyword">int</span> k=++i;<span class="comment">//执行完这一行代码之前，i先自增，再给k赋值</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        System.out.println(k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//幂运算 使用Math工具类来操作</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">logic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//逻辑运算符</span></span><br><span class="line">        <span class="keyword">boolean</span> a = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(a&amp;&amp;b);</span><br><span class="line">        System.out.println(a||b);</span><br><span class="line">        System.out.println(!(a&amp;&amp;b));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//短路运算</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">boolean</span> d = (c&lt;<span class="number">4</span>)&amp;&amp;(c++&lt;<span class="number">4</span>);<span class="comment">//与运算在遇到第一个为false的情况下不会继续判断后面第二个值</span></span><br><span class="line">        System.out.println(d);</span><br><span class="line">        System.out.println(c);<span class="comment">//并没有执行后面的c++</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//位运算</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        A = 0011 1100</span></span><br><span class="line"><span class="comment">        B = 0000 1101</span></span><br><span class="line"><span class="comment">        ------------------------</span></span><br><span class="line"><span class="comment">        A&amp;B = 0000 1100</span></span><br><span class="line"><span class="comment">        A|B = 0011 1101</span></span><br><span class="line"><span class="comment">        A^B = 0011 0001 (异或)</span></span><br><span class="line"><span class="comment">        ~B = 1111 0010</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        面试题：用最快的方法计算2*8——计算机是不会乘除法的</span></span><br><span class="line"><span class="comment">        效率极高，直接跟底层打交道</span></span><br><span class="line"><span class="comment">        &lt;&lt;:按位左移，相当于把数字*2</span></span><br><span class="line"><span class="comment">        &gt;&gt;:按位右移，相当于把数字/2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0000 0000   0</span></span><br><span class="line"><span class="comment">        0000 0001   1</span></span><br><span class="line"><span class="comment">        0000 0010   2</span></span><br><span class="line"><span class="comment">        0000 0100   4</span></span><br><span class="line"><span class="comment">        0000 1000   8</span></span><br><span class="line"><span class="comment">        0001 0000   16</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="number">2</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_35402412/article/details/81156020">&gt;&gt;&gt;与&gt;&gt;的区别参考</a></p><h2 id="条件运算及扩展赋值"><a href="#条件运算及扩展赋值" class="headerlink" title="条件运算及扩展赋值"></a>条件运算及扩展赋值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">extern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        a+=b;</span><br><span class="line">        a-=b;</span><br><span class="line">        System.out.println(a+=b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串连接符+:只要有一个变量是String类型，都会把其他变量转换成String类型然后进行连接</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sum&quot;</span>+a+b);</span><br><span class="line">        System.out.println(a+b+<span class="string">&quot;sum&quot;</span>);<span class="comment">//【面试题】会先进行运算，再检测到有String变量，进行字符串转换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//三元运算符</span></span><br><span class="line">        <span class="comment">//x ? y : z</span></span><br><span class="line">        <span class="comment">//如果x==true，则结果为y，否则为z</span></span><br><span class="line">        <span class="keyword">int</span> score = <span class="number">80</span>;</span><br><span class="line">        String type = score &lt; <span class="number">60</span> ? <span class="string">&quot;不及格&quot;</span> : <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        System.out.println(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h1><p><img src="http://img.cuper.top/QQ%E6%88%AA%E5%9B%BE20201228190818.png" alt="QQ截图20201228190818"></p><h1 id="JavaDoc-文档注释"><a href="#JavaDoc-文档注释" class="headerlink" title="JavaDoc(文档注释)"></a>JavaDoc(文档注释)</h1><p>在IDEA中输入<code>/**</code>回车可自动生成文档注释样式，可加在类或者方法上面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cuper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doc</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> cuper</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数信息：</p><ul><li>@author: 作者名</li><li>@version: 版本号</li><li>@since: 指明需要最早使用的jdk版本</li><li>@param: 参数名</li><li>@return: 返回值情况</li><li>@throws: 异常抛出情况</li></ul><p>用命令行生成JavaDoc文档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc -encoding UTF-8 -charset UTF-8 xxx.java</span><br></pre></td></tr></table></figure><p>然后会生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">D:\Java\code\JavaSE_learning\grammar\src\<span class="built_in">type</span>&gt;javadoc -encoding UTF-8 -charset UTF-8 type_base.java</span><br><span class="line">正在加载源文件type_base.java...</span><br><span class="line">正在构造 Javadoc 信息...</span><br><span class="line">标准 Doclet 版本 1.8.0_181</span><br><span class="line">正在构建所有程序包和类的树...</span><br><span class="line">正在生成.\<span class="built_in">type</span>\type_base.html...</span><br><span class="line">正在生成.\<span class="built_in">type</span>\package-frame.html...</span><br><span class="line">正在生成.\<span class="built_in">type</span>\package-summary.html...</span><br><span class="line">正在生成.\<span class="built_in">type</span>\package-tree.html...</span><br><span class="line">正在生成.\constant-values.html...</span><br><span class="line">正在构建所有程序包和类的索引...</span><br><span class="line">正在生成.\overview-tree.html...</span><br><span class="line">正在生成.\index-all.html...</span><br><span class="line">正在生成.\deprecated-list.html...</span><br><span class="line">正在构建所有类的索引...</span><br><span class="line">正在生成.\allclasses-frame.html...</span><br><span class="line">正在生成.\allclasses-noframe.html...</span><br><span class="line">正在生成.\index.html...</span><br><span class="line">正在生成.\help-doc.html...</span><br></pre></td></tr></table></figure><p>点击index.html可以看到官方界面的JavaDoc文档。</p><p>用IDEA生成JavaDoc<a href="https://blog.csdn.net/weixin_42140580/article/details/89635775">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习笔记——Shell入门</title>
      <link href="2020/12/14/shell_Note/"/>
      <url>2020/12/14/shell_Note/</url>
      
        <content type="html"><![CDATA[<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.bilibili.com/video/BV1hW41167NW">B站视频：尚硅谷Shell教程(shell自动化编程精讲)</a></p><h1 id="Shell概述"><a href="#Shell概述" class="headerlink" title="Shell概述"></a>Shell概述</h1><p><img src="http://img.cuper.top/bigdata20201214171703.png"></p><h1 id="Shell解析器"><a href="#Shell解析器" class="headerlink" title="Shell解析器"></a>Shell解析器</h1><ul><li>Linux提供的Shell解析器</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[cuper@iZe4h75o51zvd0Z ~]$ cat /etc/shells</span><br><span class="line">/bin/sh <span class="comment">#重要</span></span><br><span class="line">/bin/bash <span class="comment">#重要</span></span><br><span class="line">/sbin/nologin</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br></pre></td></tr></table></figure><ul><li>bash和sh的关系</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[cuper@iZe4h75o51zvd0Z bin]$ ll | grep bash</span><br><span class="line">-rwxr-xr-x  1 root root    1219248 Nov  9  2019 bash</span><br><span class="line">lrwxrwxrwx  1 root root          4 Nov  9  2019 sh -&gt; bash</span><br></pre></td></tr></table></figure><p>sh为bash的软链接，功能一样。</p><ul><li>CentOS默认的解析器</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[cuper@iZe4h75o51zvd0Z bin]$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><h1 id="Shell脚本入门"><a href="#Shell脚本入门" class="headerlink" title="Shell脚本入门"></a>Shell脚本入门</h1><h2 id="脚本格式"><a href="#脚本格式" class="headerlink" title="脚本格式"></a>脚本格式</h2><p>脚本以<code>#!/bin/bash</code>开头：指定解析器</p><blockquote><p>Shell脚本注释即以”#“开头。</p></blockquote><h2 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h2><p>创建脚本文件<code>vim Helloworld.sh</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;Hello World!&quot;</span><br></pre></td></tr></table></figure><p>保存后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash Helloworld.sh</span><br><span class="line">sh Helloworld.sh</span><br><span class="line">./Helloworld.sh</span><br></pre></td></tr></table></figure><p>以上三个命令效果相等，文件的绝对路径或相对路径均可。</p><p><strong>注：</strong><code>./Helloworld.sh</code>需要当前用户有可执行的权限，需要给所有者添加才可执行：<code>chmod u+x Helloworld.sh</code></p><blockquote><p>第一、二个命令本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限；第三个命令本质是脚本需要自己执行，所以需要执行权限。</p></blockquote><h2 id="多命令处理"><a href="#多命令处理" class="headerlink" title="多命令处理"></a>多命令处理</h2><p>一行一命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">cd /home/atguigu #路径跳转</span><br><span class="line">touch cls.txt #创建文件</span><br><span class="line">echo &quot;I love cls&quot; &gt;&gt;cls.txt #写入内容</span><br></pre></td></tr></table></figure><h1 id="脚本变量"><a href="#脚本变量" class="headerlink" title="脚本变量"></a>脚本变量</h1><h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><p>常用变量：</p><p><code>$HOME</code>：当前用户的家目录<br><code>$PWD</code>：当前绝对路径<br><code>$SHELL</code>：当前脚本使用的解析器<br><code>$USER</code>：当前用户</p><p>查看系统变量的值：<code>echo $变量名</code>（<code>$</code>为取后面变量名对应的值的意思）</p><p>显示当前Shell中所有变量：<code>set</code></p><p>使用一个定义过的变量，只要在变量名前面加<code>$</code>即可。</p><h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li>定义变量：<code>变量=值</code>（不用<code>$</code>）</li><li>撤销变量：<code>unset 变量</code>（不用<code>$</code>）</li><li>声明静态变量：<code>readonly 变量=值</code>（注意：静态变量只能一次赋值，无法unset，不能更改内容，不能重设，只有当前shell注销后才失效）</li></ul><h3 id="变量定义规则"><a href="#变量定义规则" class="headerlink" title="变量定义规则"></a>变量定义规则</h3><ul><li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名<strong>建议大写</strong>。</li><li><strong>等号两侧不能有空格。</strong></li><li>在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。</li><li>变量的值如果有空格，需要使用双引号或单引号括起来。</li></ul><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>把变量提升为全局环境变量，可供其他Shell程序使用：<code>export 变量名</code></p><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><h3 id="n"><a href="#n" class="headerlink" title="$n"></a>$n</h3><p>传递给脚本的第n个参数值，n为数字，<code>$0</code>代表该脚本名称，<code>$1</code>-<code>$9</code>代表第一到第九个参数，十以上的参数需要用大括号包含（如<code>$&#123;10&#125;</code>），执行时输入的实参直接空格跟在脚本执行命令后面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xxx.sh <span class="variable">$1</span>的值 <span class="variable">$2</span>的值 ...</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title="$#"></a>$#</h3><p>获取所有输入参数的<strong>个数</strong>，常用于循环，在脚本里直接调用<code>$#</code>。</p><h3 id="-1"><a href="#-1" class="headerlink" title="$*"></a>$*</h3><p>代表命令行中所有的参数，把所有的参数看成一个整体</p><h3 id="-2"><a href="#-2" class="headerlink" title="$@"></a>$@</h3><p>代表命令行中所有的参数，把每个参数区分对待</p><h3 id="？"><a href="#？" class="headerlink" title="$？"></a>$？</h3><p>显示最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>两种语法：</p><ol><li><code>$((运算式))</code>或<code>$[运算式]</code> ：作为变量</li><li><code>expr  + , - , \*, /, %</code> ：分别为加，减，乘（需要转义），除，取余，直接运算在终端上，<strong>expr运算符间要有空格</strong>。</li></ol><h1 id="条件判断（测试表达式）"><a href="#条件判断（测试表达式）" class="headerlink" title="条件判断（测试表达式）"></a>条件判断（测试表达式）</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>[ condition ]</code></p><p><strong>注意：condition前后要有空格</strong>，条件非空即为true，[ xxx ]返回true，[] 返回false。</p><h2 id="常用判断条件"><a href="#常用判断条件" class="headerlink" title="常用判断条件"></a>常用判断条件</h2><ol><li>两个整数之间比较：<code>[ num1 -参数 num2 ]</code></li></ol><ul><li><code>=</code> 字符串比较</li><li><code>-lt</code> 小于（less than）</li><li><code>-le</code> 小于等于（less equal）</li><li><code>-eq</code> 等于（equal）</li><li><code>-gt</code> 大于（greater than）</li><li><code>-ge</code> 大于等于（greater equal）</li><li><code>-ne</code> 不等于（Not equal）</li></ul><ol start="2"><li>按照文件权限进行判断：<code>[ -参数 文件 ]</code></li></ol><ul><li><code>-r</code> 有读的权限（read）</li><li><code>-w</code> 有写的权限（write）</li><li><code>-x</code> 有执行的权限（execute）</li></ul><ol start="3"><li>按照文件类型进行判断：<code>[ -参数 文件 ]</code></li></ol><ul><li><code>-f</code> 文件存在并且是一个常规的文件（file）</li><li><code>-e</code> 文件存在（existence)</li><li><code>-d</code> 文件存在并是一个目录（directory）</li></ul><h2 id="多条件判断"><a href="#多条件判断" class="headerlink" title="多条件判断"></a>多条件判断</h2><p><code>expression1 &amp;&amp; expression2</code>：与条件，表示expression1为真时，才执行expression2</p><p><code>expression1 || expression2</code>： 或条件，表示expression1为假才执行expression2，若expression1为真则直接返回true</p><p><code>expression1 ; expression2</code>：不管expression1执行是否正确，expression2都会执行（可用于脚本里把多个命令写在同一行）</p><p>常用：<code>[ condition ] &amp;&amp; echo 1 || echo 0</code> 三元判断式用于直接测试condition是否返回true。</p><p><img src="https://images2018.cnblogs.com/blog/1447389/201807/1447389-20180728163512674-1284919694.png"></p><p><a href="https://blog.csdn.net/wuhanyeah/article/details/102823096">参考博文</a></p><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h2><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ];then </span><br><span class="line">  程序</span><br><span class="line">elif [ 条件判断式 ];then</span><br><span class="line">  程序</span><br><span class="line">...</span><br><span class="line">else</span><br><span class="line">  程序</span><br><span class="line">fi </span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ] </span><br><span class="line">  then</span><br><span class="line">    程序</span><br><span class="line">elif [ 条件判断式 ] </span><br><span class="line">  then</span><br><span class="line">    程序</span><br><span class="line">...</span><br><span class="line">else</span><br><span class="line">    程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>注：</p><ul><li><code>[ 条件判断式 ]</code>中括号和条件判断式之间必须有空格</li><li><strong>if后要有空格</strong></li></ul><h2 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h2><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case $变量名 in </span><br><span class="line">  &quot;值1&quot;)</span><br><span class="line">    如果变量的值等于值1则执行的程序1 </span><br><span class="line">    ;;</span><br><span class="line">  &quot;值2&quot;) </span><br><span class="line">    如果变量的值等于值2则执行的程序2 </span><br><span class="line">    ;;</span><br><span class="line">  …省略其他分支… </span><br><span class="line">  *) </span><br><span class="line">    如果变量的值都不是以上的值则执行的程序（即default） </span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>case行尾必须为单词<code>in</code>，每一个模式匹配必须以右括号<code>)</code>结束。</li><li>双分号<code>;;</code>表示命令序列结束，相当于java中的<code>break</code>。</li><li>最后的<code>*)</code>表示默认模式，相当于java中的<code>default</code>。</li></ul><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>语法1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 )) </span><br><span class="line">  do </span><br><span class="line">    程序 </span><br><span class="line">  done</span><br></pre></td></tr></table></figure><p>语法2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3… </span><br><span class="line">  do </span><br><span class="line">    程序 </span><br><span class="line">  done</span><br></pre></td></tr></table></figure><p>注：<code>in</code>后面常用<code>$*</code>或<code>$@</code>，在不带双引号时两者等价，都以<code>$1 $2 … $n</code>的形式输出所有参数。</p><p>若被双引号<code>&quot;&quot;</code>包含时：</p><ul><li><code>&quot;$*&quot;</code>会将所有的参数作为一个整体，以<code>&quot;$1 $2 … $n&quot;</code>的形式输出所有参数，若在for循环的in里，所有参数看成是一个整体，所以for循环只会循环一次；</li><li><code>&quot;$@&quot;</code>会将各个参数分开，以<code>&quot;$1&quot;</code> <code>&quot;$2&quot;</code> …<code>&quot;$n&quot;</code>的形式输出所有参数，若在for循环的in里，每个参数都看成是独立的，所以<code>&quot;$@&quot;</code>中有几个参数，就会循环几次 。</li></ul><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [ 条件判断式 ] </span><br><span class="line">  do </span><br><span class="line">    程序</span><br><span class="line">  done</span><br></pre></td></tr></table></figure><p>注：</p><ul><li><code>[ 条件判断式 ]</code>中括号和条件判断式之间必须有空格</li><li><strong>while后要有空格</strong></li></ul><h1 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h1><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read (选项) (参数)</span><br></pre></td></tr></table></figure><p>选项：</p><ul><li><p>-p：指定读取值时的提示符；</p></li><li><p>-t：指定读取值时等待的时间（秒）。</p></li></ul><p>参数：</p><ul><li>变量：指定读取值的变量名</li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h2><h3 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basename [string或pathname] [suffix]</span><br></pre></td></tr></table></figure><p>功能：去掉文件名的路径和后缀，会删掉所有的前缀包括最后一个<code>/</code>字符，然后将字符串显示出来，常用于从绝对路径里截取出文件名称。</p><p>选项：suffix为后缀名，如果suffix被指定了，basename会将pathname或string中的suffix同时去掉。</p><h3 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirname 文件绝对路径</span><br></pre></td></tr></table></figure><p>功能：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分）</p><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>实质：自定义一个终端命令</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ function ] funname[()] #这一行中括号里的function和小括号()均意为可写可不写</span><br><span class="line">&#123;</span><br><span class="line">Action;</span><br><span class="line">[return int;] #return可选</span><br><span class="line">&#125;</span><br><span class="line">funname</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><strong>必须在调用函数地方之前先声明函数</strong>，shell脚本是逐行运行，不会像其它语言一样先编译。</li><li>函数返回值只能通过系统变量<code>$?</code>获得，可以显示加<code>return</code>返回；如果不加，将以最后一条命令运行结果，作为返回值。<code>return</code>后跟数值n(0-255)。</li></ul><h1 id="Shell工具"><a href="#Shell工具" class="headerlink" title="Shell工具"></a>Shell工具</h1><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>cut的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut [选项参数] filename</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-f</td><td>列号，提取第几列</td></tr><tr><td>-d</td><td>分隔符，按照指定分隔符分割列（默认值为制表符）</td></tr></tbody></table><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul><li>在以空格为分隔符的cut.txt文件中切割出在某一行第一列里的”guan”：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat cut.txt | grep &quot;guan&quot; | cut -d &quot; &quot; -f 1</span><br></pre></td></tr></table></figure></li><li>选取系统PATH变量值，第2个<code>:</code>开始后的所有路径：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH | cut -d : -f 2- #`n-`表示从第n列开始到最后的所有字符串，`-n`表示从字符串开始取到第n列，均包含第n列本身</span><br></pre></td></tr></table></figure></li><li>切割ifconfig后打印的IP地址：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[cuper@iZe4h75o51zvd0Z ~]$ ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.19.31  netmask 255.255.240.0  broadcast 172.16.31.255</span><br><span class="line">        inet6 fe80::216:3eff:fe12:e6ca  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:16:3e:12:e6:ca  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 9518632  bytes 4811078305 (4.4 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 9940677  bytes 4450481278 (4.1 GiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">[cuper@iZe4h75o51zvd0Z ~]$ ifconfig eth0 | grep &quot;inet &quot; | cut -d &#x27;t&#x27; -f 2 | cut -d &#x27; &#x27; -f 2</span><br><span class="line">172.16.19.31</span><br></pre></td></tr></table></figure></li></ul><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>sed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。<strong>文件内容并没有改变</strong>，除非使用重定向存储输出。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [选项参数] &#x27;command&#x27; filename</span><br></pre></td></tr></table></figure><h3 id="选项参数"><a href="#选项参数" class="headerlink" title="选项参数"></a>选项参数</h3><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>将下一个参数解释为一个sed指令，只有当命令行上给出多个sed指令时才需要使用-e选项</td></tr></tbody></table><h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><table><thead><tr><th>命令</th><th>功能描述</th></tr></thead><tbody><tr><td>a</td><td>新增，a的后面可以接字符串，在下一行出现</td></tr><tr><td>d</td><td>删除</td></tr><tr><td>s</td><td>查找并替换</td></tr></tbody></table><p>命令的使用：<code>&#39;command&#39;</code> = <code>&#39;na xxxx&#39;</code>表示在第n行下面加入xxxx内容。</p><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><ul><li>将’hello’这个单词插入到sed.txt第二行下，打印：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;2a hello&#x27; sed.txt</span><br></pre></td></tr></table></figure><p><strong>注意：文件并没有改变</strong></p><ul><li>删除sed.txt文件所有包含hello的行：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/wo/d&#x27; sed.txt</span><br></pre></td></tr></table></figure><ul><li>将sed.txt文件中hello替换为hi：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/hello/hi/g&#x27; sed.txt</span><br></pre></td></tr></table></figure><p><strong>注意：<code>g</code>表示global，全部替换</strong></p><ul><li>将sed.txt文件中的第二行删除并将hello替换为hi：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;2d&#x27; -e &#x27;s/hello/hi/g&#x27; sed.txt</span><br></pre></td></tr></table></figure><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><p>一个强大的文本分析工具，把文件逐行地读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk [选项参数] &#x27;pattern1&#123;action1&#125; pattern2&#123;action2&#125; ...&#x27; filename</span><br></pre></td></tr></table></figure><ul><li>pattern：表示<code>awk</code>在数据中查找的内容，就是匹配模式，若没有则表示全部匹配</li><li>action：在找到匹配内容时所执行的一系列命令</li></ul><h3 id="选项参数-1"><a href="#选项参数-1" class="headerlink" title="选项参数"></a>选项参数</h3><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-F</td><td>指定输入文件的分隔符</td></tr><tr><td>-v</td><td>var=value，赋值一个用户定义变量，方便action调用</td></tr><tr><td>-f</td><td>后接一个保存了awk程序的文件，代替在命令行指定awk程序</td></tr></tbody></table><h3 id="awk指令里的BEGIN块和END块"><a href="#awk指令里的BEGIN块和END块" class="headerlink" title="awk指令里的BEGIN块和END块"></a>awk指令里的BEGIN块和END块</h3><p>用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern&#123;action&#125;=BEGIN/END&#123;action&#125;</span><br></pre></td></tr></table></figure><ul><li>BEGIN用于初始化FS变量（列分隔符），打印标题，或者初始化后需要在程序中调用的全局变量</li><li>END用于执行最后的运算或者打印最终的输出结果</li><li>END块和BEGIN不是必须的</li></ul><h3 id="awk的内置变量"><a href="#awk的内置变量" class="headerlink" title="awk的内置变量"></a>awk的内置变量</h3><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>FILENAME</td><td>文件名</td></tr><tr><td>NR</td><td>已读的记录数</td></tr><tr><td>NF</td><td>浏览记录的域的个数（即切割后列的个数）</td></tr></tbody></table><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><ul><li>搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以<code>,</code>号分割：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F : &#x27;/^root/&#123;print $1&quot;,&quot;$7&#125;&#x27; /etc/passwd #/^root/为匹配root开头的行</span><br></pre></td></tr></table></figure><p>注意：只有匹配了pattern的行才会执行action，在awk中使用正则匹配，<strong>正则表达式必须要放在<code>//</code>中</strong></p><ul><li>只显示/etc/passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名”user,shell”，在最后一行添加”The End”：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F : &#x27;BEGIN&#123;print &quot;user,shell&quot;&#125; &#123;print $1&quot;,&quot;$7&#125; END&#123;print &quot;The End.&quot;&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure><ul><li>将passwd文件中的用户id增加数值1并输出：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F : -v i=1 &#x27;&#123;print $3+i&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure><ul><li>统计passwd文件名，每行的行号，每行的列数：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F : &#x27;&#123;print FILENAME &quot;,&quot; NR &quot;,&quot; NF&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure><ul><li>切割IP</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[cuper@iZe4h75o51zvd0Z ~]$ ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.19.31  netmask 255.255.240.0  broadcast 172.16.31.255</span><br><span class="line">        inet6 fe80::216:3eff:fe12:e6ca  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:16:3e:12:e6:ca  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 9566150  bytes 4829288932 (4.4 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 10006033  bytes 4463500274 (4.1 GiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">[cuper@iZe4h75o51zvd0Z ~]$ ifconfig eth0 | grep &quot;inet &quot; | awk -F &#x27;t&#x27; &#x27;&#123;print $2&#125;&#x27; | awk -F &#x27; &#x27; &#x27;&#123;print $1&#125;&#x27;</span><br><span class="line">172.16.19.31</span><br></pre></td></tr></table></figure><ul><li>查询sed.txt中空行所在的行号：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;/^$/&#123;print NR&#125;&#x27; sed.txt #^开头，$结尾，/^$/表示空行</span><br></pre></td></tr></table></figure><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><h3 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h3><p>将文件进行排序，并将排序结果标准输出。</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort (选项) (参数)</span><br></pre></td></tr></table></figure><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>依照数值的大小排序</td></tr><tr><td>-r</td><td>以相反的顺序来排序</td></tr><tr><td>-t</td><td>设置排序时所用的分隔字符</td></tr><tr><td>-k</td><td>指定需要排序的列</td></tr></tbody></table><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>指定待排序的文件列表</p><h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><ul><li>按照<code>:</code>分割后的第三列倒序排序passwd：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -t : -nrk 3 /etc/passwd</span><br></pre></td></tr></table></figure><h1 id="面试真题"><a href="#面试真题" class="headerlink" title="面试真题"></a>面试真题</h1><h2 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h2><p>Q1.使用Linux命令查询file1中空行所在的行号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;/^$/&#123;print NR&#125;&#x27; sed.txt</span><br></pre></td></tr></table></figure><p>Q2.有文件chengji.txt内容如下:</p><p>张三 40<br>李四 50<br>王五 60</p><p>使用Linux命令计算第二列的和并输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat chengji.txt | awk -F &quot; &quot; &#x27;&#123;sum+=$2&#125; END&#123;print sum&#125;&#x27;</span><br></pre></td></tr></table></figure><h2 id="搜狐-amp-和讯网"><a href="#搜狐-amp-和讯网" class="headerlink" title="搜狐&amp;和讯网"></a>搜狐&amp;和讯网</h2><p>Q.Shell脚本里如何检查一个文件是否存在？如果不存在该如何处理？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ -f file.txt ]; then</span><br><span class="line">   echo &quot;文件存在!&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不存在!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="新浪"><a href="#新浪" class="headerlink" title="新浪"></a>新浪</h2><p>Q.用shell写一个脚本，对文本中无序的一列数字排序，并计算总和</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -n test.txt | awk &#x27;&#123;a+=$0;print $0&#125; END&#123;print &quot;SUM=&quot;a&#125;&#x27;</span><br></pre></td></tr></table></figure><h2 id="金和网络"><a href="#金和网络" class="headerlink" title="金和网络"></a>金和网络</h2><p>Q.请用shell脚本写出查找当前文件夹（/home）下所有的文本文件内容中包含有字符”shen”的文件名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r &quot;shen&quot; /home | cut -d &quot;:&quot; -f 1 #只用grep会包含&quot;:文件内容&quot;，需要cut一下</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> MOOC笔记 </tag>
            
            <tag> Shell </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习笔记——Linux相关操作</title>
      <link href="2020/12/02/Linux_note/"/>
      <url>2020/12/02/Linux_note/</url>
      
        <content type="html"><![CDATA[<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.bilibili.com/video/BV1ZW411k7Qh?p=1">B站视频：尚硅谷大数据Linux教程(大数据linux开发)</a></p><p><a href="https://blog.csdn.net/weixin_44262126/article/details/108217320">视频评论区的学习笔记</a></p><h1 id="Linux的文件目录结构"><a href="#Linux的文件目录结构" class="headerlink" title="Linux的文件目录结构"></a>Linux的文件目录结构</h1><p><strong>在Linux的世界里，一切皆文件。</strong></p><p><img src="http://img.cuper.top/bigdata20200824201738718.png" alt="20200824201738718"></p><ul><li><p><strong>/bin</strong> (/usr/bin 、/usr/local/bin)：是Binary的缩写，这个目录存放着最经常使用的命令。</p></li><li><p>/sbin (/usr/sbin 、/usr/local/sbin)：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p><strong>/home</strong> ：存放普通用户的主目录， 在linux中每个用户都有一一个自己的目录，一般该目录名是以用户的账号命名的。</p></li><li><p><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p>/lib：系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p>/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li><li><p><strong>/etc</strong>：所有的系统管理所需要的配置文件和子目录my.conf。</p></li><li><p><strong>/usr</strong>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p></li><li><p><strong>/boot</strong>：存放的是启动Linux时使用 的一些核心文件，包括一些连接文件以及镜像文件。</p></li><li><p>/proc：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。</p></li><li><p>/srv：service缩写，该目录存放一些服务启动之后需要提取的数据。</p></li><li><p>/sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统。</p></li><li><p>/tmp：这个目录是用来存放一些临时文件的。</p></li><li><p>/dev：类似于windows的设备管理器，把所有的硬件用文件的形式存储。</p></li><li><p><strong>/media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p></li><li><p><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。</p></li><li><p>/opt：这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。默认为空。</p></li><li><p><strong>/usr/local</strong>：这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。</p></li><li><p><strong>/var</strong>：这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。</p></li><li><p>/selinux [security-enhanced linux] 360：SELinux是一种安全子系统，它能控制程序只能访问特定文件。</p></li></ul><h1 id="Vi和Vim编辑器"><a href="#Vi和Vim编辑器" class="headerlink" title="Vi和Vim编辑器"></a>Vi和Vim编辑器</h1><p><img src="http://img.cuper.top/bigdata20200824202314177.png" alt="20200824202314177"></p><p>退出编辑器：</p><ul><li>:w 将缓冲区写入文件，即保存修改</li><li>:wq 保存修改并退出</li><li>:x 保存修改并退出</li><li>:q 退出，如果对缓冲区进行过修改，则会提示</li><li>:q! 强制退出，放弃修改</li></ul><p>部分常用快捷键：</p><ul><li>拷贝当前行 yy, 拷贝当前行向下的5行 5yy, 粘贴 p</li><li>删除当前行 dd , 删除当前行向下的5行 5dd</li><li>查找，命令行下 /关键字，回车查找，再输入n查找下一个</li><li>设置文件的行号 :set nu，取消文件的行号 :set nonu</li><li>使用快捷键到底文档的最末行 G， 最首行 gg</li><li>撤销 u</li><li>将光标移动到指定行 行数+shift+g</li></ul><p><a href="https://www.cnblogs.com/markleaf/p/7808817.html">更多常用快捷键</a></p><h1 id="用户与组"><a href="#用户与组" class="headerlink" title="用户与组"></a>用户与组</h1><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20201109103544.png" alt="QQ截图20201109103544"></p><ul><li>用户至少要属于一个组</li></ul><p><strong>用户和组的相关文件：</strong></p><ul><li><strong>/etc/passwd 文件</strong>——用户（user）的配置文件，记录用户的各种信息<br>每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</li><li><strong>/etc/shadow 文件</strong>——口令的配置文件<br>每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:保留</li><li><strong>/etc/group 文件</strong>——组(group)的配置文件，记录Linux包含的组的信息<br>每行的含义：组名:口令:组标识号:组内用户列表（一般是看不到的）</li></ul><h1 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h1><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20201109145201.png" alt="QQ截图20201109145201"></p><p>常用的运行级别是3和5。在主界面下的运行级别就是5，用Xshell等远程连接工具登录就是3。如果要修改默认的运行级别，可通过vim来修改/ect/inittab文件中的 id:5:initdefault: 这一行中的数字。或者直接在终端的命令行输入：init 5。</p><h1 id="找回root密码"><a href="#找回root密码" class="headerlink" title="找回root密码"></a>找回root密码</h1><p>启动时-&gt;快速输入 enter-&gt;输入 e-&gt; 进入到编辑界面-&gt; 选择中间有 kernel 项-&gt;输入 e(edit)-&gt; 在该行的最后写入 1 [表示修改内核，临时生效]-&gt; 输入 enter-&gt;输入 b [boot]-&gt; 进入到单用模式，即可直接设置root新密码。</p><blockquote><p>前提：必须在操作系统所在电脑中操作，远程登陆不行。</p></blockquote><h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><h3 id="man-命令或者配置文件"><a href="#man-命令或者配置文件" class="headerlink" title="man [命令或者配置文件]"></a>man [命令或者配置文件]</h3><h3 id="help-命令"><a href="#help-命令" class="headerlink" title="help [命令]"></a>help [命令]</h3><h2 id="文件目录类指令"><a href="#文件目录类指令" class="headerlink" title="文件目录类指令"></a>文件目录类指令</h2><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>该命令行的意思就是print working directory，显示当前工作目录的绝对路径。</p><h3 id="ls-选项-显示当前目录下的文件和目录"><a href="#ls-选项-显示当前目录下的文件和目录" class="headerlink" title="ls [选项] 显示当前目录下的文件和目录"></a>ls [选项] 显示当前目录下的文件和目录</h3><p><strong>选项：</strong></p><ul><li>-a ：显示当前目录所有的文件和目录，包括隐藏的 (文件名以.开头就是隐藏，默认是不显示的)</li><li>-l ： 以列表的方式显示信息</li><li>-h ： 显示文件大小时，以 k , m, G 单位显示</li></ul><h3 id="touch-文件名-文件名-……"><a href="#touch-文件名-文件名-……" class="headerlink" title="touch [文件名] [文件名] ……"></a>touch [文件名] [文件名] ……</h3><p>创建一个或者多个空文件，如果文件存在，则刷新文件的修改时间</p><h3 id="rm-rf-空目录或者非空目录"><a href="#rm-rf-空目录或者非空目录" class="headerlink" title="rm -rf [空目录或者非空目录]"></a>rm -rf [空目录或者非空目录]</h3><p>删除空或者非空目录，其中选项r表示文件与子目录全部删除，f表示全部删除，不需要询问</p><h3 id="cat-选项-n表示显示行号-要查看的文件"><a href="#cat-选项-n表示显示行号-要查看的文件" class="headerlink" title="cat [选项 -n表示显示行号] 要查看的文件"></a>cat [选项 -n表示显示行号] 要查看的文件</h3><p>以只读形式打开文件</p><p>为浏览方便，带上管道命令<code>| more</code>：</p><p><strong>说明：</strong><br>如果需要一行行，输入 enter；<br>如果需要翻页，输入空格键；<br>如果需要退出，输入 q。</p><h3 id="more-文件名"><a href="#more-文件名" class="headerlink" title="more [文件名]"></a>more [文件名]</h3><p>基于vi编辑器的文本过滤器，以全屏幕的方式按页显示文本文件的内容。</p><p><strong>说明：</strong><br>空格键 代表向下翻一页；<br>enter 代表向下翻一行；<br>q 代表立刻离开 more ，不再显示该文件内容；<br>ctrl+F 表示向下滚动一屏；<br>ctrl+B 表示返回上一屏；<br>= 输出当前行的行号；<br>:f 输出文件名和当前行的行号</p><h3 id="less-文件名"><a href="#less-文件名" class="headerlink" title="less [文件名]"></a>less [文件名]</h3><p>和more的功能类似，但不是一次性将整个文件加载进来再显示，而是根据需要再显示，看大型的日志文件一般推荐less。</p><p><strong>说明：</strong><br>空格键、[pagedown] 代表向下翻一页；<br>[pageup] 代表向上翻一页；<br>enter 代表向下翻一行；<br>/[字符串] 代表向下搜寻[字符串] n:向下查找 N:向上查找；<br>?[字符串] 代表向上搜寻[字符串] n:向上查找 N:向下查找；<br>q 离开less这个程序；</p><h3 id="gt-与-gt-gt"><a href="#gt-与-gt-gt" class="headerlink" title="&gt;与&gt;&gt;"></a>&gt;与&gt;&gt;</h3><p>&gt;：输出重定向指令 （会将原来的文件的内容跟覆盖）</p><p>&gt;&gt; ：追加指令 （不会覆盖原来文件的内容，而是追加到文件的尾部）</p><p><code>[命令] &gt;/&gt;&gt; 文件</code>：就是把前面指令在终端里显示的内容写入到后面的文件中，若文件名不存在则创建该文件。</p><p><strong>示例：</strong></p><ul><li>ls -l &gt;sharm.txt （功能描述：列表的内容写入文件sharm.txt中（覆盖写））</li><li>ls -l &gt;&gt;sharm.txt （功能描述：列表的内容追加到文件sharm.txt的末尾）</li></ul><h3 id="echo-PATH"><a href="#echo-PATH" class="headerlink" title="echo $PATH"></a>echo $PATH</h3><p>输出当前的环境变量</p><h3 id="head-n-行数-文件"><a href="#head-n-行数-文件" class="headerlink" title="head [-n 行数] [文件]"></a>head [-n 行数] [文件]</h3><p>用于显示文件的开头部分内容，默认情况显示文件的前10行内容</p><h3 id="tail-n-行数-文件"><a href="#tail-n-行数-文件" class="headerlink" title="tail [-n 行数] [文件]"></a>tail [-n 行数] [文件]</h3><p>用于输出文件中尾部的内容，默认情况显示文件的后10行内容</p><ul><li>tail -f 文件（功能描述：实时追踪该文档的所有更新，命令需要一直运行着，<strong>工作经常用</strong>）</li></ul><h3 id="ln-s-原文件或目录-软链接名"><a href="#ln-s-原文件或目录-软链接名" class="headerlink" title="ln -s [原文件或目录] [软链接名]"></a>ln -s [原文件或目录] [软链接名]</h3><p>给原文件创建一个软链接，软链接也成为符号链接，类似于windows 里的快捷方式，主要存放了链接其他文件的路径，当使用<code>pwd</code>查看目录时，仍然看到的是软链接所在目录。</p><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>查看已经执行过得历史命令，也可以执行历史命令</p><p><code>history 个数n</code>：显示最近使用过的n个指令</p><p><code>!编号</code>：在已经输入history的前提下，执行对应历史编号的指令</p><h2 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h2><h3 id="find-搜索范围-选项-文件"><a href="#find-搜索范围-选项-文件" class="headerlink" title="find [搜索范围] [选项] [文件]"></a>find [搜索范围] [选项] [文件]</h3><p>find指令是将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。</p><p><img src="http://img.cuper.top/bigdata20200825100316937.png" alt="20200825100316937"></p><ul><li>-size +n大于/-n小于/n等于</li></ul><h3 id="locate-文件名"><a href="#locate-文件名" class="headerlink" title="locate [文件名]"></a>locate [文件名]</h3><p>locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。由于locate指令基于数据库进行查询，所以第一次运行前，必须使用<code>updatedb</code>指令创建locate数据库。</p><h3 id="grep-与管道符“-”"><a href="#grep-与管道符“-”" class="headerlink" title="grep 与管道符“|”"></a>grep 与管道符“|”</h3><p>grep：过滤查找，<code>grep [选项] 查找内容 源文件</code></p><p><strong>grep的选项：</strong><br>-n 显示匹配行及行号；<br>-i 忽略字母大小写；</p><p>|：将前一命令的结果传到后一命令上</p><p><strong>示例：</strong></p><ul><li>grep -n if /home/hello.txt</li><li>cat /home/hello.txt |grep -n if </li><li>两者的作用相同，均是在hello.txt文件中找到if的行号，就像英文中的主动与被动语法</li></ul><h2 id="压缩和解压类"><a href="#压缩和解压类" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h2><h3 id="gzip与gunzip（会删除原文件）"><a href="#gzip与gunzip（会删除原文件）" class="headerlink" title="gzip与gunzip（会删除原文件）"></a>gzip与gunzip（会删除原文件）</h3><p>gzip为压缩文件命令，只能将文件压缩为*.gz文件(不能压缩文件夹)</p><p>gunzip为解压文件命令</p><h3 id="zip与unzip"><a href="#zip与unzip" class="headerlink" title="zip与unzip"></a>zip与unzip</h3><p>可以压缩/解压缩文件&amp;文件夹</p><p><code>zip [选项] xxx.zip 待压缩的内容</code></p><p><strong>选项：</strong></p><p>-r 递归压缩，即压缩目录</p><p><code>unzip [选项] 解压后存放的目录 xxx.zip </code></p><p><strong>选项：</strong></p><p>-d 指定压缩后文件的存放目录</p><p><strong>示例：</strong></p><ul><li>zip -r nn.zip /home/temp/ 将/home目录下的temp文件夹压缩成名为nn.zip的文件，同时保留原文件，注意，要写全，如/home/temp/</li><li>unzip -d /home/haha nn.zip 将nn.zip文件解压到/home/haha中，如果没有该目录，则自动创建该目录</li></ul><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>tar是打包指令，最后打包后的文件是 .tar.gz 的文件。该命令可以压缩，也可以解压缩</p><p><img src="http://img.cuper.top/bigdata2020082510084565.png" alt="2020082510084565"></p><p><strong>示例：</strong></p><ul><li>tar <strong>-zcvf</strong> a.tar.gz haha.txt mimi.txt 将haha.txt和mimi.txt合并打包为a.tar.gz文件</li><li>tar <strong>-zcvf</strong> myhome.tar.gz /home/ 将/home文件夹下的所有东西打包成一个myhome.tar.gz文件</li><li>tar <strong>-zxvf</strong> a.tar.gz 将z.tar.gz压缩文件解压到该原目录下</li><li>tar <strong>-zxvf</strong> a.tar.gz <strong>-C</strong> /opt/tmp 将a.tar.gz压缩文件解压到/opt/tmp文件夹下，该文件夹需要事先创建</li></ul><h1 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h1><p>每个文件的权限概念：</p><ul><li>所有者</li><li>所在组</li><li>其他组</li></ul><p><strong>修改文件所有者：</strong><code>chown 用户名 文件名</code></p><p><strong>修改文件所在组：</strong><code>chgrp 组名 文件名</code></p><p><strong>同时修改所有者和所在组：</strong><code>chown 用户名:组名 文件名</code></p><p>参数<code>-R</code>：对目录使其下所有子文件或目录递归生效</p><p><code>ls -alh</code>查看文件信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxrw-r-- 1 root police 1213 Feb 2 09:39 abc.txt</span><br></pre></td></tr></table></figure><ul><li>第0位确定文件类型，其中-:普通文件；d:目录；l:连接文件；c:字符设备文件[键盘,鼠标]；b:块设备文件[硬盘]</li><li>第1-3位确定所有者（该文件的所有者）拥有该文件的权限（r:读权限;w:写权限；x:执行权限）</li><li>第4-6位确定所属组（同用户组的）拥有该文件的权限</li><li>第7-9位确定其他用户拥有该文件的权限</li><li>1:如果是文件，表示硬链接的数目（一般都是1）；如果是目录，则表示有多少个子目录</li><li>root表示所有者名称</li><li>police表示所属组名称</li><li>1213：表示文件存储的大小，如果是目录，则统一为<strong>4096</strong></li><li>Feb 2 09:39表示文件最后的修改时间</li></ul><p><strong>rwx权限详情</strong></p><ul><li><p>rwx作用到文件</p><ul><li>[r]代表可读(read):可以读取,查看</li><li>[w]代表可写(write):可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件</li><li>[x]代表可执行(execute):可以被执行</li></ul></li><li><p>rwx作用到目录</p><ul><li>[r]代表可读(read):可以读取，ls查看目录内容</li><li>[w]代表可写(write):可以修改,目录内创建+删除+重命名目录</li><li>[x]代表可执行(execute):可以进入该目录</li></ul></li></ul><p><strong>修改文件权限：</strong><code>chmod</code></p><ul><li><p>通过+、-、=变更权限（**u:所有者　g:所有组　o:其他人　a:所有人(u,g,o的总和)**）</p><ul><li><code>chmod u=rwx,g=rx,o=x 文件/目录</code> ：给所有者rwx, 给所在组的用户rx, 给其他人x</li><li><code>chmod o+w 文件/目录</code> ：给其它用户增加w的权限</li><li><code>chmod a-x文件/目录</code>：表示：给所有用户去掉x权限</li></ul></li><li><p>通过数字变更权限（<strong>r=4 w=2 x=1 rwx=4+2+1=7</strong>）</p><ul><li><code>chmod u=rwx,g=rx,o=x 文件/目录</code>&amp;<code>chmod 751 文件/目录</code> 两者的功能是相同的</li></ul></li></ul><h1 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h1><p>需要自动执行某一个脚本（代码）：需要任务调度</p><p><strong>任务调度的两种方式：</strong><br>1）直接通过命令行来调度<br>2）通过调用脚本来调度<br>本质上两者是相同的，只不过当内容太多时，放在脚本中比较方便。</p><p>命令：<code>crontab [选项]</code></p><p>参数：</p><ul><li>-e 编辑crontab定时任务</li><li>-l 查询crontab任务</li><li>-r 删除当前用户所有的crontab任务</li></ul><p>调度任务格式：<code>占位符(可含参数)+待执行命令</code></p><p>5个占位符说明（记得每个占位符之间要空格）：</p><p><img src="http://img.cuper.top/QQ%E6%88%AA%E5%9B%BE20201208023744.png" alt="QQ截图20201208023744"></p><p>特殊符号作为参数：</p><ul><li>星号 * ：代表任何时间。比如第一个“*”代表一小时中每分钟都执行一次的意思。</li><li>逗号，：代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令。</li><li>杠号 - ：代表连续的时间范围。比如“0 5 * * 1-6命令”，代表在周一到周六的凌晨5点0分执行命令。</li><li>*/n： 代表每隔多久执行一次。比如“*/10 * * * * 命令”，代表每隔10分钟就执行一遍命令。</li></ul><blockquote><p>注意：星期几和几号最好不要同时出现，因为它们定义的都是天，非常容易让管理员混乱。</p></blockquote><p><code>service crond restart</code>：重启任务调度</p><h1 id="磁盘分区与挂载"><a href="#磁盘分区与挂载" class="headerlink" title="磁盘分区与挂载"></a>磁盘分区与挂载</h1><h2 id="分区的方式"><a href="#分区的方式" class="headerlink" title="分区的方式"></a>分区的方式</h2><h3 id="mbr分区："><a href="#mbr分区：" class="headerlink" title="mbr分区："></a>mbr分区：</h3><ul><li>最多支持四个主分区</li><li>系统只能安装在主分区</li><li>扩展分区要占一个主分区</li><li>MBR最大只支持2TB，但拥有最好的兼容性</li></ul><h3 id="gpt分区（✔）："><a href="#gpt分区（✔）：" class="headerlink" title="gpt分区（✔）："></a>gpt分区（✔）：</h3><ul><li>支持无限多个主分区（但操作系统可能限制，比如windows下最多128个分区）</li><li>最大支持18EB的大容量（1EB=1024PB，1PB=1024TB）</li><li>windows7 64位以后支持gtp</li></ul><h2 id="Linux与Windows分区的区别"><a href="#Linux与Windows分区的区别" class="headerlink" title="Linux与Windows分区的区别"></a>Linux与Windows分区的区别</h2><p>Windows：</p><p><img src="https://img-blog.csdnimg.cn/20200825102707751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI2MjEyNg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p>Linux：</p><ul><li>对Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分。</li><li>Linux采用了一种叫“载入(mount)”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</li></ul><h2 id="Linux下磁盘的说明"><a href="#Linux下磁盘的说明" class="headerlink" title="Linux下磁盘的说明"></a>Linux下磁盘的说明</h2><p>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘。</p><ul><li>对于IDE硬盘，驱动器标识符为“hdx”,其中“hd”表明分区所在设备的类型，这里是指IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）,“~”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例：hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区，hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区。</li><li>对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样。sdb1 [表示第2块scsi 硬盘的第1个分区]</li></ul><p>列出所有可用块设备的信息并且显示它们之间的依赖关系的指令：<code>lsblk -f</code></p><blockquote><p>记：老师不离开</p></blockquote><p>硬盘分区：<code>fdisk /dev/sdb</code><br>选项：<br>m 显示命令列表<br>p 显示磁盘分区 同 fdisk –l<br>n 新增分区<br>d 删除分区<br>w 写入并退出<br>（示例说明：开始分区后输入n，新增分区，然后选择p，分区类型为主分区。两次回车默认剩余全部空间。最后输入w写入分区并退出，若不保存退出输入q）</p><p>格式化分区：<code>mdfs -t ext4 /dev/sdb1</code> [把 /dev/sdb1 分区格式化为ext4这种类型]</p><p>挂载：<code>mount /dev/sdb1 /home/newdisk</code> [注：挂载时(包括卸载umount时)，当前目录不要在/home/newdisk ]</p><p>实现永久挂载，需要配置Linux的分区表，实现启动时，自动挂载：<code>vim /etc/fstab</code>，加入一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dev&#x2F;sdb1&#x2F;home&#x2F;newdiskext4defaults0 0</span><br></pre></td></tr></table></figure><p>添加后执行<code>mount -a</code>立即生效。</p><p>查询系统整体磁盘使用情况：<code>df -h</code></p><p>查询指定目录的磁盘占用情况（默认为当前目录）：<code>du -h 目录</code><br>其他参数：<br>-s 指定目录占用大小汇总<br>-h 带计量单位<br>-a 含文件<br>–max-depth=1 子目录深度<br>-c 列出明细的同时，增加汇总值</p><p>实例：</p><p>统计/home 文件夹下文件的个数：<code>ls –l /home/ | grep “^-” | wc -l</code><br>统计/home 文件夹下目录的个数：<code>ls –l /home/ | grep “^d” | wc -l</code><br>统计/home 文件夹下文件的个数，包括子文件夹里的：<code>ls –lR /home/ | grep “^-” | wc -l</code><br>统计/home 文件夹下目录的个数，包括子文件夹里的：<code>ls –lR /home/ | grep “^d” | wc -l</code><br>以树状显示目录结构：<code>tree</code></p><h1 id="Linux网络配置"><a href="#Linux网络配置" class="headerlink" title="Linux网络配置"></a>Linux网络配置</h1><h2 id="配置固定的IP地址"><a href="#配置固定的IP地址" class="headerlink" title="配置固定的IP地址"></a>配置固定的IP地址</h2><p><code>vim /etc/sysconfig/network-scripts/ifcfg-eth0</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTO=static <span class="comment">#以静态方式获取ip</span></span><br><span class="line">IPADDR=192.168.184.130 <span class="comment">#设置ip地址</span></span><br><span class="line">GATEWAY=192.168.184.2 <span class="comment">#网关</span></span><br><span class="line">DNS1=192.168.184.2 <span class="comment">#DNS和网关保持一致即可</span></span><br></pre></td></tr></table></figure><p>保存后重启网络生效：<code>service network restart</code></p><h2 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h2><p>查看当前主机名：<code>hostname</code></p><p>修改Linux主机名：<code>vim /etc/hostname</code>，在文件里直接写入名字</p><p>添加ip与主机的映射：<code>vim /etc/hosts</code>，加入一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip地址主机名</span><br></pre></td></tr></table></figure><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li>在Linux中，每个执行的程序（代码）都称为一个进程，每一个进程都分配一个ID号。</li><li>每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。</li><li>每个进程都可能以两种方式存在的：前台与后台。所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</li><li>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才才结束。</li></ol><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><p><code>ps -aux</code>：<br>-a: 显示当前终端的所有进程信息<br>-u: 以用户的格式显示进程信息<br>-x: 显示后台进程运行的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">USER:用户名</span><br><span class="line">PID:进程ID</span><br><span class="line">%CPU:占用CPU的百分比</span><br><span class="line">%MEM:占用物理内存的百分比</span><br><span class="line">VSZ:占用的虚拟内存大小(KB)</span><br><span class="line">RSS:占用的物理内存大小(KB)</span><br><span class="line">TTY:使用终端</span><br><span class="line">STAT:进程的状态（S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等）</span><br><span class="line">START:进程的启动时间</span><br><span class="line">TIME:进程使用CPU的总时间</span><br><span class="line">COMMAND:启动进程所用的命令和参数，如果过长会被截断显示，或者命令ps -ef 以全格式显示当前所有的进程</span><br></pre></td></tr></table></figure><p>查找是否有某个进程：<code>ps -aux | grep xxx</code></p><p>以全格式显示当前所有的进程：<code>ps -ef </code>（PPID可查看父进程；C为CPU用于计算执行优先级的因子，数值越大表明进程是CPU密集型运算，优先级降低，数值越小表明进程是I/O密集型运算，优先级提高）</p><h2 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h2><p><code>kill [选项] 进程号</code>：通过进程号杀死进程，常用选项：<code>-9</code>，表示强制终止</p><p><code>killall 进程名称</code>：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用</p><h2 id="进程树"><a href="#进程树" class="headerlink" title="进程树"></a>进程树</h2><p><code>pstree</code>：以树状图的形式来显示进程</p><p>选项：<br>-p :显示进程的PID<br>-u :显示进程的所属用户</p><h2 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h2><p>服务(service)本质就是进程，但是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql,sshd,防火墙等)，因此又称为守护进程。</p><p><strong>service管理指令：</strong><code>systemctl 服务名 [start|stop|restart|reload|status]</code></p><p>监听某个端口是否在运行中：<code>telnet ip [端口]</code></p><h2 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名"></a>查看服务名</h2><p>方式1：<code>setup</code>进入系统服务<br>方式2：<code>ls -l /etc/init.d/</code>列出服务列表</p><h2 id="运行级别-1"><a href="#运行级别-1" class="headerlink" title="运行级别"></a>运行级别</h2><p>查看或者修改默认级别： vim /etc/inittab<br>Linux系统有7种运行级别(runlevel)：常用的是级别3和5</p><ul><li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li><li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆</li><li>运行级别2：多用户状态(没有NFS)，不支持网络</li><li>运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式</li><li>运行级别4：系统未使用，保留</li><li>运行级别5：X11控制台，登陆后进入图形GUI模式</li><li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li></ul><h2 id="服务自启动"><a href="#服务自启动" class="headerlink" title="服务自启动"></a>服务自启动</h2><p>查看服务：<code>chkconfig --list | grep xxx</code>（用grep筛选想要的）</p><p>通过服务名查看：<code>chkconfig xxx --list</code></p><p>修改服务在某个级别下自启动：<code>chkconfig --level 5 xxx on/off</code></p><p>若要在所有级别下都修改某个服务的自启动，不加level这个词：<code>chkconfig xxx on/off</code></p><p><em>设计好之后，一定要<code>reboot</code>。</em></p><h2 id="监控服务"><a href="#监控服务" class="headerlink" title="监控服务"></a>监控服务</h2><p><code>top</code>：</p><p>选项：<br><code>-d 秒数</code>：指定top命令每隔几秒更新，默认是3秒。<br><code>-i</code>：使top不显示任何闲置或者僵死进程。<br><code>-p</code>：通过指定监控进程ID来仅仅监控某个进程的状态。</p><p><img src="https://img-blog.csdnimg.cn/20200825105051550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI2MjEyNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>进入交互式模式后的操作：<br><code>P</code>：以CPU使用率排序，默认为此<br><code>M</code>：以内存的使用率排序<br><code>N</code>：以PID排序<br><code>q</code>：退出top<br><code>u</code>：再输入用户名，监视特定用户<br><code>k</code>：再输入进程ID号，终止指定的进程</p><h2 id="监控网络服务"><a href="#监控网络服务" class="headerlink" title="监控网络服务"></a>监控网络服务</h2><p><code>netstat</code>：</p><p>选项：<br>-an 按一定顺序排列输出<br>-p 显示哪个进程在调用</p><h1 id="RPM包-amp-YUM管理"><a href="#RPM包-amp-YUM管理" class="headerlink" title="RPM包&amp;YUM管理"></a>RPM包&amp;YUM管理</h1><h2 id="RPM包"><a href="#RPM包" class="headerlink" title="RPM包"></a>RPM包</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>一种用于互联网下载包的打包及安装工具，包含在某些Linux 分发版中，生成具有.RPM 扩展名的文件。RPM是RedHat Package Manage（r RedHat软件包管理工具）的缩写，类似windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。Linux的分发版本（suse,redhat,centos等等）都有采用，可以算是公认的行业标准了。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul><li><code>rpm -qa</code> 查询所安装的所有rpm软件包</li><li><code>rpm -qa | grep xxx</code> 查询具体某一个软件包</li><li><code>rpm -q 软件包名</code> 查询该软件包是否安装</li><li><code>rpm -qi 软件包名</code> 查询该软件包的信息</li><li><code>rpm -ql 软件包名</code> 查询该软件安装后形成了哪些文件，这些文件放在哪些文件</li><li><code>rpm -qf 文件全路径名</code> 查询某个文件属于哪个rpm包</li></ul><h3 id="RPM包名称基本格式"><a href="#RPM包名称基本格式" class="headerlink" title="RPM包名称基本格式"></a>RPM包名称基本格式</h3><p>一个rpm包名：firefox-45.0.1-1.el6.centos.x86_64.rpm</p><ul><li>名称：firefox</li><li>版本号：45.0.1-1</li><li>适用操作系统：el6.centos.x86_64，表示centos6.x的64位系统，如果是i686、i386表示32位系统，<strong>noarch表示通用</strong></li></ul><h3 id="卸载软件包"><a href="#卸载软件包" class="headerlink" title="卸载软件包"></a>卸载软件包</h3><ul><li><code>rpm -e 软件包名</code> 卸载软件包</li><li><code>rpm -e --nodeps 软件包名</code> 强制删除</li></ul><h3 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h3><p><code>rpm -ivh RPM包全路径名称</code></p><p>参数说明：</p><ul><li>i=install 安装 </li><li>v=verbose 提示 </li><li>h=hash 进度条</li></ul><h2 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h2><p>yum是一个Shell软件包管理器，基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。</p><p><strong>yum的基本指令:</strong></p><ul><li><code>yum list|grep xx软件列表</code> 查询yum服务器是否有需要安装的软件</li><li><code>yum install xxx</code> 安装指定的yum包（默认会安装最新版本的软件）</li></ul><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ul><li><p>写出6个Linux常用命令：<code>netstat</code>, <code>top</code>, <code>lsblk</code>, <code>find</code>, <code>ps</code>, <code>chkconfig</code></p></li><li><p>查看内存：<code>top</code></p></li><li><p>磁盘存储：<code>df -lh</code></p></li><li><p>IO读写：<code>iotop</code></p></li><li><p>端口占用：<code>netstat -tunlp</code></p></li><li><p>进程：<code>ps -aux | grep xxx</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> MOOC笔记 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大数据技术原理与应用》学习笔记——Ch4：分布式数据库HBase</title>
      <link href="2020/11/01/BigData_Ch4_HBase/"/>
      <url>2020/11/01/BigData_Ch4_HBase/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>本文为<a href="https://www.icourse163.org/course/XMU-1002335004?tid=1450180443">《大数据技术原理与应用》</a>第四章学习笔记。</p><p>HBase安装和编程<a href="http://dblab.xmu.edu.cn/blog/2442-2/">实践指南</a></p><h1 id="HBase简介"><a href="#HBase简介" class="headerlink" title="HBase简介"></a>HBase简介</h1><p><strong>HBase是一个高可靠、高性能、面向列、可伸缩的分布式数据库，</strong>是<em>BigTable</em>的一个<em>开源实现</em>，主要用来存储非结构化和半结构化的松散数据。</p><p><img src="http://img.cuper.top/wirelessQQ%E6%88%AA%E5%9B%BE20201020104703.png" alt="QQ截图20201020104703"></p><h3 id="HBase和BigTable的底层技术对应关系："><a href="#HBase和BigTable的底层技术对应关系：" class="headerlink" title="HBase和BigTable的底层技术对应关系："></a>HBase和BigTable的底层技术对应关系：</h3><table><thead><tr><th></th><th>BigTable</th><th>HBase</th></tr></thead><tbody><tr><td>文件存储系统</td><td>GFS</td><td>HDFS</td></tr><tr><td>海量数据处理</td><td>MapReduce</td><td>Hadoop MapReduce</td></tr><tr><td>协同服务管理</td><td>Chubby</td><td>Zookeeper</td></tr></tbody></table><h3 id="在已有Hadoop和HDFS的情况下为什么需要HBase："><a href="#在已有Hadoop和HDFS的情况下为什么需要HBase：" class="headerlink" title="在已有Hadoop和HDFS的情况下为什么需要HBase："></a>在已有Hadoop和HDFS的情况下为什么需要HBase：</h3><ul><li>Hadoop无法满足大规模数据实时处理应用的需求</li><li>HDFS面向批量访问模式，不是随机访问模式</li><li>传统的通用关系型数据库无法应对在数据规模剧增时导致的系统扩展性和性能问题（分库分表也不能很好解决）</li><li>传统关系数据库在数据结构变化时一般需要停机维护</li><li>空列浪费存储空间</li></ul><h3 id="HBase与传统关系数据库的对比分析"><a href="#HBase与传统关系数据库的对比分析" class="headerlink" title="HBase与传统关系数据库的对比分析"></a>HBase与传统关系数据库的对比分析</h3><table><thead><tr><th></th><th>HBase</th><th>关系型数据库</th></tr></thead><tbody><tr><td>数据类型</td><td>采用了更加简单的数据模型，它把数据存储为未经解释的字符串</td><td>采用关系模型，具有丰富的数据类型和存储方式</td></tr><tr><td>数据操作</td><td>不存在复杂的表与表之间的关系，只有简单的插入、查询、删除、清空等</td><td>包含了丰富的操作，其中会涉及复杂的多表连接</td></tr><tr><td>存储模式</td><td>基于列存储的，每个列族都由几个文件保存，不同列族的文件是分离的，可降低I/O开销</td><td>基于行模式存储的</td></tr><tr><td>数据索引</td><td>只有一个索引：行键，所有访问均通过行键访问或扫描</td><td>针对不同列构建复杂的多个索引，以提高数据访问性能</td></tr><tr><td>数据维护</td><td>执行更新操作时生成一个新的版本，旧有的版本仍然保留</td><td>更新操作会用最新的当前值去替换记录中原来的旧值，旧值被覆盖后就不会存在</td></tr><tr><td>可伸缩性</td><td>分布式集群扩展灵活，能够轻易地通过在集群中增加或者减少硬件数量来实现性能的伸缩</td><td>很难实现横向扩展，纵向扩展的空间也比较有限。</td></tr></tbody></table><h3 id="HBase访问接口"><a href="#HBase访问接口" class="headerlink" title="HBase访问接口"></a>HBase访问接口</h3><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20201020122830.png" alt="QQ截图20201020122830"></p><h1 id="HBase数据模型"><a href="#HBase数据模型" class="headerlink" title="HBase数据模型"></a>HBase数据模型</h1><h2 id="数据模型概述"><a href="#数据模型概述" class="headerlink" title="数据模型概述"></a>数据模型概述</h2><ul><li>HBase是一个稀疏、多维度、排序的映射表</li><li>四个索引：行键、列族、列限定符和时间戳</li><li>每个值是一个未经解释的<strong>字符串</strong>，没有数据类型</li><li>每一行都有一个可排序的行键和<strong>任意多</strong>的列</li><li>表在水平方向由一个或者多个列族组成，一个列族中可以包含<strong>任意多</strong>个列，同一 个列族里面的数据存储在一起</li><li>列族支持动态扩展，可以很轻松地添加一个列族或列，无需预先定义列的数量以及类型，所有列均以字符串形式存储，用户需要自行进行数据类型转换</li></ul><p><em>为什么说HBase是稀疏的：</em>同一张表里的每一行数据都可以有截然不同的列，对于整个映射表来说有些列的值就是空的。</p><ul><li>HBase中执行更新操作时，生成一个新的版本，旧有的版本仍然保留（因为HDFS<strong>只允许追加</strong>不允许修改）</li></ul><h2 id="数据模型相关概念"><a href="#数据模型相关概念" class="headerlink" title="数据模型相关概念"></a>数据模型相关概念</h2><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>HBase采用表来组织数据，表由行和列组成，列划分为若干个列族</p><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>每个HBase表都由若干行组成，每个行由行键（row key）来标识</p><h3 id="列族"><a href="#列族" class="headerlink" title="列族"></a>列族</h3><p>一个HBase表被分组成许多“列族” （Column Family）的集合，它是<strong>基本的访问控制单元</strong>。</p><ul><li>不同的列族会存到不同的文件中去</li><li>需要在表创建时定义好（由于HBase本身的缺陷最多只限于几十个）</li><li>同一个列族中的数据通常都属于同一种数据类型</li><li>数据表中每个列都属于某个列族，列名都以列族为前缀：<code>列族:列名</code></li><li>支持权限控制和配置访问模式</li></ul><h3 id="列限定符（列）"><a href="#列限定符（列）" class="headerlink" title="列限定符（列）"></a>列限定符（列）</h3><p>列族里的数据通过列限定符（列）来定位，动态增减。数据类型始终为<code>byte[]</code>。</p><h3 id="单元格"><a href="#单元格" class="headerlink" title="单元格"></a>单元格</h3><ul><li><p>具体存储数据的地方，存储的都是未经解释的字符串。</p></li><li><p>在HBase表中，通过行、列族和列确定一个“单元格”（cell）。</p></li><li><p>数据类型始终为<code>byte[]</code>。</p></li><li><p>每个单元格中可以保存一个数据的多个版本，每个版本对应一个不同的时间戳。</p></li></ul><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><ul><li><p>每个单元格都保存着同一份数据的多个版本，这些版本采用时间戳进行索引。</p></li><li><p>每次对单元格进行操作时HBase都会隐式地生成并存储一个时间戳。</p></li><li><p>一个单元格里不同版本根据时间戳降序存储，最新版本可被最先读取。</p></li></ul><p>HBase数据模型实例：</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20201020153345.png" alt="QQ截图20201020153345"></p><h2 id="数据坐标"><a href="#数据坐标" class="headerlink" title="数据坐标"></a>数据坐标</h2><p>HBase对数据的定位：四维坐标——[行键, 列族, 列限定符, 时间戳]</p><p><em>键值数据库</em></p><h2 id="概念视图与物理视图"><a href="#概念视图与物理视图" class="headerlink" title="概念视图与物理视图"></a>概念视图与物理视图</h2><h3 id="概念视图"><a href="#概念视图" class="headerlink" title="概念视图"></a>概念视图</h3><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20201020154833.png" alt="QQ截图20201020154833"></p><h3 id="物理视图"><a href="#物理视图" class="headerlink" title="物理视图"></a>物理视图</h3><p>同一列族的数据保存在一起</p><p><img src="http://img.cuper.top/bigdataQQ%E5%9B%BE%E7%89%8720201020154857.jpg" alt="QQ图片20201020154857"></p><h2 id="面向列的存储"><a href="#面向列的存储" class="headerlink" title="面向列的存储"></a>面向列的存储</h2><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20201020155305.png" alt="QQ截图20201020155305"></p><ul><li>列式数据库采用DSM（decomposition storage model）存储模型</li></ul><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20201020155605.png" alt="QQ截图20201020155605"></p><h1 id="HBase的实现原理"><a href="#HBase的实现原理" class="headerlink" title="HBase的实现原理"></a>HBase的实现原理</h1><h2 id="HBase功能组件"><a href="#HBase功能组件" class="headerlink" title="HBase功能组件"></a>HBase功能组件</h2><p>3个主要的功能组件： </p><ul><li>库函数：链接到每个客户端，客户端能利用库函数访问HBase数据库</li><li>一个Master主服务器：管家作用<ul><li>负责管理和维护HBase表的分区信息</li><li>维护Region服务器列表</li><li>分配Region</li><li>负载平衡</li><li>处理模式变化（表和列族的创建等）</li></ul></li><li>许多个Region服务器：负责存储和维护分配给自己的Region，处理来自客户端的读写请求</li></ul><blockquote><ul><li>客户端并不是直接从Master主服务器上读取数据，而是在获得Region的存储位置信息后，直接从Region服务器上读取数据。</li><li>客户端并不依赖Master，而是通过Zookeeper来获得Region位置信息，大多数客户端甚至<strong>从来不和Master通信</strong>，这种设计方式使得Master负载很小</li></ul></blockquote><h2 id="表和Region"><a href="#表和Region" class="headerlink" title="表和Region"></a>表和Region</h2><p>根据行键的值对表中的行进行分区，每个行区间构成一个分区（Region）：</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20201021203810.png" alt="QQ截图20201021203810"></p><ul><li>开始只有一个Region，当Region中的行数达到一个阈值时开始分裂成两个表，随后不断分裂，一个Region会分裂成多个新的Region：</li></ul><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20201022103805.png" alt="QQ截图20201022103805"></p><ul><li>Region拆分操作非常快，接近瞬间，因为拆分之后的Region读取的仍然是原存储文件（<strong>只是修改了指向信息</strong>），直到“合并”过程把存储文件异步地写到独立的文件之后，才会读取新文件</li><li>目前每个Region最佳大小建议1GB-2GB（实际大小取决于单台服务器的有效处理能力）</li><li>Master主服务器会把不同的Region分配到不同的Region服务器上，但拆分过程中同一个Region不会被拆到多个Region服务器</li><li>每个Region服务器管理一个Region集合，大概存储10-1000个Region</li></ul><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20201022164117.png" alt="QQ截图20201022164117"></p><h2 id="Region的定位"><a href="#Region的定位" class="headerlink" title="Region的定位"></a>Region的定位</h2><ul><li><p>元数据表（.META.表）：存储了Region（Region标识符，“表名+开始主键+RegionID”）和Region服务器的映射关系。当HBase表很大时， .META.表也会被分裂成多个Region。</p></li><li><p>根数据表（-ROOT-表）：记录所有元数据的具体位置（.META.表的分裂信息），只有唯一一个Region（不可分割），名字是在程序中被写死的</p></li><li><p>Zookeeper文件：记录了-ROOT-表的位置</p></li></ul><p>HBase的三层结构（三级寻址过程）（类似B+树）：</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20201022170454.png" alt="QQ截图20201022170454"></p><p>.META.表的全部Region都会被保存在内存中，三层结构可以保存的用户数据表的Region数目的计算方法是：</p><ul><li><p>（-ROOT-表能够寻址的.META.表的Region个数）×（每个.META.表的Region可以寻址的用户数据表的Region个数）</p></li><li><p>其中每个表中的Region个数=每个Region的限制容量/每行（一个映射条目）在内存中占用的大小</p></li></ul><p><em>客户端访问数据时的“三级寻址”</em>：</p><ul><li>为了加速寻址，客户端会缓存位置信息，同时，需要解决缓存失效问题（惰性解决机制，仅在使用该缓存没找到对应数据后才判定缓存失效）</li><li>寻址过程客户端只需要询问Zookeeper服务器，不需要连接Master服务器</li></ul><h1 id="HBase运行机制"><a href="#HBase运行机制" class="headerlink" title="HBase运行机制"></a>HBase运行机制</h1><h2 id="HBase系统架构"><a href="#HBase系统架构" class="headerlink" title="HBase系统架构"></a>HBase系统架构</h2><p>系统架构图：</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20201103112025.png" alt="QQ截图20201103112025"></p><blockquote><p>HBase采用HDFS作为底层存储，自身不具备数据复制和维护数据副本的功能，而HDFS提供这些支持。</p></blockquote><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul><li>访问HBase的接口</li><li>在缓存中维护着已经访问过的Region位置信息，用来加快后续数据访问过程</li><li>使用RPC机制与Master和Region服务器通信</li></ul><h3 id="Zookeeper服务器"><a href="#Zookeeper服务器" class="headerlink" title="Zookeeper服务器"></a>Zookeeper服务器</h3><ul><li><p>每个Region服务器都到Zookeeper中注册，Zookeeper实时监控每个Region服务器的状态并通知给Master</p></li><li><p>帮助选举出一个Master作为集群的总管，并保证在任何时刻总有唯一一个Master在运行，避免了Master的“单点失效”问题</p></li><li><p>保存-ROOT-表和Master的地址，以供客户端访问获得</p></li></ul><blockquote><p>Zookeeper是一个很好的集群管理工具，被大量用于分布式计算，提供配置维护、域名服务、分布式同步、组服务等。</p></blockquote><p><img src="http://img.cuper.top/bigdataacdfwf.png" alt="acdfwf"></p><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><ul><li>管理用户对表的增加、删除、修改、查询等操作</li><li>实现不同Region服务器之间的负载均衡</li><li>在Region分裂或合并后，负责重新调整Region的分布</li><li>对发生故障失效的Region服务器上的Region进行迁移</li></ul><h3 id="Region服务器"><a href="#Region服务器" class="headerlink" title="Region服务器"></a>Region服务器</h3><p>HBase中最核心的模块，负责维护分配给自己的Region，并响应用户的读写请求</p><h2 id="Region服务器工作原理"><a href="#Region服务器工作原理" class="headerlink" title="Region服务器工作原理"></a>Region服务器工作原理</h2><p>Region服务器体系：</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20201103163300.png" alt="QQ截图20201103163300"></p><ul><li>每一台Region服务器可以存储10-1000个Region</li><li>所有Region共用一个日志文件HLog</li><li>在存储中每个Region的每个列族会单独构成一个Store</li><li>每个Store包含一个MemStore和若干个StoreFile</li><li>MemStore：在内存中的缓存，保存最近更新的数据</li><li>StoreFile：磁盘文件，MemStore满了之后再刷写，实现方式是HDFS文件系统的HFile</li></ul><h3 id="用户读写数据过程"><a href="#用户读写数据过程" class="headerlink" title="用户读写数据过程"></a>用户读写数据过程</h3><ul><li>写入数据时，被分配到相应Region服务器去执行，首先被写入到MemStore和Hlog中，当操作写入Hlog之后，commit()调用才会将其返回给客户端</li><li>读取数据时，Region服务器会首先访问MemStore缓存，如果找不到，再去磁盘上面的StoreFile中寻找</li></ul><h3 id="缓存的刷新"><a href="#缓存的刷新" class="headerlink" title="缓存的刷新"></a>缓存的刷新</h3><ul><li>周期性地把MemStore缓存里的内容刷写到磁盘的StoreFile文件中，清空缓存，并在Hlog里面写入一个标记表示已写入。每次刷写都生成一个新的StoreFile文件。</li><li>Region服务器每次启动都检查HLog，确认最近一次执行缓存刷新操作之后是否发生新的写入操作：若发现更新，则先写入MemStore，再刷新缓存并删除旧的HLog文件，才开始提供服务。</li></ul><h3 id="StoreFile的合并"><a href="#StoreFile的合并" class="headerlink" title="StoreFile的合并"></a>StoreFile的合并</h3><p>当StoreFile文件数量达到一个阈值后，调用Store.compact()把多个合并成一个，减少查找时间方便访问某个Store中的某个值。</p><h2 id="Store工作原理"><a href="#Store工作原理" class="headerlink" title="Store工作原理"></a>Store工作原理</h2><p><strong>Store是Region服务器的核心</strong></p><p>StoreFile的合并与分裂（<strong>Region分裂发生的地方</strong>）：</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20201103190720.png" alt="QQ截图20201103190720"></p><ul><li>StoreFile文件数量达到阈值时触发合并操作</li><li>单个StoreFile文件大小达到阈值时触发分裂操作</li></ul><h2 id="HLog工作原理"><a href="#HLog工作原理" class="headerlink" title="HLog工作原理"></a>HLog工作原理</h2><p><strong>分布式环境必须要考虑系统出错后能够回恢复。</strong></p><p>HLog文件：预写式日志（Write Ahead Log）</p><p>用户更新数据的步骤：</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20201103191530.png" alt="QQ截图20201103191530"></p><p>Zookeeper实时监测每个Region服务器的状态，当某个Region服务器发生故障时：</p><ul><li>Zookeeper通知Master</li><li>Master首先会处理该故障Region服务器上面遗留的HLog文件：包含了来自多个Region对象的日志记录，对HLog数据进行拆分，分别放到相应Region对象的目录下</li><li>将失效的Region重新分配到可用的Region服务器中，并把与该Region对象相关的HLog日志记录也发送给相应的Region服务器</li><li>Region服务器领取到分配给自己的Region对象以及与之相关的HLog日志记录以后，重做一遍日志记录中的各种操作</li></ul><h3 id="一个Region服务器中各个Region共用一个HLog日志："><a href="#一个Region服务器中各个Region共用一个HLog日志：" class="headerlink" title="一个Region服务器中各个Region共用一个HLog日志："></a>一个Region服务器中各个Region共用一个HLog日志：</h3><ul><li>优点：减少磁盘寻址字数，提高对表的写操作性能</li><li>缺点：恢复时需要分拆日志</li></ul><h1 id="HBase应用方案"><a href="#HBase应用方案" class="headerlink" title="HBase应用方案"></a>HBase应用方案</h1><h2 id="HBase实际应用中的性能优化方法"><a href="#HBase实际应用中的性能优化方法" class="headerlink" title="HBase实际应用中的性能优化方法"></a>HBase实际应用中的性能优化方法</h2><h3 id="把常用数据保存到一起"><a href="#把常用数据保存到一起" class="headerlink" title="把常用数据保存到一起"></a>把常用数据保存到一起</h3><p>行键是按照字典序存储，因此，设计行键时，要充分利用这个排序特点，将经常一起读取的数据存储到一块，将最近可能会被访问的数据放在一块：</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20201103193633.png" alt="QQ截图20201103193633"></p><h3 id="提升读写性能"><a href="#提升读写性能" class="headerlink" title="提升读写性能"></a>提升读写性能</h3><ul><li><p><strong>InMemory</strong>：设置HColumnDescriptor.setInMemory(true)将表放到Region服务器的缓存中，保证在读取的时候被cache命中</p></li><li><p><strong>Max Version</strong>：将HColumnDescriptor.setMaxVersions(int maxVersions)设置表中数据的最大版本，节省存储空间</p></li><li><p><strong>InMemory</strong>：将HColumnDescriptor.setTimeToLive(int timeToLive)设置表中数据的存储生命期，过期数据将自动被删除</p></li></ul><h2 id="在HBase之上构建SQL引擎"><a href="#在HBase之上构建SQL引擎" class="headerlink" title="在HBase之上构建SQL引擎"></a>在HBase之上构建SQL引擎</h2><p>在NoSQL数据存储HBase上提供SQL接口的原因：</p><ul><li>易使用</li><li>减少编码</li></ul><p>方案：</p><ul><li>Hive整合HBase</li><li>Phoenix</li></ul><h2 id="构建HBase二级索引"><a href="#构建HBase二级索引" class="headerlink" title="构建HBase二级索引"></a>构建HBase二级索引</h2><p>原生HBase产品不支持对各个列构建相关索引，只能：</p><ul><li>通过单个行键访问</li><li>通过一个行键的区间来访问</li><li>全表扫描</li></ul><p>采用HBase0.92版本之后引入的Coprocessor特性，可以构建二级索引：</p><ul><li>Coprocessor提供了两个实现：endpoint和observer，endpoint相当于关系型数据库的存储过程，而observer则相当于触发器</li><li>observer允许我们在记录put前后做一些处理，因此，而我们可以在插入数据时同步写入索引表，生成相对于主表的另一个表</li></ul><p>为HBase行健提供索引功能的产品：</p><ul><li>Hindex二级索引</li><li>HBase+Redis</li><li>HBase+solr</li></ul><h2 id="HBase性能监视"><a href="#HBase性能监视" class="headerlink" title="HBase性能监视"></a>HBase性能监视</h2><ul><li>Master-status(自带)</li><li>Ganglia</li><li>OpenTSDB</li><li>Ambari</li></ul><h1 id="HBase编程实践"><a href="#HBase编程实践" class="headerlink" title="HBase编程实践"></a>HBase编程实践</h1><p>详细安装过程参考：</p><ul><li><a href="http://blog.cuper.top/2020/09/18/ZooKeeper_setup/">ZooKeeper3.4.14完全分布式安装</a></li><li><a href="http://blog.cuper.top/2020/09/18/HBase_setup/">HBase1.4.13完全分布式安装</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> MOOC笔记 </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文投稿反馈意见总结——SIGCSE_2021_paper_206</title>
      <link href="2020/10/17/paper_advice/"/>
      <url>2020/10/17/paper_advice/</url>
      
        <content type="html"><![CDATA[<h1 id="总评审"><a href="#总评审" class="headerlink" title="总评审"></a>总评审</h1><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul><li>话题与SIGCSE非常相关</li><li>数据集相当大</li><li>分析很好地呈现出来</li><li>将视频观看行为编码为字符串是一种有趣的方法</li><li>视觉效果非常简洁</li></ul><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ul><li>文章像一篇应用机器学习进行的项目报告</li><li>结果&amp;讨论部分较多不足之处。在Programming1和Programming2课中没有full participation learners，原文的意思是利用轮廓系数确定的K值是2，所以没有这类学习者，但是过于牵强，应该是由于课程差异很大而导致的可能同一聚类方法不能应用于不同的课程。</li><li>4门特殊课程的选择过程没讲清楚</li></ul><h2 id="建议："><a href="#建议：" class="headerlink" title="建议："></a>建议：</h2><ul><li>展示一些创造性的新应用技术</li><li>进行一些实验，以证明该工作在现有工作的基础上有所改进</li><li>比较并替代现有技术</li></ul><h1 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h1><table><thead><tr><th>评分项</th><th>审1</th><th>审2</th><th>审3</th></tr></thead><tbody><tr><td>有理论基础</td><td>2</td><td>1</td><td>3</td></tr><tr><td>有一个或多个研究问题</td><td>3</td><td>2</td><td>3</td></tr><tr><td>研究问题有基于相关的前期工作</td><td>2</td><td>2</td><td>3</td></tr><tr><td>工作解决了研究问题</td><td>2</td><td>2</td><td>3</td></tr><tr><td>文章提供了足够的细节来支撑对研究结果的复现</td><td>1</td><td>3</td><td>3</td></tr><tr><td>文章中描述的过程/方法是回答研究问题的有效方法</td><td>2</td><td>2</td><td>2</td></tr><tr><td>贡献描述清楚。（若是新项目，）介绍了超出先前工作的贡献。（若是复现，）本文的贡献包含了对与先前研究相比的新结果意义的讨论。</td><td>1</td><td>2</td><td>3</td></tr><tr><td>对有效性的威胁或研究局限性已明确说明，并证实其适合研究过程/方法</td><td>1</td><td>1</td><td>1</td></tr><tr><td>陈述（文字、图表或图表）清晰明了</td><td>1</td><td>2</td><td>2</td></tr></tbody></table><h1 id="一审"><a href="#一审" class="headerlink" title="一审"></a>一审</h1><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>主题相关</li><li>将视频观看行为编码为字符串是一种有趣的方法</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>没有讨论以往研究成果，缺乏理论依据</p></li><li><p>描述了该方法，但存在潜在的偏差问题和缺乏适当的理由</p></li><li><p>结果中没有足够的细节</p></li><li><p>研究问题的影响不明确，与这些问题相关的结果的意义没有得到适当的讨论</p></li><li><p>对有效性的威胁没有得到解决</p></li></ul><h3 id="总体评价"><a href="#总体评价" class="headerlink" title="总体评价"></a>总体评价</h3><ul><li>建议把工作更多地放在文献研究中：因为在学习分析方面已有大量的工作（推荐了一个：Ihantola等人从2015年起对LA的研究）；对于related work应该描述他们的发现，而不仅仅是使用的方法。</li><li>修改RQ2的措辞：学习结果是由教师定义的、学习者期望达到的，聚类集群不会直接影响学习结果。我知道作者们想用这个问题来评估学生在课堂上的表现是否会有差异，我的评论也反映了这个假设。</li></ul><blockquote><p>RQ2: Do different learning patterns of different clusters of learners exert an influence on learning outcomes?</p></blockquote><ul><li>只报告了每个分组的平均分和学生人数：希望看到更多的描述性统计数据，比如分数的标准差、每个聚类中字符串长度的平均值和标准差，并对每一组学生的行为进行全面评估；而不是仅仅从5个组别中分别选出一个学生，5253个学生只有5个被研究讨论。同样，也没有证明在不同课程里的相同类别学生的相似性。</li><li>评估类别之间平均分差异的显著性：需要一些统计测试，比如ANOVA或非参数检验。同时，没有说明后3门课程的分数为何如此之低。并且没有讨论课程之间各类别的分差的差异性：第二高的“Section-oriented” cluster类学习者平均分，在Theory_2里比第一高的低了50%，而在Theory_1里只低了10%。</li><li>确定研究问题之间的相关性、以及结果与它们如何解决问题之间的联系：本文中所有的研究问题都有一个二元的结果，可以直接用“是/否”来回答，没有多大意义。比如RQ3可改为：What are the differences in the clustering results among different types of clusters?</li><li>所产生的聚类集群似乎是人为的：预先分成两类之后使用K-Medoids分成5类似乎是随意确定的，没有报告一共8次K-Medoids运算过程中的轮廓系数的具体变化情况。建议在每次确定k值时都显示一个轮廓系数图。同样，一个课程有5个集群而其他课程有4个集群，但结果上保持相同的集群名称，需要更多的数据驱动的理由——比如对每个集群的字符串都进行描述性统计。</li><li>报告更详细的结果的这个建议同样意味着这项工作的复现。除开有效性不谈，文章提出的方法得到了描述并且是可以重复使用的，但是论文缺少的细节使得这项工作无法得到复现和验证。</li><li>在1585门课程中选择这4门的原因没有说明。例如：选择过程是什么？每个课程中都有多少个视频？视频的长度（最大值、最小值、平均值）是多少？有这些课程的学习者的个人信息吗？每门课程的作业考核评估都有多少次？</li><li>结果存在偏差的一个可能的原因：对于那些未完成（辍学的）学习者给了0分。应该报告清楚那些未完成练习的学生数量，与真正考得很差的那些人区分开。只考虑已完成（有得分）的学习者来计算平均分可能是一个更好的方法。</li><li>其他不算很大的问题：作为这项工作的动机的未经证实的陈述，例如“The analysis results of video watching behavior is the most direct reflection of learner’s learning behavior”，这在文献中有点争议（<a href="https://jolt.merlot.org/vol9no2/milligan_0613.htm">参考</a>），建议引证一下。</li><li>总而言之的问题：the validity of the methods and the lack of transparency in the results</li></ul><h1 id="二审"><a href="#二审" class="headerlink" title="二审"></a>二审</h1><h3 id="语法问题"><a href="#语法问题" class="headerlink" title="语法问题"></a>语法问题</h3><p>较多待解决的语法问题，摘要的第一句话就有几个问题，不过其含义大体上是清楚的。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>有趣的问题——在MOOC中描述学生的主要行为类型</li><li>技术方法似乎合理</li><li>论文的组织结构很好，很容易理解所做的事情</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>研究贡献不大：简单地展示了使用MOOC数据进行聚类分析和可视化的一种方法，没有尝试多种方法，并且建立一套标准来评估哪种方法是最好的。</li><li>没有将他们的聚类方法与其他方法进行比较，以证明他们的方法更有效。只是在解释他们尝试过的一种方法，使得无法评估该方法是否比任何其他方法更好或更差。</li><li>本文的一个关键技术选择是如何将视频日志数据编码为字符串，但无法判断这是否是一个好的选择。同样地对聚类分析的选择也是如此。</li><li>一般来说，无监督学习和可视化方法是很难评估的；但至少可以说明，如果使用其他方法，他们的结果会如何变化。<strong>需要对比</strong></li><li>语法问题：由于语法问题论文很难阅读，特别是在前几页中这个问题似乎尤其糟糕，对应文字里作者们正在高水平地解释他们的工作。</li><li>建议提供一个例子来展示某个学生的视频观看行为的编码字符串。</li><li>在第3.1节中作者把日志数据分为不同的观看“session”，但后面又提到了“Sequence”，尚不清楚序列中的字符串是否对应于单个会话。（特别是3.1节的最后两段表述不清楚）</li></ul><h3 id="总体评价-1"><a href="#总体评价-1" class="headerlink" title="总体评价"></a>总体评价</h3><ul><li>研究贡献薄弱。</li><li>没有将文中方法与其他方法进行比较，也没有提供一种评估结果质量的方法。</li><li>论文更多的是对一个工程项目的描述，而不是一篇研究论文。</li></ul><h1 id="三审"><a href="#三审" class="headerlink" title="三审"></a>三审</h1><h3 id="语法问题-1"><a href="#语法问题-1" class="headerlink" title="语法问题"></a>语法问题</h3><p>本文最有趣的部分之一是聚类方法发现了5种类型的学习者，并且这5种类型的学习者（a）是可解释的，（b）在不同的课程中相当一致。建议在摘要和结论中强调这五种类型的学习者。</p><p><strong>详细意见</strong></p><ul><li>建议删除摘要的前两句话，以便更快地抓住要点</li><li>第2章节第2段的”screen out”表述不清，不知道是”including”还是”excluding”</li><li>第2章：不是 “user’s ID”, “course’s ID”而是”user ID”、”course ID”。”OS”作为操作系统的缩写需要大写。”local start time”应该比”start local time”更常用，”real time”意味不明。</li><li>第2章第一段：”a log <em>entry</em> will be generated”</li><li>3.2章：”Considering the form of string in behavior sequences, we use Levenshtein distance as our similarity measurement”应该是”Since we are computing similarities of sequences, we use the Levenshtein distance.”</li><li>4.2章：”we extract all the log of him”应该是”we extract all his logs…”或者（更可取的，保持性别中立的）”we extract all their logs…”</li><li>表3： 减少“Average Score”列中的有效位数，以显示适当的不确定度。</li><li>表1/2/3中的“Number”推荐用“Count”代替</li></ul><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>这项工作与更广泛的SIGCSE话题界相关。</li><li>该方法相当有趣，似乎是合理的。</li><li>类似的可解释聚类出现在多个课程中，这是一个非常引人注目的结果。</li><li>论文的结构也很好，虽然有一些语法问题，但易于理解。</li><li>数字很容易理解，也很有启发性。</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>评估学习成果的方法存疑：低覆盖率的学习者不会完成大部分题目，所以“average score”更像是练习题完成率的代表。更推荐的指标是计算每个学习者实际完成的题目的平均分数。比如4.2节最后几句讨论的话，比较并不完全成立，因为不清楚section-oriented learner是否仅是因为完成了更多的问题而把平均分抬高了。</li></ul><blockquote><p>For example, the average score of low-participation learners is 10 points less than that of section-oriented learner, indicating that the outcome of superficial learning is worse than that of targeted learning.</p></blockquote><ul><li>研究的MOOC背景条件不充分，不利于把研究结果置于特定背景中讨论：它们在小学/中学/大学环境中使用过？学员是否需要完成课程才能获得一些证书认证？对于编程课程，是否有一些入门部分是大多数学习者跳过的，因此没有full-participation learners？</li><li>第4.1节似乎表明低覆盖率学习者比高覆盖率学习者多得多，但这些数字与表1和表2不符。（<strong>确实这里4.1节写反了</strong>）对于大多数MOOC来说，低覆盖率的学习者应该会比高覆盖率的学习者更多。（但是Theory_1就是一个例外）</li><li>低覆盖率和高覆盖率学习者的聚类前的划分本身是非常有趣的，但是多讨论一下为什么不能将这两个群体聚集在一起将有助于理解。</li><li>集群中是否有异常值，如果有，这些异常值有多普遍。有多少学习者不适合这五个聚类集群？</li><li>对有效性的威胁没有得到解决。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 聚类 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 可视化 </tag>
            
            <tag> MOOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文精读笔记——Achievable Rate Maximization by Passive Intelligent Mirrors</title>
      <link href="2020/10/09/ACHIEVABLE_RATE_MAXIMIZATION_BY_PASSIVE_INTELLIGENT_MIRRORS/"/>
      <url>2020/10/09/ACHIEVABLE_RATE_MAXIMIZATION_BY_PASSIVE_INTELLIGENT_MIRRORS/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>多媒体通信课堂报告，选取ICASSP2018中的<a href="https://ieeexplore.ieee.org/document/8461496">Achievable Rate Maximization by Passive Intelligent Mirrors</a>一文。</p><h1 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h1><p>使用Passive Intelligent Mirrors（PIM，无源智能反射镜）来操作多用户MISO下行链路通信。</p><p>设计transmit powers（传输功率）和mirror reflection coefficient（镜像反射系数）：保证移动用户的个人Quality of Service（QoS）需求的前提下，使sum-rate（和速率）最大化。</p><p>问题特点：non-convex（非凸）</p><p>solution：alternating maximization（交替极大化）与majorization-minimization算法（优化极小化算法）相结合。</p><p>merit：在不需要额外的能量消耗的情况下，system throughput（系统吞吐量）至少提高了40%。</p><h1 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1. INTRODUCTION"></a>1. INTRODUCTION</h1><p>无线设备数量直奔500亿（50 billions）</p><p>对蜂窝网络的要求：</p><ul><li>比现有网络高1000倍的数据速率</li><li>耗能减半</li></ul><p>绿色节能的无线解决方案：</p><ul><li>renewable energy sources（可再生能源）</li><li>energy-efficient hardware（节能硬件）</li><li>green radio resource allocation and transmission（绿色无线电资源分配和传输）</li></ul><p>具有巨大潜力的技术：Passive Intelligent Mirrors (PIM)——由许多small-unit reflector（小型单元反射镜）组成的physical metasurface（物理超表面），配备了simple low-cost sensors（简单的低成本传感器）和cognitive engine（认知引擎）。</p><blockquote><p>metasurface（超表面）：指一种厚度小于波长的人工层状材料。超表面可实现对电磁波偏振、振幅、相位、极化方式、传播模式等特性的灵活有效调控。</p></blockquote><p>对于任何一个入射electromagnetic field（电磁场），反射单元都能反射出phase-shifted（相移）的形式。因此通过设计适当的相移，可以组合不同单元反射的信号，使PIM成为一个active medium（激活媒质，工作媒质）。</p><p>PIM：充当一个amplify-and-forward relay（放大和转发中继），并不需要专用能源。作用：</p><ul><li>节省宝贵的能源</li><li>在信道条件差的情况下也能进行通信</li><li>部署成本低</li></ul><p>PIM使用范围：</p><ul><li>集成到发射机周围建筑物的墙壁中</li><li>移动列车的天花板</li><li>笔记本电脑袋</li><li>人的手臂</li><li>……</li></ul><p>intelligent wall（智能墙）：一种可以安装在建筑物内部以改善室内通信的墙。</p><p>related work：以往的工作并没有提供任何系统设计方法，只是将PIM的思想引入到室内场景中。</p><p>本文：主要针对室外场景，考虑一个MISO下行链路信道。工作：优化发射功率&amp;PIM相移，目标：系统和速率最大化。</p><p>所得的优化问题：非凸问题</p><p>解决：结合交替优化和MM算法，提出可证明收敛、低复杂度的优化方法</p><p>结果：PIM可以在不增加任何能量消耗的情况下使系统的和速率提高40%以上</p><h1 id="2-SYSTEM-MODEL"><a href="#2-SYSTEM-MODEL" class="headerlink" title="2. SYSTEM MODEL"></a>2. SYSTEM MODEL</h1><p>Figure 1：M根antennas（天线）的base station（BS，基站），通过嵌入周围建筑物中的N个反射单元组成的PIM（充当一个中继），为K个单天线用户（K个mobile）服务。</p><p>忽略BS和mobile的直接路径 ∵假设没有line-of-sight communication（直视通信线）</p><p><img src="http://img.cuper.top/wirelessFigure1.png" alt="Figure1"></p><p>在用户k处接收到的离散时间信号可以写成（<strong>对于某个用户k来说</strong>）：</p><p><img src="http://img.cuper.top/wirelessgs1.png" alt="gs1"></p><p><img src="http://img.cuper.top/wirelesshk2.png" alt="hk2">：PIM和用户k之间的信道矩阵，1×N</p><p><img src="http://img.cuper.top/wirelessH1.png" alt="H1">：BS和PIM之间的信道，N×M</p><p>这两个是标准高斯变量（standard Gaussian variables），并且：</p><ul><li><p>独立同分布（independent and identically distributed，i.i.d.）</p></li><li><p>复圆周对称（complex circularly symmetric）</p></li></ul><blockquote><p>独立同分布（independent and identically distributed，i.i.d.）：在概率统计理论中，指随机过程中，任何时刻的取值都为随机变量，如果这些随机变量服从同一分布，并且互相独立，那么这些随机变量是独立同分布。</p><p>复圆周对称（circular symmetry）： its real and imaginary parts are independent and have the same distribution.</p></blockquote><p><img src="http://img.cuper.top/wireless%CE%98.png" alt="Θ">：PIM相移矩阵，N×N</p><p><img src="http://img.cuper.top/wireless%E7%83%AD%E5%99%AA%E5%A3%B02.png" alt="热噪声2">：用户k的热噪声</p><blockquote><p>thermal noise（热噪声）：</p><p>热噪声亦称白噪声，是由导体中电子的热震动引起的，它存在于所有电子器件和传输介质中。它是温度变化的结果，但不受频率变化的影响。热噪声是在所有频谱中以相同的形态分布，它是不能够消除的，由此对通信系统性能构成了上限。</p><ul><li>由电阻等导体中自由电子的布朗运动引起的噪声；</li><li>电子的这种随机运动会产生一个交流电流成分，即热噪声；</li><li>频谱像白光的频谱在可见光的频谱范围内一样的均匀分布，又称白噪声。</li><li>服从高斯分布，又常称高斯白噪声。</li></ul></blockquote><p><img src="http://img.cuper.top/wirelessX.png" alt="X">：基站发射的信号，其中：</p><ul><li>p：发射功率（transmit power）</li><li>g：信息符号（information symbol）（M×1矩阵）</li><li>s：波束成形向量（beamforming vector）</li></ul><p>对于用户k来说，SINR（信号与干扰加噪声比，Signal to Interference plus Noise Ratio）为：</p><p><img src="http://img.cuper.top/wirelessgs2.png" alt="gs2"></p><h2 id="2-1-Problem-formulation"><a href="#2-1-Problem-formulation" class="headerlink" title="2.1 Problem formulation"></a>2.1 Problem formulation</h2><p>工作目标：优化发射功率和矩阵Θ，以达到系统和速率的最大化</p><p>使问题易处理：采用zero-forcing transmission（迫零传输）——在高信噪比条件下最优</p><p>假设N≥K，定义：</p><ul><li><img src="http://img.cuper.top/wirelessG1.png" alt="G1"></li><li><img src="http://img.cuper.top/wirelessH.png" alt="H"></li></ul><p>迫零传输通过设置<img src="http://img.cuper.top/wireless%E8%BF%AB%E9%9B%B6.png" alt="迫零">实现。</p><p><img src="http://img.cuper.top/wireless%EF%BC%88%EF%BC%89+.png" alt="（）+">代表伪逆矩阵（pseudo-inversion）</p><p>然后，</p><ul><li>定义矩阵：<img src="http://img.cuper.top/wirelessP.png" alt="P"></li><li>定义基站的最大可行发射功率：<img src="http://img.cuper.top/wirelessPmax.png" alt="Pmax"></li><li>定义第k个用户的需求速率：<img src="http://img.cuper.top/wirelessRmin.png" alt="Rmin"></li></ul><p>和速率最大化的问题可以如下表述：</p><p><img src="http://img.cuper.top/wirelessProblem.png" alt="Problem"></p><p>这是一个非凸问题，并且对于Θ的优化具有挑战性。Section3将介绍一种计算上可承受的（computationally-affordable）方法</p><h1 id="3-PROPOSED-APPROACH"><a href="#3-PROPOSED-APPROACH" class="headerlink" title="3. PROPOSED APPROACH"></a>3. PROPOSED APPROACH</h1><p>解决计算复杂性：把P和Θ分别、迭代地优化。</p><h2 id="3-1-Optimization-with-respect-to-Θ"><a href="#3-1-Optimization-with-respect-to-Θ" class="headerlink" title="3.1. Optimization with respect to Θ"></a>3.1. Optimization with respect to Θ</h2><p>对于固定的P，问题变成了一个可行性试验：</p><p><img src="http://img.cuper.top/wirelessProblem4.png" alt="Problem4"></p><p>用一个变量替换：<img src="http://img.cuper.top/wireless%CF%86k=ej%CE%B8k.png" alt="φk=ejθk">，问题变成了：</p><p><img src="http://img.cuper.top/wirelessProblem5.png" alt="Problem5"></p><p>问题在于：目标函数不可微分，并且最后一个条件是非凸限制。</p><p>接着，作者观察到该问题是有解的，当且仅当：</p><p><img src="http://img.cuper.top/wirelessProblem6.png" alt="Problem6">这个问题里的目标函数的最小值小于<img src="http://img.cuper.top/wirelessPmax.png" alt="Pmax">。因此，目标函数可以再次改写为：</p><p><img src="http://img.cuper.top/wirelessProblem7.png" alt="Problem7"></p><blockquote><p>vec()：向量化算符，拉成列向量</p><p>⊗：张量积</p><p>||·||F：Frobenius 范数，简称F-范数，是一种矩阵范数，记为||·||F。矩阵A的Frobenius范数定义为矩阵A各项元素的绝对值平方的总和开根，可用于利用低秩矩阵来近似单一数据矩阵。用数学表示就是去找一个秩为k的矩阵B，使得矩阵B与原始数据矩阵A的差的F范数尽可能地小。</p></blockquote><p>在这里，利用了Frobenius矩阵范数（Frobenius matrix norm）的性质&amp;向量化算子（vectorization operator）与Kronecker积（克罗内克积，Kronecker product）之间的联系。这个新的目标函数可以处理非凸限制——前提是把它转化为可微函数。</p><p>使用：<strong>MM算法（Majorization-Minimization method）</strong>，一个迭代方法，在第i次迭代时最大化目标函数的上限。</p><blockquote><p>MM算法是一种迭代优化方法，它利用函数的凸性来找到它们的最大值或最小值。当目标函数f(θ)较难优化时，算法不直接对目标函数求最优化解，转而寻找一个易于优化的目标函数g(θ)替代，然后对这个替代函数求解，g(θ)的最优解逼近于f(θ)的最优解。每迭代一次，根据所求解构造用于下一次迭代的新的替代函数，然后对新的替代函数最优化求解得到下一次迭代的求解。通过多次迭代，可以得到越来越接近目标函数最优解的解。</p><p>Majorize-Minimization：每次迭代找到一个目标函数的上界函数，求上界函数的最小值。Majorization-Minimization的名字就是这么来的，找一个在上面的函数u——Majorization，最小化函数u——Minimization。</p></blockquote><p><img src="https://pic3.zhimg.com/v2-1329a99e9bd78a0cb8f489e8b42cf276_r.jpg" alt="mm2"></p><p>然而，对于任何第i次迭代，当在第(i−1)次迭代中计算的最大化值时，需要保证第i次迭代中最大化的上界和真实目标函数的上界必须相等。</p><p>MM算法的property（性质）：单调改进（monotonic improvement），即每次迭代后都单调地减少真正目标函数的值。——意味着最终会收敛于目标值 ∵目标函数在问题可行集上有下界。</p><p>使用MM算法的挑战：确定真实目标函数的合适上界，该上界需要：</p><ul><li>满足MM算法的理论要求（即和真实目标函数的上界必须相等）</li><li>与原始目标函数相比更容易最小化</li></ul><p>提出lemma（引理），给出一个方便确定的上界：</p><p><img src="http://img.cuper.top/wirelesslemma1.png" alt="lemma1"></p><p>利用（8）式中的二阶泰勒展开式证明，在这里作者由于篇幅限制省略了证明的过程……</p><p>基于引理1，对于MM算法的每次迭代，面对的问题转化为：</p><p><img src="http://img.cuper.top/wirelessProblem9.png" alt="Problem9"></p><p>再提出命题：</p><p><img src="http://img.cuper.top/wirelessProblem10.png" alt="Problem10"></p><p>利用上面问题目标函数的驻点分析来证明，同样省略了证明过程。</p><h2 id="3-2-Optimization-with-respect-to-P"><a href="#3-2-Optimization-with-respect-to-P" class="headerlink" title="3.2 Optimization with respect to P"></a>3.2 Optimization with respect to P</h2><p>对于固定的Θ，问题为：</p><p><img src="http://img.cuper.top/wirelessProblem11.png" alt="Problem11"></p><p>一个凸问题，可以直接用标准凸优化的方法。分析它的Karush–Kuhn–Tucker (KKT) optimality condi- tions（KKT最优化条件），引出该问题的闭式表达式（closed-form expression）的解：</p><blockquote><p>Karush-Kuhn-Tucker (KKT)条件是非线性规划(nonlinear programming)最佳解的必要条件，将Lagrange乘数法(Lagrange multipliers)所处理涉及等式的约束优化问题推广至不等式。</p><p>闭式：一个表达式，由初等函数经过有限次的初等运算复合而成。</p></blockquote><p><img src="http://img.cuper.top/wirelesslemma2.1.png" alt="lemma2.1"></p><p><img src="http://img.cuper.top/wirelesslemma2.2.png" alt="lemma2.2"></p><p>完整算法总结：</p><p><img src="http://img.cuper.top/wirelessAlgorithm.png" alt="Algorithm"></p><p>内循环：MM算法</p><p>外循环：交替最大化（alternating maximization）</p><p>算法的每次迭代使整个问题的目标函数（最开头未转化时的那个max值）值单调递增，最终收敛于目标函数值 ∵目标函数在紧可行域（闭集且有界）上是连续的，因此必有上界。</p><h1 id="4-NUMERICAL-RESULTS"><a href="#4-NUMERICAL-RESULTS" class="headerlink" title="4. NUMERICAL RESULTS"></a>4. NUMERICAL RESULTS</h1><p>做一个数值仿真，场景同第二章所述：</p><ul><li>用户在625平方米的区域内被随机安排位置</li><li>信道为随机矩阵的实现，标准复高斯分布，独立同分布</li></ul><p>所有结果通过平均了500多个独立信道和用户位置得到的</p><p>定义信噪比：<img src="http://img.cuper.top/wirelessSNR.png" alt="SNR"></p><p>图2：SNR-可实现的和速率</p><p><img src="http://img.cuper.top/wirelessFigure2.png" alt="Figure2"></p><p>考虑了两组系统参数：</p><ul><li>K = 16, M = 32, N = 32</li><li>K = 8, M = 8, N = 8</li></ul><p>最小QoS速率设置为那个Rmin。</p><p>问题的最优解由拟牛顿法（共轭方向法，Quasi-Newton search）获得，算法复杂度是指数级别的，且只考虑benchmarking purpose（基准、标杆测试）。</p><p>在没有PIM的系统中：资源分配也被视为一个基线方案，这种情况下只需进行功率分配（就是3.2节Optimization with respect to P完成的工作）</p><p>由图可见，PIM提高了大于40%的和速率。随着天线和PIM单元的数量增加，差异变得更大。与更高复杂度的全局优化方法相比，PIM与其的差距始终有限。</p><p>图3：PIM单元数量-可实现的和频谱利用率</p><p><img src="http://img.cuper.top/wirelessFigure3.png" alt="Figure3"></p><p>参数：SNR = 20 dB, K = 16, M = 8, Rmin,k = 2 bps/Hz</p><p>如图所示，PIM所提出的算法1与全局优化方法得到的结果十分接近。PIM单元越多，在一个蜂窝里的和频谱利用率越高，但PIM单元数目越来越多时会接近饱和。</p><p>图4：迭代次数-MSE</p><p><img src="http://img.cuper.top/wirelessFigure4.png" alt="Figure4"></p><p>研究基于MM的算法1的收敛速度，基于该指标：达到给定的在两次连续迭代中的均方误差（Mean Square Error，MSE）所需要的迭代次数。MSE定义为：</p><p><img src="http://img.cuper.top/wirelessMSE.png" alt="MSE"></p><p>系统参数：K = 16, M = 8, N = 16; 32; 64</p><p>如图所示，MM算法在几十次迭代中即可达到可接受的MSE值。N越大，MSE值也越大——因为对应于待优化的变量的数量也在增加。</p><p>回顾MM算法的每个迭代只涉及简单的闭式计算，图4证实了所提出的基于MM的算法的非常有限的复杂性。</p><h1 id="5-CONCLUSION"><a href="#5-CONCLUSION" class="headerlink" title="5. CONCLUSION"></a>5. CONCLUSION</h1><p>提出了一种基于PIM的多用户MIMO系统的和速率最大化方案。</p><p>将MM和交替优化相结合，解决了非凸无线资源分配问题，给出了一种可证明收敛且低复杂度的算法。</p><p>数值结果表明，该方案达到了近似最优的性能，与传统的无PIM系统相比，其和速率提高了40%以上。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://zhuanlan.zhihu.com/p/107204751?utm_source=wechat_session">知乎：MM算法</a></p><p><a href="https://blog.csdn.net/weixin_43871127/article/details/106157635?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">CSDN：MM算法</a></p><p><a href="https://blog.csdn.net/jbb0523/article/details/52134630">Majorization-Minimization优化框架</a></p><p><a href="https://my.oschina.net/u/2935389/blog/2967416">非凸优化</a></p><p><a href="https://zhuanlan.zhihu.com/p/52530189">独立同分布</a></p><p><a href="https://blog.csdn.net/qidailiming1994/article/details/88429100">波束成形</a></p><p><a href="https://blog.csdn.net/lthirdonel/article/details/80920199">F范数</a></p><p><a href="https://ccjou.wordpress.com/2017/02/07/karush-kuhn-tucker-kkt-%E6%A2%9D%E4%BB%B6/">KKT条件</a></p><p><a href="https://zhuanlan.zhihu.com/p/26514613">KKT条件解读</a></p><p><a href="https://blog.csdn.net/liuwenyou/article/details/102589998">compact set</a></p><p><a href="https://blog.csdn.net/weixin_44492024/article/details/102455345">Quasi-Newton拟牛顿法（共轭方向法）</a></p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> MIMO </tag>
            
            <tag> 无线通信 </tag>
            
            <tag> PIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase1.4.13完全分布式安装</title>
      <link href="2020/09/18/HBase_setup/"/>
      <url>2020/09/18/HBase_setup/</url>
      
        <content type="html"><![CDATA[<h1 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h1><p>首先check<strong>版本要求</strong>！否则后续会遇到难以预料的“惊喜”。以下截图为2020年9月信息，可能随时更新，最新信息自行查询<a href="http://hbase.apache.org/book.html#basic.prerequisites">官网标准</a>。</p><p>JDK版本：</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20200918150113.png" alt="QQ截图20200918150113"></p><p>Hadoop版本：</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20200918150611.png" alt="QQ截图20200918150611"></p><p>本机已安装Hadoop2.7.7&amp;JDK1.8，于是选择HBase-1.4.x进行安装。从<a href="http://mirror.hust.edu.cn/apache/hbase/1.4.13/">镜像源</a>中下载hbase-1.4.13-bin.tar.gz。</p><h1 id="HBase1-4-13安装"><a href="#HBase1-4-13安装" class="headerlink" title="HBase1.4.13安装"></a>HBase1.4.13安装</h1><p>先用<code>scp</code>从网关把压缩包传到Master服务器上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp hbase-1.4.13-bin.tar.gz lpj@cpu-node0:/home/lpj/</span><br></pre></td></tr></table></figure><p>解压并重命名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf hbase-1.4.13-bin.tar.gz -C /home/lpj/</span><br><span class="line">mv hbase-1.4.13 hbase1.4</span><br></pre></td></tr></table></figure><p>配置环境变量，将hbase下的bin目录添加到path中，这样，启动hbase就无需到/usr/local/hbase目录下，大大地方便了hbase的使用。编辑~/.bashrc文件，先前在安装Hadoop时已经引入过PATH，直接在export PATH这行追加/home/lpj/hbase1.4/bin，这里的“：”是分隔符：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/home/lpj/hadoop2.7/bin:/home/lpj/hadoop2.7/sbin:/home/lpj/hbase1.4/bin</span><br></pre></td></tr></table></figure><p>编辑完成后，用<code>source ~/.bashrc</code>使上述配置在当前终端立即生效。用<code>hbase version</code>查看HBase版本，确定HBase安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ hbase version</span><br><span class="line">HBase 1.4.13</span><br><span class="line">Source code repository git://Sakthis-MacBook-Pro-2.local/Users/sakthi/dev/hbase revision=38bf65a22b7e9320f07aeb27677e4533b9a77ef4</span><br><span class="line">Compiled by sakthi on Sun Feb 23 02:06:36 PST 2020</span><br><span class="line">From source with checksum cfb98e5fbeeca2068278ea88175d751b</span><br></pre></td></tr></table></figure><h1 id="HBase配置"><a href="#HBase配置" class="headerlink" title="HBase配置"></a>HBase配置</h1><h2 id="配置hbase-env-sh"><a href="#配置hbase-env-sh" class="headerlink" title="配置hbase-env.sh"></a>配置hbase-env.sh</h2><p>修改conf文件夹里的hbase-env.sh文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> The java implementation to use.  Java 1.8+ required.</span></span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Extra Java CLASSPATH elements.  Optional.</span></span><br><span class="line">export HBASE_CLASSPATH=/home/lpj/hbase1.4/conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Configure PermSize. Only needed <span class="keyword">in</span> JDK7. You can safely remove it <span class="keyword">for</span> JDK8+</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> HBASE_MASTER_OPTS=<span class="string">&quot;<span class="variable">$HBASE_MASTER_OPTS</span> -XX:PermSize=128m -XX:MaxPermSize=128m -XX:ReservedCodeCacheSize=256m&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> HBASE_REGIONSERVER_OPTS=<span class="string">&quot;<span class="variable">$HBASE_REGIONSERVER_OPTS</span> -XX:PermSize=128m -XX:MaxPermSize=128m -XX:ReservedCodeCacheSize=256m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Tell HBase whether it should manage it<span class="string">&#x27;s own instance of ZooKeeper or not.</span></span></span><br><span class="line">export HBASE_MANAGES_ZK=false</span><br></pre></td></tr></table></figure><h2 id="配置hbase-site-xml"><a href="#配置hbase-site-xml" class="headerlink" title="配置hbase-site.xml"></a>配置hbase-site.xml</h2><p>修改conf文件夹里的hbase-site.xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://cpu-node0:9000/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">description</span>&gt;</span>The mode the cluster will be in. Possible values are</span><br><span class="line">      false: standalone and pseudo-distributed setups with managed Zookeeper</span><br><span class="line">      true: fully-distributed with unmanaged Zookeeper Quorum (see hbase-env.sh)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>cpu-node0,cpu-node3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.clientPort<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>3384<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/lpj/zookeeper3.4/zkdata<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.peerport<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>2878<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.leaderport<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>3878<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/lpj/hbase1.4/tmp/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.regionserver.port<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>16021<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.regionserver.info.port<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>16031<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>hbase.rootdir值是根据%HADOOP_HOME%/etc/hadoop下配置文件core-site.xml中fs.default.name的值加上/hbase.</li><li>hbase.zookeeper.property.dataDir的值是ZooKeeper的zoo.cfg文件里的dataDir的值，hbase.zookeeper.property.clientPort的值是同一个文件中clientPort的值。</li><li>hbase.zookeeper.peerport和hbase.zookeeper.leaderport分别是zoo.cfg里server.x的ip地址后面的两个端口，如果每个节点设置得不一样的话，hbase-site.xml复制过去之后记得修改。</li></ul><h2 id="配置regionservers"><a href="#配置regionservers" class="headerlink" title="配置regionservers"></a>配置regionservers</h2><p>在conf/regionservers中把从节点写进去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpu-node3</span><br></pre></td></tr></table></figure><h2 id="配置backup-masters"><a href="#配置backup-masters" class="headerlink" title="配置backup-masters"></a>配置backup-masters</h2><p>新建一个backup-masters文件并写入备份节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpu-node0</span><br></pre></td></tr></table></figure><h2 id="分发并同步安装包"><a href="#分发并同步安装包" class="headerlink" title="分发并同步安装包"></a><strong>分发并同步安装包</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r hbase1.4 lpj@cpu-node3:/home/lpj/</span><br></pre></td></tr></table></figure><h1 id="Start-amp-Check"><a href="#Start-amp-Check" class="headerlink" title="Start &amp; Check"></a>Start &amp; Check</h1><p>在Master节点上运行启动脚本<code>start-hbase.sh</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ start-hbase.sh</span><br><span class="line">running master, logging to /home/lpj/hbase1.4/bin/../logs/hbase-lpj-master-cpu-node0.hustlab.out</span><br><span class="line">cpu-node3: running regionserver, logging to /home/lpj/hbase1.4/bin/../logs/hbase-lpj-regionserver-cpu-node3.hustlab.out</span><br><span class="line">cpu-node0: master running as process 28346. Stop it first.</span><br></pre></td></tr></table></figure><p>然后用<code>jps</code>分别在主从节点上检查，如果Master上有<code>HMaster</code>、Slave上有<code>HRegionServer</code>即为启动成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ jps</span><br><span class="line">28657 Jps</span><br><span class="line">10293 QuorumPeerMain</span><br><span class="line">9495 SecondaryNameNode</span><br><span class="line">28346 HMaster</span><br><span class="line">10172 JobHistoryServer</span><br><span class="line">9149 NameNode</span><br><span class="line">9791 ResourceManager</span><br><span class="line"></span><br><span class="line">[lpj@cpu-node3 ~]$ jps</span><br><span class="line">22833 QuorumPeerMain</span><br><span class="line">22338 DataNode</span><br><span class="line">23861 HRegionServer</span><br><span class="line">22486 NodeManager</span><br><span class="line">24189 Jps</span><br></pre></td></tr></table></figure><p><strong>如何区分启动的ZooKeeper是HBase自带的还是外部的</strong>：若<code>jps</code>中是<code>QuorumPeerMain</code>则为外部自行安装的，<code>HQuorumPeerMain</code>则为HBase自带的。</p><h1 id="HBase-Shell实践"><a href="#HBase-Shell实践" class="headerlink" title="HBase Shell实践"></a>HBase Shell实践</h1><p>用<code>hbase shell</code>进入shell界面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ hbase shell</span><br><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:&#x2F;home&#x2F;lpj&#x2F;hbase1.4&#x2F;lib&#x2F;slf4j-log4j12-1.7.25.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:&#x2F;home&#x2F;lpj&#x2F;hadoop2.7&#x2F;share&#x2F;hadoop&#x2F;common&#x2F;lib&#x2F;slf4j-log4j12-1.7.10.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http:&#x2F;&#x2F;www.slf4j.org&#x2F;codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual binding is of type [org.slf4j.impl.Log4jLoggerFactory]</span><br><span class="line">HBase Shell</span><br><span class="line">Use &quot;help&quot; to get list of supported commands.</span><br><span class="line">Use &quot;exit&quot; to quit this interactive shell.</span><br><span class="line">Version 1.4.13, r38bf65a22b7e9320f07aeb27677e4533b9a77ef4, Sun Feb 23 02:06:36 PST 2020</span><br><span class="line"></span><br><span class="line">hbase(main):001:0&gt;</span><br></pre></td></tr></table></figure><p>简单操作一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; list</span><br><span class="line">TABLE</span><br><span class="line">0 row(s) in 0.2460 seconds</span><br><span class="line"></span><br><span class="line">=&gt; []</span><br><span class="line">hbase(main):002:0&gt; help</span><br><span class="line">HBase Shell, version 1.4.13, r38bf65a22b7e9320f07aeb27677e4533b9a77ef4, Sun Feb 23 02:06:36 PST 2020</span><br><span class="line">Type &#x27;help &quot;COMMAND&quot;&#x27;, (e.g. &#x27;help &quot;get&quot;&#x27; -- the quotes are necessary) for help on a specific command.</span><br><span class="line">Commands are grouped. Type &#x27;help &quot;COMMAND_GROUP&quot;&#x27;, (e.g. &#x27;help &quot;general&quot;&#x27;) for help on a command group.</span><br><span class="line"></span><br><span class="line">COMMAND GROUPS:</span><br><span class="line">  Group name: general</span><br><span class="line">  Commands: processlist, status, table_help, version, whoami</span><br><span class="line"></span><br><span class="line">  Group name: ddl</span><br><span class="line">  Commands: alter, alter_async, alter_status, create, describe, disable, disable_all, drop, drop_all, enable, enable_all, exists, get_table, is_disabled, is_enabled, list, list_regions, locate_region, show_filters</span><br><span class="line"></span><br><span class="line">  Group name: namespace</span><br><span class="line">  Commands: alter_namespace, create_namespace, describe_namespace, drop_namespace, list_namespace, list_namespace_tables</span><br><span class="line"></span><br><span class="line">  Group name: dml</span><br><span class="line">  Commands: append, count, delete, deleteall, get, get_counter, get_splits, incr, put, scan, truncate, truncate_preserve</span><br><span class="line"></span><br><span class="line">  Group name: tools</span><br><span class="line">  Commands: assign, balance_switch, balancer, balancer_enabled, catalogjanitor_enabled, catalogjanitor_run, catalogjanitor_switch, cleaner_chore_enabled, cleaner_chore_run, cleaner_chore_switch, clear_deadservers, close_region, compact, compact_rs, compaction_state, flush, is_in_maintenance_mode, list_deadservers, major_compact, merge_region, move, normalize, normalizer_enabled, normalizer_switch, split, splitormerge_enabled, splitormerge_switch, trace, unassign, wal_roll, zk_dump</span><br><span class="line"></span><br><span class="line">  Group name: replication</span><br><span class="line">  Commands: add_peer, append_peer_tableCFs, disable_peer, disable_table_replication, enable_peer, enable_table_replication, get_peer_config, list_peer_configs, list_peers, list_replicated_tables, remove_peer, remove_peer_tableCFs, set_peer_bandwidth, set_peer_tableCFs, show_peer_tableCFs, update_peer_config</span><br><span class="line"></span><br><span class="line">  Group name: snapshots</span><br><span class="line">  Commands: clone_snapshot, delete_all_snapshot, delete_snapshot, delete_table_snapshots, list_snapshots, list_table_snapshots, restore_snapshot, snapshot</span><br><span class="line"></span><br><span class="line">  Group name: configuration</span><br><span class="line">  Commands: update_all_config, update_config</span><br><span class="line"></span><br><span class="line">  Group name: quotas</span><br><span class="line">  Commands: list_quotas, set_quota</span><br><span class="line"></span><br><span class="line">  Group name: security</span><br><span class="line">  Commands: grant, list_security_capabilities, revoke, user_permission</span><br><span class="line"></span><br><span class="line">  Group name: procedures</span><br><span class="line">  Commands: abort_procedure, list_procedures</span><br><span class="line"></span><br><span class="line">  Group name: visibility labels</span><br><span class="line">  Commands: add_labels, clear_auths, get_auths, list_labels, set_auths, set_visibility</span><br><span class="line"></span><br><span class="line">  Group name: rsgroup</span><br><span class="line">  Commands: add_rsgroup, balance_rsgroup, get_rsgroup, get_server_rsgroup, get_table_rsgroup, list_rsgroups, move_servers_rsgroup, move_servers_tables_rsgroup, move_tables_rsgroup, remove_rsgroup, remove_servers_rsgroup</span><br><span class="line"></span><br><span class="line">SHELL USAGE:</span><br><span class="line">Quote all names in HBase Shell such as table and column names.  Commas delimit</span><br><span class="line">command parameters.  Type &lt;RETURN&gt; after entering a command to run it.</span><br><span class="line">Dictionaries of configuration used in the creation and alteration of tables are</span><br><span class="line">Ruby Hashes. They look like this:</span><br><span class="line"></span><br><span class="line">  &#123;&#x27;key1&#x27; =&gt; &#x27;value1&#x27;, &#x27;key2&#x27; =&gt; &#x27;value2&#x27;, ...&#125;</span><br><span class="line"></span><br><span class="line">and are opened and closed with curley-braces.  Key/values are delimited by the</span><br><span class="line">&#x27;=&gt;&#x27; character combination.  Usually keys are predefined constants such as</span><br><span class="line">NAME, VERSIONS, COMPRESSION, etc.  Constants do not need to be quoted.  Type</span><br><span class="line">&#x27;Object.constants&#x27; to see a (messy) list of all constants in the environment.</span><br><span class="line"></span><br><span class="line">If you are using binary keys or values and need to enter them in the shell, use</span><br><span class="line">double-quote&#x27;d hexadecimal representation. For example:</span><br><span class="line"></span><br><span class="line"><span class="meta">  hbase&gt;</span><span class="bash"> get <span class="string">&#x27;t1&#x27;</span>, <span class="string">&quot;key\x03\x3f\xcd&quot;</span></span></span><br><span class="line"><span class="meta">  hbase&gt;</span><span class="bash"> get <span class="string">&#x27;t1&#x27;</span>, <span class="string">&quot;key\003\023\011&quot;</span></span></span><br><span class="line"><span class="meta">  hbase&gt;</span><span class="bash"> put <span class="string">&#x27;t1&#x27;</span>, <span class="string">&quot;test\xef\xff&quot;</span>, <span class="string">&#x27;f1:&#x27;</span>, <span class="string">&quot;\x01\x33\x40&quot;</span></span></span><br><span class="line"></span><br><span class="line">The HBase shell is the (J)Ruby IRB with the above HBase-specific commands added.</span><br><span class="line">For more on the HBase Shell, see http://hbase.apache.org/book.html</span><br><span class="line">hbase(main):003:0&gt; exit</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="http://dblab.xmu.edu.cn/blog/2442-2/">林子雨HBase教程</a>（不过主要讲了单机和伪分布模式）</li><li><a href="https://blog.csdn.net/weixin_40596016/article/details/80392109">CSDN博文：Hadoop+hbase+zookeeper完全分布式搭建</a></li><li><a href="http://hbase.apache.org/book.html#config.files">Apache HBase官方文档</a>（特别是7.Default Configuration和8.Example Configurations，参考意义较大）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> HBase </tag>
            
            <tag> 安装 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper3.4.14完全分布式安装</title>
      <link href="2020/09/18/ZooKeeper_setup/"/>
      <url>2020/09/18/ZooKeeper_setup/</url>
      
        <content type="html"><![CDATA[<h1 id="ZooKeeper版本的选择与下载"><a href="#ZooKeeper版本的选择与下载" class="headerlink" title="ZooKeeper版本的选择与下载"></a>ZooKeeper版本的选择与下载</h1><p>在<a href="http://hbase.apache.org/book.html#zookeeper">HBase文档</a>里有这一句话：</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20200918173552.png" alt="QQ截图20200918173552"></p><p>然后在ZooKeeper的<a href="http://mirror.hust.edu.cn/apache/zookeeper/">下载镜像源</a>里说道：</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20200918173812.png" alt="QQ截图20200918173812"></p><p>为了求稳&amp;参照实验室前人装了3.4.14的经验，下载了<a href="http://mirror.hust.edu.cn/apache/zookeeper/zookeeper-3.4.14/">zookeeper-3.4.14.tar.gz</a>这个包。然后用MobaXterm的Sftp传到网关，再用<code>scp</code>传到Master服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp zookeeper-3.4.14.tar.gz lpj@cpu-node0:/home/lpj/</span><br></pre></td></tr></table></figure><p>解压并重命名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf zookeeper-3.4.14.tar.gz -C /home/lpj/</span><br><span class="line">mv zookeeper-3.4.14 zookeeper3.4</span><br></pre></td></tr></table></figure><h1 id="ZooKeeper配置"><a href="#ZooKeeper配置" class="headerlink" title="ZooKeeper配置"></a>ZooKeeper配置</h1><p>首先在zookeeper文件夹里新建两个文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir zkdata  # 数据</span><br><span class="line">mkdir zkdatalog  # 日志</span><br></pre></td></tr></table></figure><p>然后进入到zookeeper的conf目录下，把zoo_sample.cfg复制一份命名为zoo.cfg，用来做配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/lpj/zookeeper3.4/conf/</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure><p>修改zoo.cfg配置为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> The number of milliseconds of each tick</span></span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="meta">#</span><span class="bash"> The number of ticks that the initial</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> synchronization phase can take</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="meta">#</span><span class="bash"> The number of ticks that can pass between</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sending a request and getting an acknowledgement</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="meta">#</span><span class="bash"> the directory <span class="built_in">where</span> the snapshot is stored.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">do</span> not use /tmp <span class="keyword">for</span> storage, /tmp here is just</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> example sakes.</span></span><br><span class="line">dataDir=/home/lpj/zookeeper3.4/zkdata</span><br><span class="line"><span class="meta">#</span><span class="bash"> the port at <span class="built_in">which</span> the clients will connect</span></span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="meta">#</span><span class="bash"> the maximum number of client connections.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> increase this <span class="keyword">if</span> you need to handle more clients</span></span><br><span class="line"><span class="meta">#</span><span class="bash">maxClientCnxns=60</span></span><br><span class="line">dataLogDir=/home/lpj/zookeeper3.4/zkdatalog</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Be sure to read the maintenance section of the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The number of snapshots to retain in dataDir</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Purge task interval <span class="keyword">in</span> hours</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set to <span class="string">&quot;0&quot;</span> to <span class="built_in">disable</span> auto purge feature</span></span><br><span class="line"><span class="meta">#</span><span class="bash">autopurge.purgeInterval=1</span></span><br><span class="line">server.1=cpu-node0:2888:3888</span><br><span class="line">server.2=cpu-node3:2888:3888</span><br></pre></td></tr></table></figure><p>然后在zkdata文件夹里新建一个myid文件，对应zoo.cfg中的server的ID号，把号码写进去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>然后将整个文件夹发给slave节点（加上参数<code>-r</code>可以直接发文件夹，不用打包再解压）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r zookeeper3.4 lpj@cpu-node3:/home/lpj/</span><br></pre></td></tr></table></figure><p>然后进入zkdata修改myid，把1改为2。</p><p>最后在两台服务器上配置环境变量，修改.bashrc文件，在之前修改过的path中加入zookeeper的bin路径（两个节点都要）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/home/lpj/hadoop2.7/bin:/home/lpj/hadoop2.7/sbin:/home/lpj/hbase1.4/bin:/home/lpj/zookeeper3.4/bin</span><br></pre></td></tr></table></figure><p>并用<code>source ~/.bashrc</code>生效一下。</p><h1 id="ZooKeeper的启动与check"><a href="#ZooKeeper的启动与check" class="headerlink" title="ZooKeeper的启动与check"></a>ZooKeeper的启动与check</h1><p>由于配置了环境变量，启动命令直接用脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure><p>然后检查启动的状态使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh status</span><br></pre></td></tr></table></figure><p>然后出现错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /home/lpj/zookeeper3.4/bin/../conf/zoo.cfg</span><br><span class="line">Error contacting service. It is probably not running.</span><br></pre></td></tr></table></figure><p>去zookeeper.out检查问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-09-21 16:54:42,266 [myid:1] - WARN  [WorkerSender[myid=1]:QuorumCnxManager@584] - Cannot open channel to 2 at election address cpu-node3/192.168.232.103:3898</span><br><span class="line">java.net.ConnectException: Connection refused (Connection refused)</span><br><span class="line">at ...</span><br></pre></td></tr></table></figure><p>由于本服务器本来也是运行了一个Hadoop项目群，所以推断是端口冲突的问题，参考<a href="https://blog.csdn.net/qq_26840065/article/details/50985765">zookeeper错误记录一</a>的端口设置，修改zoo.cfg中以下几项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clientPort=3384</span><br><span class="line"></span><br><span class="line">server.1=cpu-node0:2878:3878</span><br><span class="line">server.2=cpu-node3:2898:3898</span><br></pre></td></tr></table></figure><p>两个节点中都要修改成一样的。然后再在两端分别启动<code>zkServer.sh start</code>。</p><p><strong>需要注意的是：在启动完一个节点之后用<code>status</code>参数检查依然是error状态的，因为它需要双向端口的开通，所以应该是所有节点都启动完了再去检查：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node3 ~]$ zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /home/lpj/zookeeper3.4/bin/../conf/zoo.cfg</span><br><span class="line">Mode: leader</span><br><span class="line"></span><br><span class="line">[lpj@cpu-node0 ~]$ zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /home/lpj/zookeeper3.4/bin/../conf/zoo.cfg</span><br><span class="line">Mode: follower</span><br></pre></td></tr></table></figure><p>由于server_id的设置，cpu-node3成为leader，cpu-node0成为follower。<strong>注意：它的leader和follower是根据选举制度分的，不要认为Master就是leader。</strong></p><p>用<code>jps</code>检查进程会发现多了一个<code>QuorumPeerMain</code>进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ jps</span><br><span class="line">12946 Jps</span><br><span class="line">45704 JobHistoryServer</span><br><span class="line">45002 SecondaryNameNode</span><br><span class="line">45243 ResourceManager</span><br><span class="line">44655 NameNode</span><br><span class="line">9023 QuorumPeerMain</span><br><span class="line"></span><br><span class="line">[lpj@cpu-node3 ~]$ jps</span><br><span class="line">23609 Jps</span><br><span class="line">9100 DataNode</span><br><span class="line">23292 QuorumPeerMain</span><br><span class="line">9246 NodeManager</span><br></pre></td></tr></table></figure><p>安装成功。</p><h1 id="zkCli-sh客户端的启动与试用"><a href="#zkCli-sh客户端的启动与试用" class="headerlink" title="zkCli.sh客户端的启动与试用"></a>zkCli.sh客户端的启动与试用</h1><p>从cpu-node3连去cpu-node0：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkCli.sh  -server cpu-node0:3384</span><br></pre></td></tr></table></figure><p>然后会建立出连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2020-09-21 17:22:09,608 [myid:] - INFO  [main-SendThread(cpu-node0:3384):ClientCnxn$SendThread@879] - Socket connection established to cpu-node0/192.168.232.100:3384, initiating session</span><br><span class="line">[zk: cpu-node0:3384(CONNECTING) 0] 2020-09-21 17:22:09,637 [myid:] - INFO  [main-SendThread(cpu-node0:3384):ClientCnxn$SendThread@1299] - Session establishment complete on server cpu-node0/192.168.232.100:3384, sessionid = 0x101409bf13a0001, negotiated timeout = 30000</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:None path:null</span><br></pre></td></tr></table></figure><p>按一下回车，进入终端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[zk: cpu-node0:3384(CONNECTED) 0] ls / #列出子节点信息</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: cpu-node0:3384(CONNECTED) 1] h #列出所有命令</span><br><span class="line">ZooKeeper -server host:port cmd args</span><br><span class="line">        stat path [watch]</span><br><span class="line">        set path data [version]</span><br><span class="line">        ls path [watch]</span><br><span class="line">        delquota [-n|-b] path</span><br><span class="line">        ls2 path [watch]</span><br><span class="line">        setAcl path acl</span><br><span class="line">        setquota -n|-b val path</span><br><span class="line">        history</span><br><span class="line">        redo cmdno</span><br><span class="line">        printwatches on|off</span><br><span class="line">        delete path [version]</span><br><span class="line">        sync path</span><br><span class="line">        listquota path</span><br><span class="line">        rmr path</span><br><span class="line">        get path [watch]</span><br><span class="line">        create [-s] [-e] path data acl</span><br><span class="line">        addauth scheme auth</span><br><span class="line">        quit</span><br><span class="line">        getAcl path</span><br><span class="line">        close</span><br><span class="line">        connect host:port</span><br></pre></td></tr></table></figure><p><code>exit</code>命令，用<code>quit</code>命令进行退出客户端。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 安装 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大数据技术原理与应用》学习笔记——Ch3：分布式文件系统HDFS</title>
      <link href="2020/09/12/BigData_Ch3_HDFS/"/>
      <url>2020/09/12/BigData_Ch3_HDFS/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>本文为<a href="https://www.icourse163.org/course/XMU-1002335004?tid=1450180443">《大数据技术原理与应用》</a>第三章学习笔记。</p><p>HDFS编程实践<a href="http://dblab.xmu.edu.cn/blog/2460-2/">参考教程</a></p><h1 id="HDFS简介"><a href="#HDFS简介" class="headerlink" title="HDFS简介"></a>HDFS简介</h1><p>Hadoop分布式文件系统（Hadoop Distributed File System，HDFS），大数据平台两大核心技术之一，为了解决海量数据的分布式存储问题。</p><h2 id="计算机集群结构"><a href="#计算机集群结构" class="headerlink" title="计算机集群结构"></a>计算机集群结构</h2><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20200912171219.png" alt="QQ截图20200912171219"></p><h2 id="分布式文件系统的结构"><a href="#分布式文件系统的结构" class="headerlink" title="分布式文件系统的结构"></a>分布式文件系统的结构</h2><p>分布式文件系统在物理结构上是由计算机集群中的多个节点构成的，这些节点分为两类，一类叫“主节点”(Master Node)或者也被称为“名称结点”(NameNode)，另 一类叫“从节点”（Slave Node）或者也被称为“数据节点”(DataNode)。</p><p><img src="http://img.cuper.top/bigdata_G%60W_25CG%7DX6E@LR%7B]8NS1X.png"></p><p>主节点：数据目录（元数据）服务。负责文件和目录的创建、删除和重命名等，同时管理数据节点和文件块的映射关系。</p><p>从节点：完成数据存储任务。负责数据的存储和读取。</p><ul><li>存储：由NameNode分配存储位置，然后由客户端把数据直接写入相应DataNode。</li><li>读取：客户端从NameNode中获得数据节点和文件块的映射关系，然后到相应位置访问文件块。</li></ul><p>通常采用多副本存储：文件块被复制为多个副本存储在不同节点上，且存储同一文件块的不同副本的各个节点分布在不同机架上。</p><p>HDFS实现目标：</p><ul><li><p>兼容廉价的硬件设备</p></li><li><p>流数据读写</p></li><li><p>大数据集</p></li><li><p>简单的文件模型</p></li><li><p>强大的跨平台兼容性</p></li></ul><p>局限性：</p><ul><li>不适合低延迟数据访问（高吞吐率、高延迟，低时延需要用到HBase）</li><li>无法高效存储大量小文件（大小小于一个块的文件）</li><li>不支持多用户写入及任意修改文件（一个文件只允许一个写入者，对文件仅允许追加操作）</li></ul><h1 id="HDFS的相关概念"><a href="#HDFS的相关概念" class="headerlink" title="HDFS的相关概念"></a>HDFS的相关概念</h1><h2 id="块"><a href="#块" class="headerlink" title="块"></a>块</h2><p>HDFS默认一个块64MB，一个文件被分成多个块，以块作为存储单位</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20200912191323.png" alt="QQ截图20200912191323"></p><p>设计目的：</p><ul><li><p>支持面向大规模数据存储</p></li><li><p>降低分布式节点的寻址开销</p></li></ul><p>缺点：块过大会牺牲MapReduce的并行度</p><p>HDFS采用抽象的块概念的好处：</p><ul><li>支持大规模文件存储</li><li>简化系统设计</li><li>适合数据备份</li></ul><h2 id="名称节点和数据节点"><a href="#名称节点和数据节点" class="headerlink" title="名称节点和数据节点"></a>名称节点和数据节点</h2><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20200912193622.png" alt="QQ截图20200912193622"></p><table><thead><tr><th>NameNode</th><th align="left">DataNode</th></tr></thead><tbody><tr><td>存储元数据</td><td align="left">存储文件内容</td></tr><tr><td>元数据保存在内存中</td><td align="left">文件内容保存在磁盘中</td></tr><tr><td>保存文件，block，datanode之间的映射关系</td><td align="left">维护了block id到datanode本地文件的映射关系</td></tr></tbody></table><p>NameNode记录的元数据记录的信息（数据目录的作用）：</p><ul><li>文件是什么</li><li>文件被分成多少块</li><li>每个块和文件是怎么映射的</li><li>每个块被存储在哪个服务器上面</li></ul><h3 id="NameNode的数据结构"><a href="#NameNode的数据结构" class="headerlink" title="NameNode的数据结构"></a>NameNode的数据结构</h3><p>两个核心的数据结构：</p><ul><li>FsImage：包含文件系统中所有目录和文件inode的序列化形式。每个inode是一 个文件或目录的元数据的内部表示，并包含此类信息：文件的复制等级、修改和访问时间、访问权限、块大小以及组成文件的块。（<strong>FsImage文件没有记录块存储在哪个数据节点。而是由名称节点把这些映射保留在内存中，当数据节点加入HDFS集群时，数据节点会把自己所包含的块列表告知给名称节点，此后会定期执行这种告知操作，以确保名称节点的块映射是最新的。</strong>）</li><li>EditLog：记录所有针对文件的创建、删除、重命名等操作。</li></ul><h3 id="NameNode的启动"><a href="#NameNode的启动" class="headerlink" title="NameNode的启动"></a>NameNode的启动</h3><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20200912201244.png" alt="QQ截图20200912201244"></p><ul><li>在名称节点启动的时候，它会将FsImage文件中的内容加载到内存中，之后再执行EditLog文件中的各项操作，使得内存中的元数据和实际的同步，<strong>保持最新</strong>，存在内存中的元数据支持客户端的读操作。</li><li>一旦在内存中成功建立文件系统元数据的映射，则创建一个新的FsImage文件和一个空的EditLog文件。</li><li>（<strong>为什么不只用一个FsImage的原因</strong>）名称节点启动之后，HDFS中的更新操作会重新写到EditLog文件中，因为FsImage文件一般都很大（GB级别的很常见），如果所有的更新操作都往FsImage文件中添加，这样会导致系统运行的十分缓慢，但是，如果往EditLog文件里面写就不会这样，因为EditLog 要小很多。每次执行写操作之后，且在向客户端发送成功代码之前，edits文件都需要同步更新。</li><li>NameNode在启动过程中会处于“安全模式”，只能对外提供读操作，无法提供写操作。启动过程结束后，系统退出安全模式。</li></ul><h3 id="SecondaryNameNode（第二名称节点）"><a href="#SecondaryNameNode（第二名称节点）" class="headerlink" title="SecondaryNameNode（第二名称节点）"></a>SecondaryNameNode（第二名称节点）</h3><p>解决名称节点运行期间EditLog不断变大的问题：对名称节点运行时候是没有什么明显影响的，但是当名称节点重启的时候，名称节点需要先将FsImage里面的所有内容映像到内存中，然后再一条一条地执行EditLog中的记录，当 EditLog文件非常大的时候，会导致名称节点启动操作非常慢。</p><p><strong>SecondaryNameNode</strong>：用来保存名称节点中对HDFS元数据信息的冷备份，并减少名称节点重启的时间，一般单独运行在一台机器上。</p><p>功能：</p><ul><li>完成EditLog和FsImage的合并操作，减少EditLog文件大小，缩短NameNode重启时间；</li><li>作为NameNode的“检查点”，保存NameNode中的元数据信息。</li></ul><p>工作机制：</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20200912202333.png" alt="QQ截图20200912202333"></p><ul><li>SecondaryNameNode会定期和NameNode通信，请求其停止使用EditLog文件，暂时将新的写操作写到一个新的文件edit.new上来，这个操作是瞬间完成，上层写日志的函数完全感觉不到差别；</li><li>SecondaryNameNode通过HTTP GET方式从NameNode上获取到FsImage和EditLog文件，并下载到本地的相应目录下；</li><li>SecondaryNameNode将下载下来的FsImage载入到内存，然后一条一条地执行EditLog文件中的各项更新操作，使得内存中的FsImage保持最新；这个过程就是EditLog和FsImage文件合并；</li><li>SecondaryNameNode合并后通过post方式将新的FsImage文件发送到NameNode节点上；</li><li>NameNode将从SecondaryNameNode接收到的新的FsImage替换旧的FsImage文件，同时将edit.new替换EditLog文件，通过这个过程EditLog就变小了。</li></ul><h3 id="DataNode（数据节点）"><a href="#DataNode（数据节点）" class="headerlink" title="DataNode（数据节点）"></a>DataNode（数据节点）</h3><p>数据节点是分布式文件系统HDFS的工作节点，负责数据的存储和读取，会根据客户端或者是名称节点的调度来进行数据的存储和检索，并且向名称节点定期发送自己所存储的块的列表。</p><p><strong>每个数据节点中的数据会被保存在各自节点的本地Linux文件系统中。</strong></p><h1 id="HDFS体系结构"><a href="#HDFS体系结构" class="headerlink" title="HDFS体系结构"></a>HDFS体系结构</h1><h2 id="体系概述"><a href="#体系概述" class="headerlink" title="体系概述"></a>体系概述</h2><p>HDFS采用了主从（Master/Slave）结构模型，一个HDFS集群包括一个名称节点（ NameNode）和若干个数据节点（DataNode）。</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20200913134555.png" alt="QQ截图20200913134555"></p><p>名称节点作为中心服务器，负责管理文件系统的命名空间及客户端对文件的访问。</p><p>集群中的数据节点一般是一个节点运行 一个数据节点进程，负责处理文件系统客户端的读/写请求，在名称节点的统一调度下进行数据块的创建、删除和复制等操作。</p><h2 id="HDFS命名空间"><a href="#HDFS命名空间" class="headerlink" title="HDFS命名空间"></a>HDFS命名空间</h2><p>HDFS的命名空间包含目录、文件和块。</p><p>在HDFS1.0体系结构中，在整个HDFS集群中只有一个命名空间，并且只有唯一一个名称节点，该节点负责对这个命名空间进行管理。</p><p><strong>HDFS使用的是传统的分级文件体系。</strong>用户可以像使用普通文件系统一样，创建、删除目录和文件，在目录间转移文件，重命名文件等，但还没有实现文件访问权限、硬连接和软连接等功能。</p><h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><p>所有的HDFS通信协议都是构建在TCP/IP协议基础之上的。</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20200913135312.png" alt="QQ截图20200913135312"></p><ul><li><p>客户端通过一个可配置的端口向名称节点主动发起TCP连接，并使用客户端协议与名称节点进行交互。</p></li><li><p>名称节点和数据节点之间则使用数据节点协议进行交互。</p></li><li><p>客户端与数据节点的交互是通过RPC（Remote Procedure Call）来实现的。名称节点不会主动发起RPC，而是响应来自客户端和数据节点的RPC请求。</p></li></ul><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端是用户操作HDFS最常用的方式，HDFS在部署时都提供了客户端。HDFS客户端是一个库，暴露了HDFS文件系统接口。</p><p><strong>严格来说，客户端并不算是HDFS的一部分。</strong></p><ul><li>提供类似Shell的命令行方式：访问HDFS中的数据客户端，支持打开、读取、写入等常见的操作</li><li>提供了Java API：应用程序访问文件系统的客户端编程接口</li></ul><h2 id="HDFS体系结构的局限性"><a href="#HDFS体系结构的局限性" class="headerlink" title="HDFS体系结构的局限性"></a>HDFS体系结构的局限性</h2><p>原因：只设置唯一一个名称节点</p><ul><li>命名空间的限制</li><li>性能的瓶颈</li><li>隔离问题</li><li>集群的可用性（单点故障问题）</li></ul><p>SecondaryNameNode无法解决单点故障问题的原因：冷备份不是热备份（HDFS1.0的缺陷，在2.0中已经得到解决）</p><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20200913135841.png" alt="QQ截图20200913135841"></p><h1 id="HDFS的存储原理"><a href="#HDFS的存储原理" class="headerlink" title="HDFS的存储原理"></a>HDFS的存储原理</h1><h2 id="冗余数据保存"><a href="#冗余数据保存" class="headerlink" title="冗余数据保存"></a>冗余数据保存</h2><p>通常一个数据块的多个副本会被分布到不同的数据节点 上（默认值为3），优点：</p><ul><li>加快数据传输速度</li><li>容易检查数据错误（互为备份，互为参照）</li><li>保证数据可靠性（冗余副本低于用户设定值，自动复制生成新副本）</li></ul><h2 id="数据存取策略"><a href="#数据存取策略" class="headerlink" title="数据存取策略"></a>数据存取策略</h2><h3 id="数据存放"><a href="#数据存放" class="headerlink" title="数据存放"></a>数据存放</h3><p>一个HDFS集群通常包含多个机架，不同机架之间的数据通信通常需要经过交换机和路由器，同一个机架上的不同机器之间的通信则不需要。<strong>默认冗余复制因子是3。</strong></p><ul><li>第一个副本：放置在上传文件的数据节点；如果是集群外提交，则随机挑选一台磁盘不太满、CPU不太忙的节点</li><li>第二个副本：放置在与第一个副本不同的机架的节点上</li><li>第三个副本：与第一个副本相同机架的其他节点上</li><li>更多副本：随机节点</li></ul><h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><ul><li>HDFS提供了一个API可以确定一个数据节点所属的机架ID，客户端也可以调用API获取自己所属的机架ID。</li><li>当客户端读取数据时，从名称节点获得数据块不同副本的存放位置列表，列表中包含了副本所在的数据节点，可以调用API来确定客户端和这些数据节点所属的机架ID，当发现某个数据块副本对应的机架ID和客户端对应的机架ID相同时，就优先选择该副本读取数据，如果没有发现，就随机选择一个副本读取数据。</li></ul><h3 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h3><p>流水线复制的策略</p><h2 id="数据错误与恢复"><a href="#数据错误与恢复" class="headerlink" title="数据错误与恢复"></a>数据错误与恢复</h2><p>HDFS把硬件出错看作一种常态，而不是异常，并设计了相应的机制检测数据错误和进行自动恢复。</p><h3 id="NameNode出错"><a href="#NameNode出错" class="headerlink" title="NameNode出错"></a>NameNode出错</h3><p>最核心的两大数据结构FsImage和Editlog发生损坏，那么整个HDFS实例将失效。</p><p>HDFS1.0：暂停服务一段时间，SecondaryNameNode冷备份恢复。</p><p>HDFS2.0以后：热备份马上恢复。</p><h3 id="DataNode出错"><a href="#DataNode出错" class="headerlink" title="DataNode出错"></a>DataNode出错</h3><p>每个数据节点会定期向名称节点发送“心跳”信息，向名称节点报告自己的状态。</p><p>当数据节点发生故障，或者网络发生断网时，名称节点就无法收到来自一些数据节点的心跳信息，这时，这些数据节点就会被标记为“宕机”，节点上面的所有数据都会被标记为“不可读”，名称节点不会再给它们发送任何I/O请求。</p><p>名称节点会定期检查副本数量，一旦发现某个数据块的副本数量小于冗余因子，就会启动数据冗余复制，为它生成新的副本。</p><p><strong>HDFS和其它分布式文件系统的最大区别就是可以调整冗余数据的位置（发生负载不均衡的时候同样可以调整）。</strong></p><h3 id="数据出错"><a href="#数据出错" class="headerlink" title="数据出错"></a>数据出错</h3><p>检验数据出错：客户端在读取到数据后，会采用md5和sha1对数据块进行校验，以确定读取到正确的数据。</p><p>如果校验出错，客户端就会请求到另外一个数据节点读取该文件块，并且向名称节点报告这个文件块有错误，名称节点会定期检查并且重新复制这个块。</p><h1 id="HDFS的数据读写过程"><a href="#HDFS的数据读写过程" class="headerlink" title="HDFS的数据读写过程"></a>HDFS的数据读写过程</h1><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>读取文件代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader ;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration ;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem ;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path ;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FSDataInputStream ;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chapter3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">FileSystem fs = FileSystem.get(conf);</span><br><span class="line">Path filename = <span class="keyword">new</span> Path(“hdfs:<span class="comment">//localhost:9000/user/hadoop/test.txt&quot;);</span></span><br><span class="line">FSDataInputStream is = fs.open(filename);</span><br><span class="line">BufferedReader d = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">String content = d.readLine(); <span class="comment">//读取文件一行</span></span><br><span class="line">System.out.println(content);</span><br><span class="line">d.close(); <span class="comment">//关闭文件</span></span><br><span class="line">fs.close(); <span class="comment">//关闭hdfs</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入文件代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FSDataOutputStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chapter3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">FileSystem fs = FileSystem.get(conf);</span><br><span class="line"><span class="keyword">byte</span>[] buff = <span class="string">&quot;Hello world&quot;</span>.getBytes(); <span class="comment">// 要写入的内容</span></span><br><span class="line">String filename = <span class="string">&quot; hdfs://localhost:9000/user/hadoop/test.txt &quot;</span>; <span class="comment">//要写入的文件名</span></span><br><span class="line">FSDataOutputStream os = fs.create(<span class="keyword">new</span> Path(filename));</span><br><span class="line">os.write(buff,<span class="number">0</span>,buff.length);</span><br><span class="line">System.out.println(<span class="string">&quot;Create:&quot;</span>+ filename);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取过程"><a href="#读取过程" class="headerlink" title="读取过程"></a>读取过程</h2><p>相关的类：</p><p><img src="http://img.cuper.top/bigdataQQ%E5%9B%BE%E7%89%8720200917180244.png" alt="QQ图片20200917180244"></p><ul><li>FileSystem是一个通用文件系统的抽象基类，可以被分布式文件系统继承，所有可能使用Hadoop文件系统的代码，都要使用这个类。</li><li>DistributedFileSystem是FileSystem在HDFS文件系统中的具体实现。</li><li>FileSystem的open()方法返回的是一个输入流FSDataInputStream对象，在HDFS文件系统中具体的输入流为DFSInputStream；FileSystem中的create()方法返回的是一个输出流FSDataOutputStream对象，在HDFS文件系统具体的输出流为DFSOutputStream。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configuration conf = <span class="keyword">new</span> Configuration(); <span class="comment">//创建一个Configuration对象时，其构造方法会默认加载工程项目下两个配置文件：hdfs-site.xml和core-site.xml，这两个文件中包含访问HDFS所需的参数值（主要是fs.defaultFS，指定了HDFS的地址，有了这个地址客户端就可以通过这个地址访问HDFS了）</span></span><br></pre></td></tr></table></figure><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20200917181634.png" alt="QQ截图20200917181634"></p><blockquote><p>在读取数据过程中，若客户端与DataNode通信时出现错误，就会尝试连接包含此数据块的下一个DataNode。</p></blockquote><h2 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h2><p><img src="http://img.cuper.top/bigdataQQ%E6%88%AA%E5%9B%BE20200918104302.png" alt="QQ截图20200918104302"></p><p><em>写入文件采用流水线复制策略，最终在每个DataNode中的数据内容都是一样的</em>。</p><h1 id="HDFS编程实践"><a href="#HDFS编程实践" class="headerlink" title="HDFS编程实践"></a>HDFS编程实践</h1><blockquote><p>实际上有三种shell命令方式：</p><p>1.hadoop fs<br>2.hadoop dfs<br>3.hdfs dfs</p><p>hadoop fs适用于任何不同的文件系统，比如本地文件系统和HDFS文件系统<br>hadoop dfs只能适用于HDFS文件系统<br>hdfs dfs跟hadoop dfs的命令作用一样，也只能适用于HDFS文件系统</p></blockquote><p>统一格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs [genericOptions] [commandOptions]</span><br></pre></td></tr></table></figure><p>全部命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ hadoop fs</span><br><span class="line">Usage: hadoop fs [generic options]</span><br><span class="line">        [-appendToFile &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">        [-cat [-ignoreCrc] &lt;src&gt; ...]</span><br><span class="line">        [-checksum &lt;src&gt; ...]</span><br><span class="line">        [-chgrp [-R] GROUP PATH...]</span><br><span class="line">        [-chmod [-R] &lt;MODE[,MODE]... | OCTALMODE&gt; PATH...]</span><br><span class="line">        [-chown [-R] [OWNER][:[GROUP]] PATH...]</span><br><span class="line">        [-copyFromLocal [-f] [-p] [-l] &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">        [-copyToLocal [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;]</span><br><span class="line">        [-count [-q] [-h] &lt;path&gt; ...]</span><br><span class="line">        [-cp [-f] [-p | -p[topax]] &lt;src&gt; ... &lt;dst&gt;]</span><br><span class="line">        [-createSnapshot &lt;snapshotDir&gt; [&lt;snapshotName&gt;]]</span><br><span class="line">        [-deleteSnapshot &lt;snapshotDir&gt; &lt;snapshotName&gt;]</span><br><span class="line">        [-df [-h] [&lt;path&gt; ...]]</span><br><span class="line">        [-du [-s] [-h] &lt;path&gt; ...]</span><br><span class="line">        [-expunge]</span><br><span class="line">        [-find &lt;path&gt; ... &lt;expression&gt; ...]</span><br><span class="line">        [-get [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;]</span><br><span class="line">        [-getfacl [-R] &lt;path&gt;]</span><br><span class="line">        [-getfattr [-R] &#123;-n name | -d&#125; [-e en] &lt;path&gt;]</span><br><span class="line">        [-getmerge [-nl] &lt;src&gt; &lt;localdst&gt;]</span><br><span class="line">        [-help [cmd ...]]</span><br><span class="line">        [-ls [-d] [-h] [-R] [&lt;path&gt; ...]]</span><br><span class="line">        [-mkdir [-p] &lt;path&gt; ...]</span><br><span class="line">        [-moveFromLocal &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">        [-moveToLocal &lt;src&gt; &lt;localdst&gt;]</span><br><span class="line">        [-mv &lt;src&gt; ... &lt;dst&gt;]</span><br><span class="line">        [-put [-f] [-p] [-l] &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">        [-renameSnapshot &lt;snapshotDir&gt; &lt;oldName&gt; &lt;newName&gt;]</span><br><span class="line">        [-rm [-f] [-r|-R] [-skipTrash] &lt;src&gt; ...]</span><br><span class="line">        [-rmdir [--ignore-fail-on-non-empty] &lt;dir&gt; ...]</span><br><span class="line">        [-setfacl [-R] [&#123;-b|-k&#125; &#123;-m|-x &lt;acl_spec&gt;&#125; &lt;path&gt;]|[--set &lt;acl_spec&gt; &lt;path&gt;]]</span><br><span class="line">        [-setfattr &#123;-n name [-v value] | -x name&#125; &lt;path&gt;]</span><br><span class="line">        [-setrep [-R] [-w] &lt;rep&gt; &lt;path&gt; ...]</span><br><span class="line">        [-stat [format] &lt;path&gt; ...]</span><br><span class="line">        [-tail [-f] &lt;file&gt;]</span><br><span class="line">        [-test -[defsz] &lt;path&gt;]</span><br><span class="line">        [-text [-ignoreCrc] &lt;src&gt; ...]</span><br><span class="line">        [-touchz &lt;path&gt; ...]</span><br><span class="line">        [-truncate [-w] &lt;length&gt; &lt;path&gt; ...]</span><br><span class="line">        [-usage [cmd ...]]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> MOOC笔记 </tag>
            
            <tag> HDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop2.7.7完全分布式安装：1台Master+1台Slave</title>
      <link href="2020/09/07/Hadoop2.7.7_real_setup/"/>
      <url>2020/09/07/Hadoop2.7.7_real_setup/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>进入实验室后有了更多可用服务器的条件，参照<a href="http://dblab.xmu.edu.cn/blog/2775-2/">Hadoop集群安装配置教程_Hadoop3.1.3_Ubuntu</a>进行了一下真正的Hadoop集群的安装部署。基本步骤参照教程，但基于自己实验室里条件有不少改动的地方。</p><p><strong>首先基于实验室原有Hadoop平台，把实验对象从Hadoop3.1.3改成了Hadoop2.7.7。</strong></p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>摘抄自林子雨老师的教程：</p><blockquote><p>当Hadoop采用分布式模式部署和运行时，存储采用分布式文件系统HDFS，而且，HDFS的名称节点和数据节点位于不同机器上。这时，数据就可以分布到多个节点上，不同数据节点上的数据计算可以并行执行，这时的MapReduce分布式计算能力才能真正发挥作用。<br>为了降低分布式模式部署难度，本教程简单使用两个节点（两台物理机器）来搭建集群环境，一台机器作为 Master节点，局域网IP地址为x.x.x.x，另一台机器作为 Slave 节点，局域网 IP 地址为x.x.x.y。由三个以上节点构成的集群，也可以采用类似的方法完成安装部署。<br>Hadoop 集群的安装配置大致包括以下步骤：<br>（1）步骤1：选定一台机器作为 Master；<br>（2）步骤2：在Master节点上创建hadoop用户、安装SSH服务端、安装Java环境；<br>（3）步骤3：在Master节点上安装Hadoop，并完成配置；<br>（4）步骤4：在其他Slave节点上创建hadoop用户、安装SSH服务端、安装Java环境；<br>（5）步骤5：将Master节点上的“/usr/local/hadoop”目录复制到其他Slave节点上；<br>（6）步骤6：在Master节点上开启Hadoop；</p></blockquote><h1 id="实验室服务器环境"><a href="#实验室服务器环境" class="headerlink" title="实验室服务器环境"></a>实验室服务器环境</h1><p>通过教育网可以用ssh登陆进入实验室服务器的网关（gateway），管理员给我创建了一个“lpj”的账号并设置登陆密码，给了我网关的IP号即可通过<code>ssh lpj@x.x.x.x</code>连接。在gateway中有/home/lpj这个文件夹，这里的gateway就相当于一台装有Ubuntu系统的电脑，只不过是通过ssh远程连接。这里我的PC机端是在Windows10系统中用<a href="https://mobaxterm.mobatek.net/">MobaXterm</a>软件进行ssh连接，还挺好用的。连接成功后终端变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lpj@gateway ~]$</span><br></pre></td></tr></table></figure><p>查看/etc/hostname文件内容就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gateway</span><br></pre></td></tr></table></figure><p>然后在网关中可以用ssh直接连接服务器结点，但是也需要管理员在服务器结点中给我创建我的账号。由于Hadoop集群需要至少两个服务器结点（两个不同的IP地址），所以管理员在两个CPU服务器中给我新建了“lpj”账号。现在相当于我又拿到了两台装有Ubuntu系统的电脑，然后通过lpj这个账号登陆进去，每个服务器中都有/home/lpj这个文件夹。由于实验室配置文件比较成熟，直觉已经设定好了主机名：直接去查看每个服务器上的/etc/hosts文件，两个服务器的配置均有以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost</span><br><span class="line"></span><br><span class="line">192.168.232.100cpu-node0</span><br><span class="line">192.168.232.103cpu-node3</span><br></pre></td></tr></table></figure><p>再查看/etc/hostname：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpu-node0</span><br><span class="line"></span><br><span class="line">cpu-node3</span><br></pre></td></tr></table></figure><p>其中cpu-node0和cpu-node3就是实验室分配给我的两台服务器，在这里就先定义cpu-node0为Matser，cpu-node3为Slave（不改hosts文件里的名字了，一是没必要二也没root权限）。在网关里通过<code>ssh cpu-node0</code>和<code>ssh cpu-node3</code>即可连接进这两个服务器，然后我的终端就分别变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$</span><br><span class="line"></span><br><span class="line">[lpj@cpu-node3 ~]$</span><br></pre></td></tr></table></figure><p>然后测试一下是否相互ping得通：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ ping cpu-node3 -c 3</span><br><span class="line">PING cpu-node3 (192.168.232.103) 56(84) bytes of data.</span><br><span class="line">64 bytes from cpu-node3 (192.168.232.103): icmp_seq=1 ttl=64 time=0.289 ms</span><br><span class="line">64 bytes from cpu-node3 (192.168.232.103): icmp_seq=2 ttl=64 time=0.274 ms</span><br><span class="line">64 bytes from cpu-node3 (192.168.232.103): icmp_seq=3 ttl=64 time=0.253 ms</span><br><span class="line"></span><br><span class="line">--- cpu-node3 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2000ms</span><br><span class="line">rtt min/avg/max/mdev = 0.253/0.272/0.289/0.014 ms</span><br><span class="line"></span><br><span class="line">[lpj@cpu-node3 ~]$ ping cpu-node0 -c 3</span><br><span class="line">PING cpu-node0 (192.168.232.100) 56(84) bytes of data.</span><br><span class="line">64 bytes from cpu-node0 (192.168.232.100): icmp_seq=1 ttl=64 time=0.347 ms</span><br><span class="line">64 bytes from cpu-node0 (192.168.232.100): icmp_seq=2 ttl=64 time=0.324 ms</span><br><span class="line">64 bytes from cpu-node0 (192.168.232.100): icmp_seq=3 ttl=64 time=0.255 ms</span><br><span class="line"></span><br><span class="line">--- cpu-node0 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2000ms</span><br><span class="line">rtt min/avg/max/mdev = 0.255/0.308/0.347/0.044 ms</span><br></pre></td></tr></table></figure><p>至此，网络配置在实验室环境本已设置好的情况下检验完毕。</p><h1 id="SSH无密码登录节点"><a href="#SSH无密码登录节点" class="headerlink" title="SSH无密码登录节点"></a>SSH无密码登录节点</h1><p>让Master节点可以SSH无密码登录到各个Slave节点上。首先，生成Master节点的公匙。由于我的账户是新建的，没有生成过公钥，则无需删除。但我已有一个空的ssh文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 .ssh]$ ls -a</span><br><span class="line">.  ..</span><br></pre></td></tr></table></figure><p>于是直接进入ssh文件夹生成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ssh-keygen -t rsa       # 执行该命令后，遇到提示信息，一直按回车就可以</span><br></pre></td></tr></table></figure><p>完成后生成了两个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 .ssh]$ ls -a</span><br><span class="line">.  ..  id_rsa  id_rsa.pub</span><br></pre></td></tr></table></figure><p>这里有一条命令可以直接把cpu-node0的公钥文件传到cpu-node3并生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i /home/lpj/.ssh/id_rsa.pub lpj@cpu-node3</span><br></pre></td></tr></table></figure><p>其中需要输一次密码，然后加入成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 .ssh]$ ssh-copy-id -i /home/lpj/.ssh/id_rsa.pub lpj@cpu-node3</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/home/lpj/.ssh/id_rsa.pub&quot;</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">lpj@cpu-node3&#x27;s password:</span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh &#x27;lpj@cpu-node3&#x27;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure><p>测试一下，免密成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 .ssh]$ ssh cpu-node3</span><br><span class="line">Last login: Tue Sep  8 13:51:48 2020 from cpu-node0</span><br><span class="line">[lpj@cpu-node3 ~]$</span><br></pre></td></tr></table></figure><p><strong>注：这里要重复cpu-node3对cpu-node0、cpu-node0对cpu-node0的免密操作，不然最后启动结点时会denied！</strong></p><h1 id="Hadoop的本地安装"><a href="#Hadoop的本地安装" class="headerlink" title="Hadoop的本地安装"></a>Hadoop的本地安装</h1><p>这里参照了<a href="http://blog.cuper.top/2020/07/21/Hadoop3.1.3_setup/">Hadoop3.1.3安装教程：单机&amp;伪分布式配置</a>的步骤，首先需要把下载下来的<a href="http://mirror.hust.edu.cn/apache/hadoop/common/hadoop-2.7.7/">hadoop-2.7.7.tar.gz</a>传到服务器上。在这里，第一步先用MobaXterm的传文件功能把hadoop-2.7.7.tar.gz从自己的PC机传到gateway里，然后查看一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lpj@gateway ~]$ ls -a</span><br><span class="line">.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .cache  .config  hadoop-2.7.7.tar.gz  .local  .mozilla  .ssh  .Xauthority</span><br></pre></td></tr></table></figure><p>接下来需要用<code>scp hadoop-2.7.7.tar.gz lpj@cpu-node0:/home/lpj/</code>从网关传到主节点Master的服务器中（<strong>在配置好之后再打包发给Slave</strong>）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ ls -a</span><br><span class="line">.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .cache  .config  .local  .mozilla  .ssh</span><br><span class="line">[lpj@cpu-node0 ~]$ exit</span><br><span class="line">logout</span><br><span class="line">Connection to cpu-node0 closed.</span><br><span class="line">[lpj@gateway ~]$ scp hadoop-2.7.7.tar.gz lpj@cpu-node0:/home/lpj/</span><br><span class="line">lpj@cpu-node0&#x27;s password:</span><br><span class="line">hadoop-2.7.7.tar.gz                                                                                                         100%  322MB   6.6MB/s   00:49</span><br><span class="line">[lpj@gateway ~]$ ssh cpu-node0</span><br><span class="line">lpj@cpu-node0&#x27;s password:</span><br><span class="line">Last login: Tue Sep  8 10:49:09 2020 from gateway</span><br><span class="line">[lpj@cpu-node0 ~]$ ls -a</span><br><span class="line">.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .cache  .config  hadoop-2.7.7.tar.gz  .local  .mozilla  .ssh</span><br></pre></td></tr></table></figure><p>然后就地解压并重命名（我没有root就不解压进usr/local了）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf hadoop-2.7.7.tar.gz -C &#x2F;home&#x2F;lpj</span><br><span class="line">mv .&#x2F;hadoop-2.7.7&#x2F; .&#x2F;hadoop2.7</span><br></pre></td></tr></table></figure><p>另外由于我的账户是新建的，需要配置一下JAVA_HOME环境变量，在.bashrc里加入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><p>令其生效并测试一下版本号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ source ~/.bashrc</span><br><span class="line">[lpj@cpu-node0 ~]$ java -version</span><br><span class="line">openjdk version &quot;1.8.0_212&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_212-b04)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.212-b04, mixed mode)</span><br></pre></td></tr></table></figure><p><strong>配置JAVA环境需要在Slave中也完成该操作。</strong></p><p>然后再进入hadoop文件夹里测试hadoop的版本号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 hadoop]$ ./bin/hadoop version</span><br><span class="line">Hadoop 2.7.7</span><br><span class="line">Subversion Unknown -r c1aad84bd27cd79c3d1a7dd58202a8c3ee1ed3ac</span><br><span class="line">Compiled by stevel on 2018-07-18T22:47Z</span><br><span class="line">Compiled with protoc 2.5.0</span><br><span class="line">From source with checksum 792e15d20b12c74bd6f19a1fb886490</span><br><span class="line">This command was run using /home/lpj/hadoop2.7/share/hadoop/common/hadoop-common-2.7.7.jar</span><br></pre></td></tr></table></figure><p>默认的非分布式模式（本地模式）即安装成功了，无需进行其他配置即可运行。需要注意的是两个服务器中都需要进行以上步骤，分别完成自己本地模式的Hadoop安装。</p><p>此外，为了可以在任意目录中直接使用hadoop、hdfs等命令了，可以配置PATH变量。在Master节点（cpu-node0）上进行配置，在.bashrc文件最上面的位置加入下面一行内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/home/lpj/hadoop2.7/bin:/home/lpj/hadoop2.7/sbin</span><br></pre></td></tr></table></figure><p>然后用hadoop命令测试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ hadoop version</span><br><span class="line">Hadoop 2.7.7</span><br><span class="line">Subversion Unknown -r c1aad84bd27cd79c3d1a7dd58202a8c3ee1ed3ac</span><br><span class="line">Compiled by stevel on 2018-07-18T22:47Z</span><br><span class="line">Compiled with protoc 2.5.0</span><br><span class="line">From source with checksum 792e15d20b12c74bd6f19a1fb886490</span><br><span class="line">This command was run using /home/lpj/hadoop2.7/share/hadoop/common/hadoop-common-2.7.7.jar</span><br></pre></td></tr></table></figure><h1 id="配置集群-分布式环境"><a href="#配置集群-分布式环境" class="headerlink" title="配置集群/分布式环境"></a>配置集群/分布式环境</h1><p>在配置集群/分布式模式时，需要修改/hadoop2.7/etc/hadoop目录下的配置文件，这里仅设置正常启动所必须的设置项，包括slaves 、core-site.xml、hdfs-site.xml、mapred-site.xml、yarn-site.xml共5个文件，更多设置项以后再说吧。</p><h2 id="修改文件slaves"><a href="#修改文件slaves" class="headerlink" title="修改文件slaves"></a>修改文件slaves</h2><p>需要把所有数据节点（datanode）的主机名写入该文件，每行一个，默认为 localhost（即把本机作为数据节点），所以，在伪分布式配置时，就采用了这种默认的配置，使得节点既作为名称节点（namenode）也作为数据节点。在进行分布式配置时，可以保留localhost，让Master节点同时充当名称节点和数据节点，或者也可以删掉localhost这行，让Master节点仅作为名称节点使用。</p><p>本次安装让Master节点仅作为名称节点使用，因此将slaves文件中原来的localhost删除，只添加如下一行内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpu-node3</span><br></pre></td></tr></table></figure><h2 id="修改文件core-site-xml"><a href="#修改文件core-site-xml" class="headerlink" title="修改文件core-site.xml"></a>修改文件core-site.xml</h2><p>把core-site.xml文件修改为如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://cpu-node0:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.checkpoint.period<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>3600<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>The number of seconds between two periodic checkpoints.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/home/lpj/hadoop2.7/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.checkpoint.size<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>67108864<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>The size of the current edit log (in bytes) that triggers</span><br><span class="line">          a periodic checkpoint even if the fs.checkpoint.period hasn&#x27;t expired.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.hadoop.hosts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.hadoop.groups<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="修改文件hdfs-site-xml"><a href="#修改文件hdfs-site-xml" class="headerlink" title="修改文件hdfs-site.xml"></a>修改文件hdfs-site.xml</h2><p>对于Hadoop的分布式文件系统HDFS而言，一般都是采用冗余存储，冗余因子通常为3，也就是说，一份数据保存三份副本。但是，本教程只有一个Slave节点作为数据节点，即集群中只有一个数据节点，数据只能保存一份，所以 ，dfs.replication的值还是设置为 1。hdfs-site.xml具体内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>cpu-node0:50049<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/home/lpj/hadoop2.7/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/home/lpj/hadoop2.7/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.webhdfs.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="修改文件mapred-site-xml"><a href="#修改文件mapred-site-xml" class="headerlink" title="修改文件mapred-site.xml"></a>修改文件mapred-site.xml</h2><p>“/hadoop2.7/etc/hadoop”目录下只有mapred-site.xml.template，将其重命名为mapred-site.xml，并修改文件配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>cpu-node0:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>cpu-node0:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="修改文件-yarn-site-xml"><a href="#修改文件-yarn-site-xml" class="headerlink" title="修改文件 yarn-site.xml"></a>修改文件 yarn-site.xml</h2><p>把yarn-site.xml文件配置成如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>cpu-node0<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.vmem-pmem-ratio<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>4<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Ratio between virtual memory to physical memory when setting memory limits for containers<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.vmem-check-enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述5个文件全部配置完成以后，需要把Master节点上的“/home/lpj/hadoop”文件夹复制到各个节点上。如果之前已经运行过伪分布式模式，建议在切换到集群模式之前首先删除之前在伪分布式模式下生成的临时文件。具体来说就是删除hadoop根目录里的tmp和logs文件夹，没有的话就不用管。</p><h1 id="开始启动"><a href="#开始启动" class="headerlink" title="开始启动"></a>开始启动</h1><p>压缩后scp传输：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zcf ~/hadoop2.7.master.tar.gz ~/hadoop2.7</span><br><span class="line">scp ~/hadoop2.7.master.tar.gz cpu-node3:/home/lpj</span><br></pre></td></tr></table></figure><p>然后在Slave1节点上执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -r /home/lpj/hadoop    # 删掉旧的（如果存在）</span><br><span class="line">tar -zxf ~/hadoop2.7.master.tar.gz -C /home/lpj</span><br></pre></td></tr></table></figure><p>同样，如果有其他Slave节点，也要执行将hadoop.master.tar.gz传输到Slave节点以及在Slave节点解压文件的操作。</p><p>首次启动Hadoop集群时，需要先在Master节点执行名称节点的格式化（只需要执行这一次，后面再启动Hadoop时，不要再次格式化名称节点），命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure><p>成功的话，会看到 “successfully formatted” 的提示，返回信息有一句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-09-08 16:18:32,989 INFO common.Storage: Storage directory /home/lpj/hadoop/tmp/dfs/name has been successfully formatted.</span><br></pre></td></tr></table></figure><p>现在就可以启动Hadoop了，启动需要在Master节点上进行，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start-dfs.sh</span><br><span class="line">start-yarn.sh</span><br><span class="line">mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure><p>前两个start脚本亦可用一个命令代替：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-all.sh</span><br></pre></td></tr></table></figure><p>这个指令会开启所有start脚本，所以也会有<code>This script is Deprecated. Instead use stop-dfs.sh and stop-yarn.sh</code>这样的warning提示。如果不是反复调试中偷懒的话尽量不要用这种省事的方式。</p><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>建议用jps检查进程时也是一个脚本一个脚本地检查，在启动完<code>start-dfs.sh</code>后分别对两个服务器用jps检查启动情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ jps</span><br><span class="line">34806 NameNode</span><br><span class="line">35095 SecondaryNameNode</span><br><span class="line">35294 Jps</span><br><span class="line"></span><br><span class="line">[lpj@cpu-node3 ~]$ jps</span><br><span class="line">7361 Jps</span><br></pre></td></tr></table></figure><p>很好，cpu-node3上没有启动DataNode。这时候需要打开cpu-node3中hadoop2.7/logs/hadoop-lpj-datanode-cpu-node3.hustlab.log查看日志文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-09-16 15:38:10,678 FATAL org.apache.hadoop.hdfs.server.datanode.DataNode: Exception in secureMain</span><br><span class="line">java.net.BindException: Problem binding to [0.0.0.0:50010] java.net.BindException: Address already in use; For more details see:  http:&#x2F;&#x2F;wiki.apache.org&#x2F;hadoop&#x2F;BindException</span><br><span class="line">......</span><br><span class="line">Caused by: java.net.BindException: Address already in use</span><br></pre></td></tr></table></figure><p>显示地址已被占用，经查询是发现实验室中本已有一个hadoop是用了cpu-node3作为slave节点，而那个hadoop项目基本上采用了默认的地址和端口配置，故现在自己搭建的一个新的hadoop项目需要自定义地址端口加以避让。修改hdfs-site.xml，加上：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>cpu-node3:50011<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.http.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>cpu-node3:50076<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.ipc.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>cpu-node3:50021<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在终端中用<code>stop-dfs.sh</code>停止原先启动的进程，再用一遍<code>start-dfs.sh</code>重启即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ start-dfs.sh</span><br><span class="line">Starting namenodes on [cpu-node0]</span><br><span class="line">cpu-node0: starting namenode, logging to /home/lpj/hadoop2.7/logs/hadoop-lpj-namenode-cpu-node0.hustlab.out</span><br><span class="line">cpu-node3: starting datanode, logging to /home/lpj/hadoop2.7/logs/hadoop-lpj-datanode-cpu-node3.hustlab.out</span><br><span class="line">Starting secondary namenodes [cpu-node0]</span><br><span class="line">cpu-node0: starting secondarynamenode, logging to /home/lpj/hadoop2.7/logs/hadoop-lpj-secondarynamenode-cpu-node0.hustlab.out</span><br></pre></td></tr></table></figure><p>此时在cpu-node3中已可以看到启动后的DataNode进程。</p><p>然后启动<code>start-yarn.sh</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ start-yarn.sh</span><br><span class="line">starting yarn daemons</span><br><span class="line">starting resourcemanager, logging to /home/lpj/hadoop2.7/logs/yarn-lpj-resourcemanager-cpu-node0.hustlab.out</span><br><span class="line">cpu-node3: starting nodemanager, logging to /home/lpj/hadoop2.7/logs/yarn-lpj-nodemanager-cpu-node3.hustlab.out</span><br></pre></td></tr></table></figure><p>再去用jps分别查看cpu-node0和cpu-node3：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ jps</span><br><span class="line">39570 NameNode</span><br><span class="line">39847 SecondaryNameNode</span><br><span class="line">40696 Jps</span><br><span class="line">40365 ResourceManager</span><br><span class="line"></span><br><span class="line">[lpj@cpu-node3 ~]$ jps</span><br><span class="line">7961 DataNode</span><br><span class="line">8413 Jps</span><br><span class="line">8190 NodeManager</span><br></pre></td></tr></table></figure><p>能看到ResourceManager和NodeManager即为启动成功。</p><p>最后用<code>mr-jobhistory-daemon.sh start historyserver</code>启动JobHistoryServer：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ mr-jobhistory-daemon.sh start historyserver</span><br><span class="line">starting historyserver, logging to /home/lpj/hadoop2.7/logs/mapred-lpj-historyserver-cpu-node0.hustlab.out</span><br></pre></td></tr></table></figure><p>这里检查cpu-node0即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ jps</span><br><span class="line">45763 Jps</span><br><span class="line">45704 JobHistoryServer</span><br><span class="line">45002 SecondaryNameNode</span><br><span class="line">45243 ResourceManager</span><br><span class="line">44655 NameNode</span><br></pre></td></tr></table></figure><h2 id="check"><a href="#check" class="headerlink" title="check"></a>check</h2><p>总结：如果已经正确启动，则用jps在Master节点上可以看到NameNode、ResourceManager、SecondaryNameNode和JobHistoryServer进程，在Slave节点可以看到DataNode和NodeManager进程。<strong>缺少任一进程都表示出错，回去查看对应进程的log文件。</strong></p><p>另外还需要在Master节点上通过命令“hdfs dfsadmin -report”查看数据节点是否正常启动，如果屏幕信息中的“Live datanodes”不为 0 ，则说明集群启动成功。由于本次实验只有1个Slave节点充当数据节点，因此，数据节点启动成功以后，会显示如下图所示信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ hdfs dfsadmin -report</span><br><span class="line">Configured Capacity: 5366572122112 (4.88 TB)</span><br><span class="line">Present Capacity: 5282481352704 (4.80 TB)</span><br><span class="line">DFS Remaining: 5282481340416 (4.80 TB)</span><br><span class="line">DFS Used: 12288 (12 KB)</span><br><span class="line">DFS Used%: 0.00%</span><br><span class="line">Under replicated blocks: 0</span><br><span class="line">Blocks with corrupt replicas: 0</span><br><span class="line">Missing blocks: 0</span><br><span class="line">Missing blocks (with replication factor 1): 0</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line">Live datanodes (1):</span><br><span class="line"></span><br><span class="line">Name: 192.168.232.103:50011 (cpu-node3)</span><br><span class="line">Hostname: cpu-node3</span><br><span class="line">Decommission Status : Normal</span><br><span class="line">Configured Capacity: 5366572122112 (4.88 TB)</span><br><span class="line">DFS Used: 12288 (12 KB)</span><br><span class="line">Non DFS Used: 84090769408 (78.32 GB)</span><br><span class="line">DFS Remaining: 5282481340416 (4.80 TB)</span><br><span class="line">DFS Used%: 0.00%</span><br><span class="line">DFS Remaining%: 98.43%</span><br><span class="line">Configured Cache Capacity: 0 (0 B)</span><br><span class="line">Cache Used: 0 (0 B)</span><br><span class="line">Cache Remaining: 0 (0 B)</span><br><span class="line">Cache Used%: 100.00%</span><br><span class="line">Cache Remaining%: 0.00%</span><br><span class="line">Xceivers: 1</span><br><span class="line">Last contact: Wed Sep 16 16:19:38 CST 2020</span><br></pre></td></tr></table></figure><h1 id="执行分布式实例"><a href="#执行分布式实例" class="headerlink" title="执行分布式实例"></a>执行分布式实例</h1><p>首先创建HDFS上的用户目录，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mkdir /user/lpj</span><br></pre></td></tr></table></figure><p>然后，在HDFS中创建一个input目录，并把“/home/lpj/hadoop2.7/etc/hadoop”目录中的配置文件作为输入文件复制到input目录中，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mkdir /user/lpj/input</span><br><span class="line">hdfs dfs -put /home/lpj/hadoop2.7/etc/hadoop/*.xml /user/lpj/input</span><br></pre></td></tr></table></figure><p>可以用<code>hdfs dfs -ls [path]</code>命令查看某个目录下的所有内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ hdfs dfs -ls /user/lpj</span><br><span class="line">Found 1 items</span><br><span class="line">drwxr-xr-x   - lpj supergroup          0 2020-09-16 16:43 /user/lpj/input</span><br><span class="line">[lpj@cpu-node0 ~]$ hdfs dfs -ls /user/lpj/input</span><br><span class="line">Found 9 items</span><br><span class="line">-rw-r--r--   1 lpj supergroup       4436 2020-09-16 16:46 /user/lpj/input/capacity-scheduler.xml</span><br><span class="line">-rw-r--r--   1 lpj supergroup       1779 2020-09-16 16:46 /user/lpj/input/core-site.xml</span><br><span class="line">-rw-r--r--   1 lpj supergroup       9683 2020-09-16 16:46 /user/lpj/input/hadoop-policy.xml</span><br><span class="line">-rw-r--r--   1 lpj supergroup       1713 2020-09-16 16:46 /user/lpj/input/hdfs-site.xml</span><br><span class="line">-rw-r--r--   1 lpj supergroup        620 2020-09-16 16:46 /user/lpj/input/httpfs-site.xml</span><br><span class="line">-rw-r--r--   1 lpj supergroup       3518 2020-09-16 16:46 /user/lpj/input/kms-acls.xml</span><br><span class="line">-rw-r--r--   1 lpj supergroup       5540 2020-09-16 16:46 /user/lpj/input/kms-site.xml</span><br><span class="line">-rw-r--r--   1 lpj supergroup       1109 2020-09-16 16:46 /user/lpj/input/mapred-site.xml</span><br><span class="line">-rw-r--r--   1 lpj supergroup       1245 2020-09-16 16:46 /user/lpj/input/yarn-site.xml</span><br></pre></td></tr></table></figure><p>接着就可以运行 MapReduce 作业了，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar /home/lpj/hadoop2.7/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar grep /user/lpj/input /user/lpj/output &#x27;dfs[a-z.]+&#x27;</span><br></pre></td></tr></table></figure><p>运行时会输出MapReduce作业的进度：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ hadoop jar /home/lpj/hadoop2.7/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar grep /user/lpj/input /user/lpj/output &#x27;dfs[a-z.]+&#x27;</span><br><span class="line">20/09/16 16:47:54 INFO client.RMProxy: Connecting to ResourceManager at cpu-node0/192.168.232.100:8032</span><br><span class="line">20/09/16 16:47:55 INFO input.FileInputFormat: Total input paths to process : 9</span><br><span class="line">20/09/16 16:47:56 INFO mapreduce.JobSubmitter: number of splits:9</span><br><span class="line">20/09/16 16:47:56 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_1600243226377_0001</span><br><span class="line">20/09/16 16:47:56 INFO impl.YarnClientImpl: Submitted application application_1600243226377_0001</span><br><span class="line">20/09/16 16:47:56 INFO mapreduce.Job: The url to track the job: http://cpu-node0:8088/proxy/application_1600243226377_0001/</span><br><span class="line">20/09/16 16:47:56 INFO mapreduce.Job: Running job: job_1600243226377_0001</span><br><span class="line">20/09/16 16:48:05 INFO mapreduce.Job: Job job_1600243226377_0001 running in uber mode : false</span><br><span class="line">20/09/16 16:48:05 INFO mapreduce.Job:  map 0% reduce 0%</span><br><span class="line">20/09/16 16:48:09 INFO mapreduce.Job:  map 56% reduce 0%</span><br><span class="line">20/09/16 16:48:10 INFO mapreduce.Job:  map 67% reduce 0%</span><br><span class="line">20/09/16 16:48:13 INFO mapreduce.Job:  map 100% reduce 0%</span><br><span class="line">20/09/16 16:48:14 INFO mapreduce.Job:  map 100% reduce 100%</span><br><span class="line">20/09/16 16:48:15 INFO mapreduce.Job: Job job_1600243226377_0001 completed successfully</span><br><span class="line">20/09/16 16:48:15 INFO mapreduce.Job: Counters: 49</span><br><span class="line">        File System Counters</span><br><span class="line">                FILE: Number of bytes read=285</span><br><span class="line">                FILE: Number of bytes written=1235413</span><br><span class="line">                FILE: Number of read operations=0</span><br><span class="line">                FILE: Number of large read operations=0</span><br><span class="line">                FILE: Number of write operations=0</span><br><span class="line">                HDFS: Number of bytes read=30693</span><br><span class="line">                HDFS: Number of bytes written=419</span><br><span class="line">                HDFS: Number of read operations=30</span><br><span class="line">                HDFS: Number of large read operations=0</span><br><span class="line">                HDFS: Number of write operations=2</span><br><span class="line">        Job Counters</span><br><span class="line">                Launched map tasks=9</span><br><span class="line">                Launched reduce tasks=1</span><br><span class="line">                Data-local map tasks=9</span><br><span class="line">                Total time spent by all maps in occupied slots (ms)=23940</span><br><span class="line">                Total time spent by all reduces in occupied slots (ms)=2649</span><br><span class="line">                Total time spent by all map tasks (ms)=23940</span><br><span class="line">                Total time spent by all reduce tasks (ms)=2649</span><br><span class="line">                Total vcore-milliseconds taken by all map tasks=23940</span><br><span class="line">                Total vcore-milliseconds taken by all reduce tasks=2649</span><br><span class="line">                Total megabyte-milliseconds taken by all map tasks=24514560</span><br><span class="line">                Total megabyte-milliseconds taken by all reduce tasks=2712576</span><br><span class="line">        Map-Reduce Framework</span><br><span class="line">                Map input records=854</span><br><span class="line">                Map output records=9</span><br><span class="line">                Map output bytes=261</span><br><span class="line">                Map output materialized bytes=333</span><br><span class="line">                Input split bytes=1050</span><br><span class="line">                Combine input records=9</span><br><span class="line">                Combine output records=9</span><br><span class="line">                Reduce input groups=9</span><br><span class="line">                Reduce shuffle bytes=333</span><br><span class="line">                Reduce input records=9</span><br><span class="line">                Reduce output records=9</span><br><span class="line">                Spilled Records=18</span><br><span class="line">                Shuffled Maps =9</span><br><span class="line">                Failed Shuffles=0</span><br><span class="line">                Merged Map outputs=9</span><br><span class="line">                GC time elapsed (ms)=791</span><br><span class="line">                CPU time spent (ms)=6020</span><br><span class="line">                Physical memory (bytes) snapshot=2622357504</span><br><span class="line">                Virtual memory (bytes) snapshot=21854842880</span><br><span class="line">                Total committed heap usage (bytes)=1958215680</span><br><span class="line">        Shuffle Errors</span><br><span class="line">                BAD_ID=0</span><br><span class="line">                CONNECTION=0</span><br><span class="line">                IO_ERROR=0</span><br><span class="line">                WRONG_LENGTH=0</span><br><span class="line">                WRONG_MAP=0</span><br><span class="line">                WRONG_REDUCE=0</span><br><span class="line">        File Input Format Counters</span><br><span class="line">                Bytes Read=29643</span><br><span class="line">        File Output Format Counters</span><br><span class="line">                Bytes Written=419</span><br><span class="line">20/09/16 16:48:15 INFO client.RMProxy: Connecting to ResourceManager at cpu-node0/192.168.232.100:8032</span><br><span class="line">20/09/16 16:48:15 INFO input.FileInputFormat: Total input paths to process : 1</span><br><span class="line">20/09/16 16:48:15 INFO mapreduce.JobSubmitter: number of splits:1</span><br><span class="line">20/09/16 16:48:15 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_1600243226377_0002</span><br><span class="line">20/09/16 16:48:15 INFO impl.YarnClientImpl: Submitted application application_1600243226377_0002</span><br><span class="line">20/09/16 16:48:15 INFO mapreduce.Job: The url to track the job: http://cpu-node0:8088/proxy/application_1600243226377_0002/</span><br><span class="line">20/09/16 16:48:15 INFO mapreduce.Job: Running job: job_1600243226377_0002</span><br><span class="line">20/09/16 16:48:25 INFO mapreduce.Job: Job job_1600243226377_0002 running in uber mode : false</span><br><span class="line">20/09/16 16:48:25 INFO mapreduce.Job:  map 0% reduce 0%</span><br><span class="line">20/09/16 16:48:30 INFO mapreduce.Job:  map 100% reduce 0%</span><br><span class="line">20/09/16 16:48:35 INFO mapreduce.Job:  map 100% reduce 100%</span><br><span class="line">20/09/16 16:48:36 INFO mapreduce.Job: Job job_1600243226377_0002 completed successfully</span><br><span class="line">20/09/16 16:48:36 INFO mapreduce.Job: Counters: 49</span><br><span class="line">        File System Counters</span><br><span class="line">                FILE: Number of bytes read=285</span><br><span class="line">                FILE: Number of bytes written=246463</span><br><span class="line">                FILE: Number of read operations=0</span><br><span class="line">                FILE: Number of large read operations=0</span><br><span class="line">                FILE: Number of write operations=0</span><br><span class="line">                HDFS: Number of bytes read=547</span><br><span class="line">                HDFS: Number of bytes written=207</span><br><span class="line">                HDFS: Number of read operations=7</span><br><span class="line">                HDFS: Number of large read operations=0</span><br><span class="line">                HDFS: Number of write operations=2</span><br><span class="line">        Job Counters</span><br><span class="line">                Launched map tasks=1</span><br><span class="line">                Launched reduce tasks=1</span><br><span class="line">                Data-local map tasks=1</span><br><span class="line">                Total time spent by all maps in occupied slots (ms)=2145</span><br><span class="line">                Total time spent by all reduces in occupied slots (ms)=2290</span><br><span class="line">                Total time spent by all map tasks (ms)=2145</span><br><span class="line">                Total time spent by all reduce tasks (ms)=2290</span><br><span class="line">                Total vcore-milliseconds taken by all map tasks=2145</span><br><span class="line">                Total vcore-milliseconds taken by all reduce tasks=2290</span><br><span class="line">                Total megabyte-milliseconds taken by all map tasks=2196480</span><br><span class="line">                Total megabyte-milliseconds taken by all reduce tasks=2344960</span><br><span class="line">        Map-Reduce Framework</span><br><span class="line">                Map input records=9</span><br><span class="line">                Map output records=9</span><br><span class="line">                Map output bytes=261</span><br><span class="line">                Map output materialized bytes=285</span><br><span class="line">                Input split bytes=128</span><br><span class="line">                Combine input records=0</span><br><span class="line">                Combine output records=0</span><br><span class="line">                Reduce input groups=1</span><br><span class="line">                Reduce shuffle bytes=285</span><br><span class="line">                Reduce input records=9</span><br><span class="line">                Reduce output records=9</span><br><span class="line">                Spilled Records=18</span><br><span class="line">                Shuffled Maps =1</span><br><span class="line">                Failed Shuffles=0</span><br><span class="line">                Merged Map outputs=1</span><br><span class="line">                GC time elapsed (ms)=144</span><br><span class="line">                CPU time spent (ms)=1490</span><br><span class="line">                Physical memory (bytes) snapshot=444129280</span><br><span class="line">                Virtual memory (bytes) snapshot=4380962816</span><br><span class="line">                Total committed heap usage (bytes)=346030080</span><br><span class="line">        Shuffle Errors</span><br><span class="line">                BAD_ID=0</span><br><span class="line">                CONNECTION=0</span><br><span class="line">                IO_ERROR=0</span><br><span class="line">                WRONG_LENGTH=0</span><br><span class="line">                WRONG_MAP=0</span><br><span class="line">                WRONG_REDUCE=0</span><br><span class="line">        File Input Format Counters</span><br><span class="line">                Bytes Read=419</span><br><span class="line">        File Output Format Counters</span><br><span class="line">                Bytes Written=207</span><br></pre></td></tr></table></figure><p>用<code>hdfs dfs -cat [path]</code>查看执行完毕后的输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[lpj@cpu-node0 ~]$ hdfs dfs -cat /user/lpj/output/*</span><br><span class="line">1       dfsadmin</span><br><span class="line">1       dfs.webhdfs.enabled</span><br><span class="line">1       dfs.replication</span><br><span class="line">1       dfs.namenode.secondary.http</span><br><span class="line">1       dfs.namenode.name.dir</span><br><span class="line">1       dfs.datanode.ipc.address</span><br><span class="line">1       dfs.datanode.http.address</span><br><span class="line">1       dfs.datanode.data.dir</span><br><span class="line">1       dfs.datanode.address</span><br></pre></td></tr></table></figure><blockquote><p><em>运行程序时，输出目录不能存在</em></p><p>运行 Hadoop 程序时，为了防止覆盖结果，程序指定的输出目录（如 output）不能存在，否则会提示错误，因此运行前需要先删除输出目录。在实际开发应用程序时，可考虑在程序中加上如下代码，能在每次运行时自动删除输出目录，避免繁琐的命令行操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;Configuration conf = <span class="keyword">new</span> Configuration();Job job = <span class="keyword">new</span> Job(conf); <span class="comment">/* 删除输出目录 */</span>Path outputPath = <span class="keyword">new</span> Path(args[<span class="number">1</span>]);outputPath.getFileSystem(conf).delete(outputPath, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></blockquote><h1 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h1><p>至此，顺利完成了Hadoop集群搭建。若要关闭Hadoop集群，需要在Master节点执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop-yarn.sh</span><br><span class="line">stop-dfs.sh</span><br><span class="line">mr-jobhistory-daemon.sh stop historyserver</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 安装 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大数据技术原理与应用》学习笔记——Ch2：大数据处理架构Hadoop</title>
      <link href="2020/09/04/BigData_Ch2/"/>
      <url>2020/09/04/BigData_Ch2/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>本文为<a href="https://www.icourse163.org/course/XMU-1002335004?tid=1450180443">《大数据技术原理与应用》</a>第二章学习笔记。</p><h1 id="Hadoop概述"><a href="#Hadoop概述" class="headerlink" title="Hadoop概述"></a>Hadoop概述</h1><p>“Hadoop”不是一个单一的技术，而是一系列大数据技术的结合体，是一整套解决方案的统称，可以称为一个项目。</p><p>两大核心：HDFS实现海量数据的分布式存储，MapReduce实现海量数据的分布式处理</p><p>特性：</p><ul><li>高可靠性</li><li>高效性</li><li>高可扩展性</li><li>高容错性</li><li>成本低</li><li>运行在Linux平台上</li><li>支持多种编程语言</li></ul><h1 id="Hadoop生态系统"><a href="#Hadoop生态系统" class="headerlink" title="Hadoop生态系统"></a>Hadoop生态系统</h1><p><img src="http://img.cuper.top/QQ%E6%88%AA%E5%9B%BE20200904092538.png" alt="QQ截图20200904092538"></p><table><thead><tr><th align="left">组件</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">HDFS</td><td align="left">分布式文件系统</td></tr><tr><td align="left">MapReduce</td><td align="left">分布式并行编程模型</td></tr><tr><td align="left">YARN</td><td align="left">资源管理和调度器</td></tr><tr><td align="left">Tez</td><td align="left">运行在YARN之上的下一代Hadoop查询处理框架</td></tr><tr><td align="left">Hive</td><td align="left">Hadoop上的数据仓库</td></tr><tr><td align="left">HBase</td><td align="left">Hadoop上的非关系型的分布式数据库</td></tr><tr><td align="left">Pig</td><td align="left">一个基于Hadoop的大规模数据分析平台，提供类似SQL的查询语言Pig Latin</td></tr><tr><td align="left">Sqoop</td><td align="left">用于在Hadoop与传统数据库之间进行数据传递</td></tr><tr><td align="left">Oozie</td><td align="left">Hadoop上的工作流管理系统</td></tr><tr><td align="left">Zookeeper</td><td align="left">提供分布式协调一致性服务</td></tr><tr><td align="left">Storm</td><td align="left">流计算框架</td></tr><tr><td align="left">Flume</td><td align="left">一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统</td></tr><tr><td align="left">Ambari</td><td align="left">Hadoop快速部署工具，支持Apache Hadoop集群的供应、管理和监控</td></tr><tr><td align="left">Kafka</td><td align="left">一种高吞吐量的分布式发布订阅消息系统，可以处理消费者规模的网站中的所有动作流数据</td></tr><tr><td align="left">Spark</td><td align="left">类似于Hadoop MapReduce的通用并行框架</td></tr></tbody></table><h1 id="Hadoop的安装与使用"><a href="#Hadoop的安装与使用" class="headerlink" title="Hadoop的安装与使用"></a>Hadoop的安装与使用</h1><p>Hadoop基本安装配置主要包括以下几个步骤：</p><ul><li>创建Hadoop用户</li><li>SSH登录权限设置</li><li>安装Java环境</li><li>单机安装配置</li><li>伪分布式安装配置</li></ul><p><strong>配置SSH的原因</strong>： Hadoop名称节点（NameNode）需要启动集群中所有机器的Hadoop守护进程，这个过程需要通过SSH登录来实现。Hadoop并没有提供SSH输入密码登录的形式，因此，为了能够顺利登录每台机器，需要将所有机器配置为名称节点可以无密码登录它们。</p><p>单机&amp;伪分布式安装参照：<a href="http://blog.cuper.top/2020/07/21/Hadoop3.1.3_setup/">Hadoop3.1.3安装教程：单机&amp;伪分布式配置</a></p><h1 id="Hadoop集群的部署及使用"><a href="#Hadoop集群的部署及使用" class="headerlink" title="Hadoop集群的部署及使用"></a>Hadoop集群的部署及使用</h1><p>一个基本的Hadoop集群中的节点主要有：</p><p>HDFS：</p><ul><li>NameNode：负责协调集群中的数据存储</li><li>DataNode：存储被拆分的数据块</li><li>SecondaryNameNode：帮助NameNode收集文件系统运行的状态信息（冷备份）</li></ul><p>MapReduce：</p><ul><li>JobTracker：协调数据计算任务</li><li>TaskTracker：负责执行由JobTracker指派的任务</li></ul><p>集群硬件配置：</p><p>DateNode：</p><p><img src="http://img.cuper.top/QQ%E6%88%AA%E5%9B%BE20200904114526.png"></p><p>NameNode：</p><p><img src="http://img.cuper.top/QQ%E6%88%AA%E5%9B%BE20200904114558.png" alt="QQ截图20200904114526"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> MOOC笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文精读笔记——Unsupervised Clickstream Clustering for User Behavior Analysis Courses</title>
      <link href="2020/08/08/Unsupervised_Clickstream_Clustering_for_User_Behavior_Analysis/"/>
      <url>2020/08/08/Unsupervised_Clickstream_Clustering_for_User_Behavior_Analysis/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>在阅读完《<a href="http://blog.cuper.top/2020/08/06/ViSeq/">ViSeq: Visual Analytics of Learning Sequence in Massive Open Online Courses</a>》后觉得里面的参考文献[27]似乎更有帮助，于是精读了这篇文章：《<a href="https://dl.acm.org/doi/abs/10.1145/2858036.2858107">Unsupervised Clickstream Clustering for User Behavior Analysis</a>》，作以下笔记。</p><h1 id="Unsupervised-Clickstream-Clustering-for-User-Behavior-Analysis"><a href="#Unsupervised-Clickstream-Clustering-for-User-Behavior-Analysis" class="headerlink" title="Unsupervised Clickstream Clustering for User Behavior Analysis"></a>Unsupervised Clickstream Clustering for User Behavior Analysis</h1><h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>面向通用的在线服务（社交网络或众包服务），了解用户行为。</p><p>研究面向用户行为分析的无监督点击流聚类，建立了一个无监督的系统，从点击流数据（用户点击事件的痕迹）中捕捉用户行为，并以直观的方式可视化检测到的行为，通过划分相似图来识别相似用户的集群。</p><p>相似图上的分区（也就是聚类过程）利用迭代特征剪枝算法（iterative feature pruning）来捕捉用户集群中的自然层次结构，产生直观的特征便于可视化和理解。</p><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>Clickstreams：用户操作生成的带有时间戳的事件序列。</p><p>点击流分析系统的要求：</p><ul><li>在大的、杂乱的点击流数据集上可扩展和良好运行。</li><li>系统应该能够捕捉到先前未知的用户行为（即在没有预先定义类别或标签的情况下捕捉行为）</li><li>系统应该是交互式的，以直观易懂的方式呈现检测到的行为，来帮助其他人理解用户行为。</li></ul><p>本文介绍一个实用的、可扩展的用户点击流行为分析工具的设计与评估。</p><p>使用点击流之间的相似性度量来构建用户之间的相似性图，捕捉用户的行为模式。</p><p>使用层次聚类的方法来检测最流行的用户行为模式，并使用迭代特征剪枝技术来消除每一个后续聚类层中主导特征的影响。</p><p>最终输出结果是一个行为聚类的层次结构，高层聚类代表更一般的用户行为模式，低层聚类进一步识别出在关键行为模式上存在差异的较小群体。</p><p>进一步使用卡方检验识别的统计特征可用于对行为聚类进行分类和标记的。</p><p>case studies：采用了来自Whisper和人人网的两个数据集——</p><ul><li>在Whisper中识别出不同层次的“休眠用户”的行为模式，并根据相邻的行为集群对休眠用户进行有效的预测</li><li>研究Whisper中的用户屏蔽行为，发现大部分屏蔽行为是双向的，通常发生在私聊之后、与性暗示相关。</li><li>在人人网数据集中准确识别了95%的假账户，发现了使用不同账号攻击方法的用户小组。</li></ul><p>从两个基准上评估该工具：</p><ul><li>算法生成的行为集群是否易于理解（能够理解用户行为的含义）</li><li>用算法评估了生成的聚类的质量（优于K-means）</li></ul><p>本文的三个主要贡献：</p><ul><li>提出了一种新型无监督的在线用户行为建模方法。将详细的用户行为模型捕捉为可视化图中的层次簇，并自动生成直观的特性来解释每个行为集群的含义。</li><li>对两个大规模的点击流数据集（总共1.42亿次点击事件）进行了case studies，可以有效地帮助服务提供商识别意外的用户行为（人人网的恶意帐户、Whisper的恶俗会话），甚至可以预测用户未来的行为（Whisper中的休眠用户）。</li><li>对工具进行基准评估，显示该算法生成的聚类标签易于理解，并且我们的工具能够生成高精度的用户行为模型。</li></ul><h2 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h2><ul><li>在线服务中的用户行为建模。</li><li>点击流分析：使用聚类技术来识别具有相似点击流活动的用户集群[8,25,27,29]，用于推断用户兴趣[25]或预测未来的行为[8]。</li><li>点击流可视化：点击事件序列[35]、点击转换[32]</li></ul><h2 id="CLICKSTREAM-DATASETS"><a href="#CLICKSTREAM-DATASETS" class="headerlink" title="CLICKSTREAM DATASETS"></a>CLICKSTREAM DATASETS</h2><p>数据来源：Whisper和人人网</p><h3 id="Whisper"><a href="#Whisper" class="headerlink" title="Whisper"></a>Whisper</h3><p>一款流行的用于匿名社交信息的智能手机应用程序。</p><p>与Whisper的数据科学团队合作拿到的数据集：45天内99990名用户的1.36亿次点击事件（表1）</p><p>每个click事件都由userID、时间戳、事件类型和事件参数组成。</p><p>事件类型：33种，可分为6类：</p><ul><li><strong>浏览：</strong>浏览whispers用户，访问公共whisper feeds（热门/附近/最新）。</li><li><strong>帐户：</strong>创建用户帐户并登录应用程序。</li><li><strong>发布：</strong>发布原始的whisper和回复，点赞/点踩一个whisper，分享whisper，并为某个whisper标记话题。</li><li><strong>聊天：</strong>发起聊天，屏蔽某用户，被屏蔽。</li><li><strong>通知：</strong>收到关于自己的whisper被点赞/回复的通知，以及whisper推荐。</li><li><strong>垃圾邮件：</strong>whisper被系统管理员检查或删除，标记他人的whisper为垃圾信息。此类事件均低于1%（在表2中省略了）。</li></ul><p>其中25种是由用户发起的事件，其余8种是不需要用户操作的系统事件。表2显示了最流行的事件和绝对数量（以千为单位）和点击率。其中在聊天类事件下，最常见的事件是“屏蔽用户”和“被他人屏蔽”，这个在后面会进一步挖掘。</p><p>数据集里还有whisper发布的内容，将用于理解特定的用户行为和用户意图。</p><h3 id="人人网"><a href="#人人网" class="headerlink" title="人人网"></a>人人网</h3><p>数据集（表1后半部分）：5998名普通用户和9994个Sybil帐户（百科解释：<a href="https://baike.baidu.com/item/Sybil%E7%BE%A4%E4%BD%93/22129086?fr=aladdin">Sybil群体</a>指代那些被恶意操控进行协同攻击的虚假账户，即利用社交网络中少数节点控制多个虚假身份，从而利用这些身份控制或影响网络的大量正常节点的特殊行为群体，有点像现在微博的僵尸粉）</p><p>每个click事件与whisper一样，也由userID、时间戳、事件类型和事件参数组成。</p><p>事件类型：55种，可分为8类：</p><ul><li><strong>社交：</strong>发送好友请求，接受或拒绝好友请求，删除好友。</li><li><strong>照片：</strong>上传照片，组织相册，标记好友，浏览照片和撰写评论。</li><li><strong>个人资料：</strong>浏览用户资料界面（人人网的个人资料可以被任何人浏览，但显示的信息受到所有者隐私设置的限制）。</li><li><strong>分享：</strong>用户分享人人网内/外的视频、博客或照片的网址链接。</li><li><strong>消息：</strong>状态更新和即时消息。</li><li><strong>博客：</strong>阅读/撰写博客，发表评论。</li><li><strong>通知：</strong>用户主动点击通知。</li><li><strong>点赞：</strong>用户点赞（或点踩）某内容。</li></ul><p>与Whisper不同的是，人人网不包含任何系统事件，如“接收通知”，所有事件都是由用户发起的。</p><p>表3显示了最流行的事件，普通用户和Sybil账户是分别计数的。后面会根据Sybil用户在某些数据上的不同来分析Sybil的攻击策略。</p><h2 id="UNSUPERVISED-USER-BEHAVIOR-MODELING"><a href="#UNSUPERVISED-USER-BEHAVIOR-MODELING" class="headerlink" title="UNSUPERVISED USER BEHAVIOR MODELING"></a>UNSUPERVISED USER BEHAVIOR MODELING</h2><p>在高层次上，假设人们的行为自然形成集群，目标是把这些自然集群识别为行为模型。</p><p>用户集群是多维的、树形结构（图1）：最突出的特征用于将用户划分为高级类别，而不太重要的特征用于描述详细的子结构。</p><p>设计了一种迭代特征剪枝算法来捕获层次化的点击流集群：在高层次上将用户映射到一个相似度图中（节点是用户，边缘是相似度的权值），然后划分相似度图以识别具有相似点击流活动的用户集群。递归地划分新生成的集群，同时修剪用于度量点击流相似性的特征集，以生成层次化的结构。</p><h3 id="Clickstream-and-Similarity-Graph"><a href="#Clickstream-and-Similarity-Graph" class="headerlink" title="Clickstream and Similarity Graph"></a>Clickstream and Similarity Graph</h3><h4 id="Formatting-User-Clickstream"><a href="#Formatting-User-Clickstream" class="headerlink" title="Formatting User Clickstream"></a><em>Formatting User Clickstream</em></h4><p>对于每个用户收集ta所有点击事件，形成一个单一的点击流。</p><p>是一个按到达顺序排序的离散事件序列，捕获点击流中的不同<strong>事件类型</strong>以及相邻两事件之间的<strong>时间间隔</strong>（图2）。然后使时间间隔离散化，将精确的时间间隔值映射为五个离散标识符：&lt;1s, [1s, 1min], (1min, 1h], (1h, 1day],&gt; 1day分别映射到g1~g5。</p><h4 id="Clickstream-Similarity-Graph"><a href="#Clickstream-Similarity-Graph" class="headerlink" title="Clickstream Similarity Graph"></a><em>Clickstream Similarity Graph</em></h4><p>聚类算法要基于相似图，所以需要一个相似度的度量。这里提到了他相似图方法的来源文献[29]：G. Wang, T. Konolige, C. Wilson, X. Wang, H. Zheng, and B. Y. Zhao. 2013b. You Are How You Click: Clickstream Analysis for Sybil Detection. In Proc. of USENIX Security.</p><p>然后后面就是《<a href="http://blog.cuper.top/2020/08/06/ViSeq/">ViSeq：Visual Analytics of Learning Sequence in Massive Open Online Courses</a>》里Data Preprocessing的内容。这里提到了polar distance的优点：更适合处理高度稀疏的向量，比较向量的“方向性”而不是“幅度”。</p><h3 id="Feature-Pruning-based-Clickstream-Clustering"><a href="#Feature-Pruning-based-Clickstream-Clustering" class="headerlink" title="Feature Pruning based Clickstream Clustering"></a>Feature Pruning based Clickstream Clustering</h3><p>用迭代特征剪枝递归地划分相似图，在现有簇中识别细粒度行为簇。</p><h4 id="Iterative-Feature-Pruning-amp-Clustering"><a href="#Iterative-Feature-Pruning-amp-Clustering" class="headerlink" title="Iterative Feature Pruning &amp; Clustering"></a><em>Iterative Feature Pruning &amp; Clustering</em></h4><p>采用Divisive Hierarchical Clustering算法，分层聚类步骤在图1中描述，可以用于任意矩阵空间和发现任意的聚类形状。该算法的参考文献[13]： L. Kaufman and P. Rousseeuw. 2009. Finding groups in data: an introduction to cluster analysis. Vol. 344. John Wiley &amp; Sons. </p><p>第一层的聚类中，点击流相似性是基于完整的特征集（所有k-grams的集合）来度量的。</p><p>然后执行特征修剪：识别形成父集群的主要特征，将它们从特征集中移除，并使用剩余的次要特征进一步划分父集群。比如在划分出C1后，进行特征选择以确定将用户分类到C1的关键特征（即那个关键的k-gram）。然后，在对C1进行进一步划分时，我们从特征集中去除这些k-grams，并用剩余的k-grams来计算新的相似图。</p><p>当所有新的集群无法进一步分割时（比如聚类质量达到一个最小的阈值），算法停止。</p><p>剪枝的关键步骤是找出形成父簇的主要特征（finding the primary features responsible for forming the parent cluster），用了卡方检验（Chi-square statistics） (χ2)——一种衡量特征在分离不同类数据实例时的区分能力的经典度量。（卡方检验参考了文献[33]：Yiming Yang and Jan O. Pedersen. 1997. A Comparative Study on Feature Selection in Text Categorization. In ICML.）</p><p>对于给定的一个集群C1，我们根据在C1内部和外部的用户分布情况来衡量每个特性的χ2得分。然后选出χ2得分最高的特征。经验数据显示χ2分布通常表现出“长尾”特性——只有少数主导特征得分较高。我们通过识别分布中的最低点（或转折点）自动选择顶部特征[22]。</p><h4 id="Understanding-the-Behavioral-Clusters"><a href="#Understanding-the-Behavioral-Clusters" class="headerlink" title="Understanding the Behavioral Clusters"></a><em>Understanding the Behavioral Clusters</em></h4><p>根据卡方检验选择的主要特征来推断出这个聚类的意义，可以作为集群形成的原因以及集群包含哪些用户行为的解释。通过识别卡方分布中的最低点（或转折点）自动选择顶部特征（selected features，这个后面要用）。</p><h4 id="Determining-the-Number-of-Subclusters"><a href="#Determining-the-Number-of-Subclusters" class="headerlink" title="Determining the Number of Subclusters"></a><em>Determining the Number of Subclusters</em></h4><p>对于每个父类簇（及其相似性图），我们的系统识别其中的自然子簇数：在不断地划分为更多的子簇时监控总体聚类质量的变化，当生成更多的子集群将不再提高集群质量时算法将停止。</p><p>评价聚类质量的指标：模块度（Modularity），用于测量簇内边缘到簇外边缘的密度。参考文献[4]：V. D. Blondel, J. Guillaume, R. Lambiotte, and E. Lefebvre. 2008. Fast unfolding of communities in large networks. JSTAT 2008, 10 (2008).</p><h3 id="Cluster-Visualization"><a href="#Cluster-Visualization" class="headerlink" title="Cluster Visualization"></a>Cluster Visualization</h3><p>建立了一个可视化工具展示用户行为聚类，回答一些关键问题：主要的行为类别是什么？哪种行为更普遍？不同类型的行为之间有什么关系？etc.</p><h4 id="Visualization-Interface"><a href="#Visualization-Interface" class="headerlink" title="Visualization Interface"></a><em>Visualization Interface</em></h4><p>图3是可视化界面的截图，该工具用了D3.js开发，默认是用Packed Circle展示（子集群嵌套在其父集群中），圆圈大小反映了集群中的用户数量。</p><p>点击某一个聚类可以弹窗出一个信息窗口，比如图3中的弹窗显示了Cluster #1中的具体每个k-grams出现的频率和χ2得分。</p><h4 id="Visualizing-Whisper-and-Renren-Clusters"><a href="#Visualizing-Whisper-and-Renren-Clusters" class="headerlink" title="Visualizing Whisper and Renren Clusters"></a><em>Visualizing Whisper and Renren Clusters</em></h4><p>图3和图4分别是Whisper和人人网数据集的可视化截图。</p><p>聚类过程中把模块度（Modularity）阈值设为0.01，到达阈值时算法停止。</p><p>对于Whisper数据集，系统生成了107个簇（包括根）的树层次结构，其中包含95个叶簇，最大树深为4。</p><p>对于人人网数据集，层次结构包含108个簇（95个叶簇），最大深度为4。</p><p>可视化工具只显示每个集群的选定特性（selected features）。80%的集群具有少于5个选定的特性，90%的集群具有少于10个的特性，表明流行的用户行为可以用少量的关键特征维度来表征。（不然的话比如whisper有80903个不同的k-grams）</p><h2 id="EVALUATION-CLUSTER-LABELS"><a href="#EVALUATION-CLUSTER-LABELS" class="headerlink" title="EVALUATION: CLUSTER LABELS"></a>EVALUATION: CLUSTER LABELS</h2><p>接下来分析Whisper和人人网的行为集群并证明了它们在识别意外行为和预测未来活动方面的有效性。</p><p>评估包括三个步骤：</p><ul><li>为了评估理解和标记行为集群的容易程度，进行了一项用户研究。要求参与者阅读集群信息并描述相应的用户行为，然后检查不同的人是否给出了一致的描述。</li><li>对异常行为集群进行了深入的案例研究，并为这两个网络提供了新的见解。</li><li>评估集群的质量。</li></ul><h3 id="User-Study-to-Interpret-Clusters"><a href="#User-Study-to-Interpret-Clusters" class="headerlink" title="User Study to Interpret Clusters"></a>User Study to Interpret Clusters</h3><p>要求参与者使用可视化工具（Packed Circle界面）浏览行为集群，只使用Whisper集群（图3），只查看覆盖90%用户的顶级集群（总共37个集群）。</p><h3 id="User-Study-Results"><a href="#User-Study-Results" class="headerlink" title="User Study Results"></a>User Study Results</h3><p>收集了参与者对37组个集群的555个描述（每个集群15个描述），发现行为集群对参与者来说是可以理解的。</p><p>然后为了了解描述的“一致性”，让3名外部专家独立阅读和评估收集的描述。对于每个集群，专家读取所有15个描述并打上一致性分数（范围0到1）=一致性描述的数量/所有描述的数量。一致性得分分布显示在图8。</p><p>在检查一致性得分较低的集群时有两个关键的观察结果：</p><ul><li>较低级别的集群更难解释，图9显示聚类层次越低，平均一致性得分越低，说明较低级别的集群表示更具体的甚至是难以描述的异常行为。</li><li>具有更多selected features的簇更难解释。</li></ul><p>最后根据用户研究的描述和作者自己的解释，在Whisper和人人网数据集的顶级集群中添加了短标签（就是图3和图4里那些命名）。</p><h2 id="EVALUATION-CASE-STUDIES"><a href="#EVALUATION-CASE-STUDIES" class="headerlink" title="EVALUATION: CASE STUDIES"></a>EVALUATION: CASE STUDIES</h2><p>两个目标：</p><ul><li>通过分析集群中的用户行为来验证集群标签的正确性。</li><li>探讨有趣的（或意想不到的）用户行为，并展示用户行为模型的预测能力。</li></ul><h3 id="Case-Study-1-Inactive-Whisper-Users"><a href="#Case-Study-1-Inactive-Whisper-Users" class="headerlink" title="Case Study 1: Inactive Whisper Users"></a>Case Study 1: Inactive Whisper Users</h3><p>Whisper Cluster#2，标签是不活跃用户（inactive users），selecte features几乎是由“接收通知”事件组成，表明这些用户在app中根本不活跃。图10是用户在点击流中进行了活跃事件的天数，明显这一类用户是很少的。</p><p>这里表明算法成功地将休眠用户分组到一个单独的子集群中，并且不是少数群体而是第二大群体。</p><h4 id="Predicting-Dormant-Users"><a href="#Predicting-Dormant-Users" class="headerlink" title="Predicting Dormant Users"></a><em>Predicting Dormant Users</em></h4><p>高层次上的思路：Whisper使用用户最近的点击流来构建行为模型，并定期（例如每月）更新模型。本文的假设是处于“非活动”集群中的用户更有可能完全休眠，因此可以使用非活动集群来预测未来的休眠用户。通过调查“非活动”集群中的用户是否会随时间迁移到“休眠”集群来验证这一假设。</p><p><strong>文中的不活跃（inactive）用户和休眠（dormant）用户是不同的两类。</strong></p><p>表4比较来自两个相邻快照的集群，以确定用户迁移到休眠集群的可能性。将点击流数据分成三个快照，然后记录从两个相邻的快照迁移到休眠集群的用户数，显示出处于半休眠集群中的用户比其他用户更容易迁移到休眠集群中。</p><h3 id="Case-Study-2-Hostile-Behaviors-of-Whisper-Chatters"><a href="#Case-Study-2-Hostile-Behaviors-of-Whisper-Chatters" class="headerlink" title="Case Study 2: Hostile Behaviors of Whisper Chatters"></a>Case Study 2: Hostile Behaviors of Whisper Chatters</h3><p>Whisper Cluster#4，在私聊时经常屏蔽某些人。图11显示这个集群中的用户执行屏蔽操作的频率要高得多。</p><p>探讨屏蔽事件的可能原因：假设是Cluster#4中的用户更容易发布公开的Whisper，从而吸引不必要的聊天者来骚扰他们。表5中列出了Cluster#4内外用户的行为统计数据，Cluster#4中的用户更积极地发布公开的Whisper，会吸引更多人的点赞和回复，用了具有统计学意义的Welch双样本T检验（<a href="http://www.statskingdom.com/150MeanT2uneq.html">Welch two-sample t-tests</a>）显示Cluster#4内外用户的显著不同。</p><p>表6列出了Cluster#4内外用户的热门关键字，关键字根据它们与集群的关联程度进行排序。显示出Cluster#4发布的Whisper有更多的露骨信息。</p><h4 id="Users-Who-Get-Blocked"><a href="#Users-Who-Get-Blocked" class="headerlink" title="Users Who Get Blocked"></a><em>Users Who Get Blocked</em></h4><p>在Cluster#4里有1412个用户经常被他人屏蔽（图12里的4-2-1），然后图13显示这些人就是经常被屏蔽。现在的问题是：双向屏蔽是不是经常发生的？不过文中的数据集不能直接记录到双向屏蔽，然后采用了一种近似的方法：若互相屏蔽间隔在1h内就把这两个事件配对。然后图14就显示Cluster#4中有更多的成对屏蔽事件，特别是4-2-1。</p><h3 id="Case-Study-3-Renren-Sybil-Accounts"><a href="#Case-Study-3-Renren-Sybil-Accounts" class="headerlink" title="Case Study 3: Renren Sybil Accounts"></a>Case Study 3: Renren Sybil Accounts</h3><p>分析人人网中的Sybil账户，系统成功将95%的真正Sybil账户分在了一块。selected features表明倾向于更多地发送好友请求。</p><p>此外，在Sybil账户发现了更多的子集群，表明有多种不同的攻击策略（表7）。</p><h2 id="EVALUATION-CLUSTER-QUALITY"><a href="#EVALUATION-CLUSTER-QUALITY" class="headerlink" title="EVALUATION: CLUSTER QUALITY"></a>EVALUATION: CLUSTER QUALITY</h2><p>将本文算法与现有的聚类方法进行了比较。</p><h3 id="Clustering-Quality"><a href="#Clustering-Quality" class="headerlink" title="Clustering Quality"></a>Clustering Quality</h3><p>RQ：给定一个小样本的已知用户，如何准确地检索到相同类型的其他用户？</p><h4 id="Experiment-Setups"><a href="#Experiment-Setups" class="headerlink" title="Experiment Setups"></a><em>Experiment Setups</em></h4><p>举例：假设知道一个小样本的Sybil账户（x%），使用已知样本作为seeds，对人人网数据集的行为集群进行着色。任何包含已知Sybil的集群都将被着色为Sybil-cluster。然后使用两个指标来评估准确性：Precision（Sybil-cluster中真正的Sybil帐户的用户百分比）和Recall（Sybil-cluster中捕获的真实Sybil账户的百分比，也就是除去了原有已知样本的数量）。然后x取不同的值，重复实验10次。</p><h4 id="Comparison-Baselines"><a href="#Comparison-Baselines" class="headerlink" title="Comparison Baselines"></a><em>Comparison Baselines</em></h4><p>与K-Means和层次聚类两种算法作对比。对于K的取值采用了最高模块度（modularity）的值。</p><h4 id="Results"><a href="#Results" class="headerlink" title="Results"></a><em>Results</em></h4><p>图15展示了三种算法在三类用户上的Precision和Recall，表明本算法质量较高。</p><h2 id="CONCLUSION-amp-FUTURE-WORK"><a href="#CONCLUSION-amp-FUTURE-WORK" class="headerlink" title="CONCLUSION &amp; FUTURE WORK"></a>CONCLUSION &amp; FUTURE WORK</h2><p>总结就是重述了一遍INTRODUCTION里的话。</p><h4 id="Broader-Applications"><a href="#Broader-Applications" class="headerlink" title="Broader Applications"></a><em>Broader Applications</em></h4><p>可以推广到在线社交网络之外，可以从他们的HTTP日志中提取对应的“用户事件”。对于其他服务，特定事件将取决于服务功能。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 聚类 </tag>
            
            <tag> 可视化 </tag>
            
            <tag> 相似度 </tag>
            
            <tag> 点击流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文精读笔记——ViSeq：Visual Analytics of Learning Sequence in Massive Open Online Courses</title>
      <link href="2020/08/06/ViSeq/"/>
      <url>2020/08/06/ViSeq/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>为了借鉴《<a href="https://ieeexplore.ieee.org/abstract/document/8477163">ViSeq: Visual Analytics of Learning Sequence in Massive Open Online Courses</a>》中3.1中的相似度计算方法，精读了这一篇文章，作以下笔记，笔记内容偏向关注文章中和相似度计算有关的部分，另外还简略看了一下关系度较高的两篇参考文献，也作了一点记录。</p><h1 id="ViSeq-Visual-Analytics-of-Learning-Sequence-in-Massive-Open-Online-Courses"><a href="#ViSeq-Visual-Analytics-of-Learning-Sequence-in-Massive-Open-Online-Courses" class="headerlink" title="ViSeq: Visual Analytics of Learning Sequence in Massive Open Online Courses"></a><a href="https://ieeexplore.ieee.org/abstract/document/8477163">ViSeq: Visual Analytics of Learning Sequence in Massive Open Online Courses</a></h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>背景：由于更多的工作只研究aggregated events而不关注sequence of learning activities</p><p>ViSeq：可视化的分析系统，实现不同学习群体学习序列的可视化，更好地理解学习行为背后的原因</p><p>ViSeq包含四个链接视图：用于识别学习者分组的投影视图（projection view）、用于显示某个选定的学习者群体内整体序列模式的模式视图（pattern view）、用于说明连续事件之间转换的序列视图（sequence view）、带有扩展序列链的用来比较选中的一些个人学习序列的个人视图（individual view）</p><p>Case studies和expert interviews：用来评估该系统</p><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2><p>MOOC现状：学生并非按照设计的学习顺序进行学习。</p><p>现有研究大多基于统计基础上的（statistical grounds）、具有一些显性特征的指标（with a few dominant features），忽略了某些特定方面（some specific aspects）。</p><p>现有可视化工作：主要集中在一个聚合的层次上（focused on an aggregated level），消除了顺序上的信息（eliminates sequential information）</p><p>ViSeq的目的：利用序列模式的挖掘工具去检测序列性模式，从多个粒度层次对不同类型学生的学习序列进行可视化，并分析他们学习行为背后的故事或原因。</p><p>基于三个不同MOOC的真实数据集进行案例研究（Case studies）</p><p>采访了几位领域专家对系统进行了评估（expert interviews）</p><p>文章主要贡献：</p><ul><li>一个交互式的多层次视觉分析系统：帮助教师探索各种类型的学习序列，以检测不同的学习群体，并了解学习序列与表现之间的潜在相关性。</li><li>一种增广序列设计：发现个体学习行为序列</li><li>从基于真实数据集和专家访谈从案例研究中获得见解，以指导有效的课程设计。</li></ul><h2 id="2-RELATED-WORK"><a href="#2-RELATED-WORK" class="headerlink" title="2 RELATED WORK"></a>2 RELATED WORK</h2><h3 id="2-1-MOOC-Analytics"><a href="#2-1-MOOC-Analytics" class="headerlink" title="2.1 MOOC Analytics"></a>2.1 MOOC Analytics</h3><ul><li>学习者的参与度与学习成绩</li><li>MOOC课程的设计</li><li>自我管理式学习（SRL）</li><li>社会网络分析与在社交网络影响下的学习</li><li>学习动机和MOOC学习成功的标准</li></ul><h3 id="2-2-Learning-Sequence-Analytics"><a href="#2-2-Learning-Sequence-Analytics" class="headerlink" title="2.2 Learning Sequence Analytics"></a>2.2 Learning Sequence Analytics</h3><p>提到参考文献[22]：D. H. Shanabrook, D. G. Cooper, B. P. Woolf, and I. Arroyo, “Identifying high-level student behavior using sequence-based motif discovery,” in Proc. 3rd Int. Conf. Educational Data Mining, 2010, pp. 191–200. 提出了一种半自动的方法来识别学生在完成单一作业时的状态，其中采用基于序列的模体发现方法识别高水平的学生行为，然后从30个动机分组中归纳出7个不同的有意义的组。</p><h3 id="2-3-Event-Sequence-Visualization"><a href="#2-3-Event-Sequence-Visualization" class="headerlink" title="2.3 Event Sequence Visualization"></a>2.3 Event Sequence Visualization</h3><p>提到参考文献[26]：J. Wei, Z. Shen, N. Sundaresan, and K.-L. Ma, “Visual cluster exploration of web clickstream data,” in Proc. IEEE Conf. Visual Analytics Sci. Technol., 2012, pp. 3–12. 实现了一个自组织映射来对web的点击流数据进行聚类和可视化。</p><h2 id="3-PROBLEM-CHARACTERIZATION"><a href="#3-PROBLEM-CHARACTERIZATION" class="headerlink" title="3 PROBLEM CHARACTERIZATION"></a>3 PROBLEM CHARACTERIZATION</h2><h3 id="3-1-Data-Preprocessing"><a href="#3-1-Data-Preprocessing" class="headerlink" title="3.1 Data Preprocessing"></a>3.1 Data Preprocessing</h3><p>数据来源：3个edX的课程，日志数据包括视频观看、测验问题访问和讨论发布（数据情况详情参照Table1），缺少学习者的背景信息</p><p>用一个序列S表征每一个学习者的行为，共n个事件。</p><p>为了根据学习序列对学习者进行分组：基于学习序列建立相似度矩阵（similarity matrix）——</p><ul><li>为了解决序列冗长且长度不一样的问题：从原始序列中提取子序列作为特征来比较相似度（参照文献[27]），Tk(S)定义为序列S中长度为k的子序列（k-grams）的集合。</li><li>为了让两个不等长序列达到统一长度来计算距离：定义T = Tk(S1)∪Tk(S2)，T长度为n。</li><li>然后计算T中每个子序列在两个序列中分别出现的归一化频数，分别存入两个序列对应的一个数组中（该数组长度为n）。则该数组为一个n维的向量，两个向量算余弦公式的反函数得出两个序列的polar distance。</li><li>这个polar distance取值范围为0到1，结果越小，距离越小，相似度越大。</li><li>在文中数据集作者测试了k从1到10的取值，发现k=5时效果最好，呈现出最明显的模式（presents the most distinct patterns）。</li></ul><p>在建立相似度矩阵之后，<strong>根据学习者的相似性将其投影到二维空间</strong>。投影方法选择t-SNE：通过将数据点之间的相似性转换为联合概率，并在二维地图中为每个数据点提供一个位置，来可视化高维数据，以更清楚地看到学习者的分组。</p><p>每次用户选中一个分组，将采用序列挖掘算法VMSP挖掘最大序列模式。介绍<a href="http://www.philippe-fournier-viger.com/spmf/">SPMF</a>：一个开源的序列数据挖掘库平台，包括MaxSP、VMSP、VGEN、FEAT、FSGP等算法，作者对每种算法测试了结果并选择了VMSP算法。VMSP的选择参考了文献[31]：Z. Liu, Y. Wang, M. Dontcheva, M. Hoffman, S. Walker, and A. Wilson, “Patterns and sequences: Interactive exploration of clickstreams to understand common visitor paths,” IEEE Trans. Vis. Comput. Graph., vol. 23, no. 1, pp. 321–330, Jan. 2017.</p><h3 id="3-2-Task-Analysis"><a href="#3-2-Task-Analysis" class="headerlink" title="3.2 Task Analysis"></a>3.2 Task Analysis</h3><p>T1：能否根据学习顺序确定任何学习者群体，并得知这些群体的分布情况？</p><p>T2：不同学习群体的典型学习序列模式是什么？</p><p>T3：对于不同的学习者群体，连续事件之间的非线性的转换（Non-Linear Transitions）的概况如何？大多数MOOC都有一个设计好的学习顺序，课程设计好的连续事件之间的转换定义为线性转换（Linear Transitions）。相对而言学生不遵循顺序的、个性化学习里的跳转则称为非线性转换。</p><p>T4：对于一个指定的事件（课程资源里的某个特定的视频、某次作业等）的前后连续事件是什么？用于了解用户在这个特定事件之前和之后是如何进行他们的活动。</p><p>T5：学习序列的时间差异是什么？时间信息影响学生的学习方式，尤其是当他们第一次学习和复习测验或考试时。因此，需要时间过滤功能来帮助用户研究这种模式的不同。</p><p>T6：个人学习序列是什么样的？确切地了解学生在不同课程期间的表现、深入到特定的学习者中，一个可以支持不同粒度级别的系统是有帮助的。</p><p>T7：每个个人序列与其他人的序列有何区别？如何找到相似或不同的个体？这是基于T6提出的一个问题：调查完某个个体的学习序列之后，需要找到其他学习者是否与所选个体具有相似的序列。通过一个相似度排序功能直接对不同的个体序列与该选定个体进行比较。它可能会启发教师向学生提供建议，例如“根据与你有相似学习顺序的学生的表现，你很有可能通过重温这些学习单元赶上课程。”——这是基于相似用户行为序列的一个学习建议推荐。</p><h3 id="3-3-Design-Rationales"><a href="#3-3-Design-Rationales" class="headerlink" title="3.3 Design Rationales"></a>3.3 Design Rationales</h3><p>系统设计的基本原则：</p><p>R1：帮助快速识别学习者群体和最常见的模式</p><p>R2：逐步显示足够的信息量。“概况放在首位，细节通过指令呈现”的原则，遵循从一般到详细的分析任务，从简单到复杂实现这些可视化。提供了四种不同的可视化效果：散点图、弦图、弧图和增强链图。</p><p>R3：支持即时反馈的交互式过滤。系统提供直接选择的可视化功能和单独的控制面板进行精确过滤。</p><p>R4：为多个视图进行一致的设计和适当的链接。</p><h2 id="4-VISUALIZATION-DESIGN"><a href="#4-VISUALIZATION-DESIGN" class="headerlink" title="4 VISUALIZATION DESIGN"></a>4 VISUALIZATION DESIGN</h2><h3 id="4-1-System-Overview"><a href="#4-1-System-Overview" class="headerlink" title="4.1 System Overview"></a>4.1 System Overview</h3><p>系统顶部可以选择要浏览的课程，主界面参照图1。</p><p>（a）为投影视图（projection view），以散点图形式依据学习序列的相似度来表示学习者，可以识别学习者分组。</p><p>（b）为模式视图（pattern view），罗列通过VMSP算法检测出来的序列模式，并以条形图的形式显示出现的频率。</p><p>（c）和（d）为序列视图（sequence view），一个交互式的三级和弦图。（c）是周与周之间的，（d）是一周内的情况。</p><p>（e）为个人视图（individual view），由顶部弹窗进入，显示整个课程期间学习者的个体学习顺序。</p><p>每个视图都有一个独立的控制面板来过滤（FILTER）学习者的成绩、课程时间段。</p><h3 id="4-2-Visual-Encoding"><a href="#4-2-Visual-Encoding" class="headerlink" title="4.2 Visual Encoding"></a>4.2 Visual Encoding</h3><p>矩形、圆形和三角形三种形状分别用于编码三种类型的学习事件，即视频观看、作业练习和论坛讨论。</p><p>不同的颜色用来代表不同的星期。</p><h4 id="4-2-1-Projection-View"><a href="#4-2-1-Projection-View" class="headerlink" title="4.2.1 Projection View"></a>4.2.1 Projection View</h4><p>为了便于对有意义的模式进行研究，应用VMSP算法挖掘出的序列模式还进行了分类、进一步支持搜索功能，允许用户过滤出感兴趣的模式。</p><p>投影视图显示为所有学生的散点图，其中每个学生由一个节点表示。<strong>基于学习者在整个课程期间的序列相似性完成了投影视图，来发现学习者组</strong>，并确定不同组的总体学习者分布（这里完成了<strong>T1</strong>）。</p><p>预定义的时间段是整个学期，还可以在控制面板筛选更具体的持续时间，同时设定成绩阈值过滤不及格学生等。用户可以通过在散点图上用矩形框直接进行选择，选中一部分学习者（符合了<strong>R1</strong>）。</p><p>此视图与其他视图链接起来以便用户可以在不同的视图中看到同一组学习者的可视化效果（符合了<strong>R4</strong>）。</p><h4 id="4-2-2-Pattern-View"><a href="#4-2-2-Pattern-View" class="headerlink" title="4.2.2 Pattern View"></a>4.2.2 Pattern View</h4><p>模式视图展示不同学习者组的典型学习序列模式（完成了<strong>T2</strong>）。</p><p>从投影视图中选择一个学习者组后，模式视图显示从VMSP中挖掘的所有序列模式，并在左侧显示其条形图表示出现频率。每个条形图的长度代表具有该序列模式的学习者的数量。每一行显示一个挖掘的序列模式，每个事件用彩色矩形、圆形和三角形标记。</p><p>允许用户通过根据模式长度进行排序或基于不同的持续时间对序列模式进行分类。提供模式查询功能来过滤指定的事件（图1b中打开的QUERY窗口），提供对某个事件或一组事件的包含和排除。</p><h4 id="4-2-3-Sequence-View"><a href="#4-2-3-Sequence-View" class="headerlink" title="4.2.3 Sequence View"></a>4.2.3 Sequence View</h4><p>序列视图由一个三级交互图组成，用于从不同的细节层次（<strong>T3</strong>、<strong>T4</strong>）和不同视角（<strong>T5</strong>）可视化连续事件之间的非线性转换。</p><p>图1c以和弦图来演示两周之间的转换，不同周之间的流入和流出是分开的，每个流的宽度表示具有该转换的学习者的数量（鼠标停在这个流上会显示具体数值）。</p><p>图2是比较不同学习群体的学习序列的应用。将学生的成绩从高到低排列分成A到E五个组，O代表整个学生群体。</p><p>点击转换流，这些学习者的分数分布的直方图出现在底部，如图1中c和d两张图的底部所示（符合了<strong>R3</strong>）。</p><p>当单击序列视图中选定的圆圈边缘时，会打开对应周的同一周内的事件序列转换时（第二级视图），然后会显示一个弧形图（图3a）。其中结构化事件在选定的一周内垂直对齐，右侧的圆弧表示向前过渡，而左侧的圆弧表示向后跳转（完成了<strong>T3</strong>）。</p><p>在第二级视图上选定中间的某个特定元素，将展开第三级视图（图3b），描述了某个特定事件的前序和后续事件，左右两条垂直条形图显示了前序和后续事件中的不同事件的分类（完成了<strong>T4</strong>）。时间范围和学习者等级也可用于在控制面板中过滤学习者（完成了<strong>T5</strong>）。</p><h4 id="4-2-4-Individual-View"><a href="#4-2-4-Individual-View" class="headerlink" title="4.2.4 Individual View"></a>4.2.4 Individual View</h4><p>个人视图位于单独的弹出窗口中，而不是作为主界面的一部分。</p><p>图4：事件按时间顺序排列，每个小形状表示一个事件，形状表示事件类型，颜色表示该事件所属的周。利用折线图来表示连续事件之间的距离，若按照设计的课程顺序则画一条直线来连接，若向前跳过了几个学习单元则使用上三角线连接，若回顾之前的学习单元则画一条较低的三角形线。当其中一个事件是期末考试问题时，用一条矩形线来更明确地显示转换。三角形或矩形线的高度表示两个连续事件之间的相对距离。（完成了<strong>T6</strong>）</p><p>为了便于搜索相似的学习者，<strong>使用了先前计算的相似度矩阵</strong>，当用户选中一个感兴趣的个体时，其他个体序列根据与所选个体的相似度进行排序（完成了<strong>T7</strong>）。</p><h2 id="5-CASE-STUDIES"><a href="#5-CASE-STUDIES" class="headerlink" title="5 CASE STUDIES"></a>5 CASE STUDIES</h2><p>三个实验课程，J1和J2是同一个课程的不同课程结构（一个10周，一个5周），E1是另一门语言类课程。</p><h3 id="5-1-Learner-Grouping-and-Typical-Sequential-Patterns"><a href="#5-1-Learner-Grouping-and-Typical-Sequential-Patterns" class="headerlink" title="5.1 Learner Grouping and Typical Sequential Patterns"></a>5.1 Learner Grouping and Typical Sequential Patterns</h3><p>图6：对三门课程中成绩合格的学生（60分以上）进行筛选时，前两门课程有两个明显的分组，而第三个课程只出现一个明显的分组。（A）~（C）显示了所识别组的典型个体序列，其中（A）和（C）中有较多的代表期末考试周频繁跳转的矩形线，具有相似模式。</p><h3 id="5-2-Non-linear-Transitions-from-Different-Levels-of-Detail"><a href="#5-2-Non-linear-Transitions-from-Different-Levels-of-Detail" class="headerlink" title="5.2 Non-linear Transitions from Different Levels of Detail"></a>5.2 Non-linear Transitions from Different Levels of Detail</h3><p>延续5.1节的结果，学习者在期末考试中有两种典型的方式，因此继续挖掘不同的学习者准备期末考试的方式是否也不同。筛选出考试前一周的Sequence View（图7），高分学习者开始复习前几周的视频（a），低分学习者仍在努力学习前一周的材料（b）。</p><p>点击随机一周的边界打开第二级视图（图8），将阈值设置为100隐藏少于100个学习者的流（a），选中一个特定的序列路径来过滤来自同一组学习者的学习序列（b）。</p><h3 id="5-3-Individual-Sequence-Exploration-and-Comparison"><a href="#5-3-Individual-Sequence-Exploration-and-Comparison" class="headerlink" title="5.3 Individual Sequence Exploration and Comparison"></a>5.3 Individual Sequence Exploration and Comparison</h3><p>从5.2的Sequence View中第三级视图中选定某个学生进入Individual View，图9展示了两种不同类型的跳转行为。</p><h2 id="6-EXPERT-INTERVIEW"><a href="#6-EXPERT-INTERVIEW" class="headerlink" title="6 EXPERT INTERVIEW"></a>6 EXPERT INTERVIEW</h2><p>通过采访4位专家描述了这个系统的可用性、视觉设计和互动。</p><h2 id="7-DISCUSSION"><a href="#7-DISCUSSION" class="headerlink" title="7 DISCUSSION"></a>7 DISCUSSION</h2><h3 id="7-1-System-Limitations"><a href="#7-1-System-Limitations" class="headerlink" title="7.1 System Limitations"></a>7.1 System Limitations</h3><p>相似性度量中时间信息的损失：选择当前的相似性度量方法是因为它能更好地反映不同长度序列的相似性——特别是与传统的相似性度量如编辑距离相比，然而这个度量丢失了时间信息。为了减少这种信息损失，作者提到计划探索基于哈希的技术来加快计算速度。这样，当用户选择一个特定的时间段时，我们可以用过滤后的序列更新投影视图。因此，不同的行为不太可能会被计算为相似行为。</p><p>另外提到可伸缩性的问题、缺乏对学习序列的内容感知分析、在探索过程中缺乏并行比较的支持、挖掘到的学习序列模式与学习结果（如平均成绩、退学率等）之间缺乏视图上的联系等问题。</p><h3 id="7-2-Design-Reflection"><a href="#7-2-Design-Reflection" class="headerlink" title="7.2 Design Reflection"></a>7.2 Design Reflection</h3><p>散点图有助于识别具有相似序列的学习者分组，和弦图显示了不同周之间的非线性转换，而弧图则显示了同一周内的转换。</p><p>T4本质上是T3的一个子任务。</p><h3 id="7-3-Generalizations（通用化）"><a href="#7-3-Generalizations（通用化）" class="headerlink" title="7.3 Generalizations（通用化）"></a>7.3 Generalizations（通用化）</h3><p>这类应用不仅可以应用于在线教育领域，也可以应用于其他事件序列数据分析。提到ViSeq是一个非常通用的系统，可以适应不同的应用领域。</p><h3 id="7-4-Implications-for-the-Education-Domain"><a href="#7-4-Implications-for-the-Education-Domain" class="headerlink" title="7.4 Implications for the Education Domain"></a>7.4 Implications for the Education Domain</h3><p>总结了在教育学领域的三个潜在方向：</p><ul><li>利用学生的实际学习序列来检验教学假设，并通知教师重新设计课程。</li><li>促进个性化推荐，促进自主学习。</li><li>在设计面向学生的可视化面板时，遵循所谓“成功”学生的学习轨迹。</li></ul><h2 id="8-CONCLUSION-AND-FUTURE-WORK"><a href="#8-CONCLUSION-AND-FUTURE-WORK" class="headerlink" title="8 CONCLUSION AND FUTURE WORK"></a>8 CONCLUSION AND FUTURE WORK</h2><h3 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h3><ul><li><p>重述了ViSeq的四个视图作用：（a）识别学习者群体的投影视图；（b）识别最频繁的学习序列模式的模式视图；（c）探索连续事件之间转换的序列视图；（d）呈现每个学习者序列并比较相似个体的个体视图。</p></li><li><p>使用了多种交互技术：过滤、搜索、突出显示、排序和历史回调。</p></li><li><p>介绍了相似度计算和学习者分组的方法。</p></li><li><p>通过与领域专家的访谈总结出的分析任务。</p></li></ul><h3 id="FUTURE-WORK"><a href="#FUTURE-WORK" class="headerlink" title="FUTURE WORK"></a>FUTURE WORK</h3><ul><li>提交作业的成绩信息可用于探索更有意义的学习模式。</li><li>年龄、语言和教育背景信息也可能有助于识别不同的学习者群体，并解释原因。</li><li>将较长的序列模式可视化，用于分组级的分析。高阶网络（HoN）可以通过创建额外的节点来表示高阶相关性来研究较长的序列模式（参考文献[54]）。</li></ul><h1 id="参考文献54：HoNVis-Visualizing-and-Exploring-Higher-Order-Networks"><a href="#参考文献54：HoNVis-Visualizing-and-Exploring-Higher-Order-Networks" class="headerlink" title="参考文献54：HoNVis: Visualizing and Exploring Higher-Order Networks"></a>参考文献54：<a href="https://ieeexplore.ieee.org/abstract/document/8031572/">HoNVis: Visualizing and Exploring Higher-Order Networks</a></h1><p>高阶网络（HoN）：通过创建额外的节点来编码高阶的相关性，提供了更准确的转换描述。</p><p>文章提出了一个新的视觉分析框架来探索全球海运网络的高阶相关性，利用多个视图从三个级别（全球、某地和单个港口级别）显示海运网络的结构。最后讨论了该框架在其他实际应用中的可推广性，提到了社交网络中的信息传播。将电话或推特转发视为船舶轨迹，HoNVis可以用于探索信息传播模式。</p><h1 id="参考文献27：Unsupervised-Clickstream-Clustering-for-User-Behavior-Analysis"><a href="#参考文献27：Unsupervised-Clickstream-Clustering-for-User-Behavior-Analysis" class="headerlink" title="参考文献27：Unsupervised Clickstream Clustering for User Behavior Analysis"></a>参考文献27：<a href="https://dl.acm.org/doi/abs/10.1145/2858036.2858107">Unsupervised Clickstream Clustering for User Behavior Analysis</a></h1><p>研究面向用户行为分析的无监督点击流聚类，建立了一个无监督的系统，从点击流数据（用户点击事件的痕迹）中捕捉用户行为，并以直观的方式可视化检测到的行为。通过划分相似图来识别相似用户的集群（图3和图4）</p><p>在第4页的<strong>Clickstream and Similarity Graph</strong>中提到了ViSeq文章中参考的k-grams和polar distance（描述基本一样）。</p><p>在后面的<strong>Feature Pruning based Clickstream Clustering</strong>分析中提到采用Divisive Hierarchical Clustering算法，分层聚类步骤在图1中描述，可以用于任意矩阵空间和发现任意的聚类形状。该算法的参考文献[13]： L. Kaufman and P. Rousseeuw. 2009. Finding groups in data: an introduction to cluster analysis. Vol. 344. John Wiley &amp; Sons. </p><p>另外提到为了确定聚类的个数（<em>Determining the Number of Subclusters</em>）采用了模块度（Modularity），用于测量簇内边缘到簇外边缘的密度。参考文献[4]：V. D. Blondel, J. Guillaume, R. Lambiotte, and E. Lefebvre. 2008. Fast unfolding of communities in large networks. JSTAT 2008, 10 (2008).</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 聚类 </tag>
            
            <tag> 可视化 </tag>
            
            <tag> MOOC </tag>
            
            <tag> 相似度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark2.4.6安装教程</title>
      <link href="2020/07/22/Spark2.4_setup/"/>
      <url>2020/07/22/Spark2.4_setup/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>本文大部分内容转载于<a href="http://dblab.xmu.edu.cn/blog/2501-2/">Spark安装和编程实践（Spark2.4.0）</a>，另附上一点本人安装过程中的记录，以备参考。</p><h1 id="安装-Spark2-4"><a href="#安装-Spark2-4" class="headerlink" title="安装 Spark2.4"></a>安装 Spark2.4</h1><p>首先需要下载Spark安装文件。推荐下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-2.4.6/">清华源</a>和<a href="http://mirror.hust.edu.cn/apache/spark/spark-2.4.6/">华科源</a>，原文是下载Spark2.4.0，但目前已经更新到2.4.6了，所以就选择spark-2.4.6-bin-without-hadoop.tgz下载即可。</p><p>本教程的具体运行环境如下：</p><ul><li>Hadoop 3.1.3</li><li>Java JDK 1.8</li><li>Spark 2.4.0</li></ul><p>Hadoop和Java JDK的安装参照<a href="http://blog.cuper.top/2020/07/21/Hadoop3.1.3_setup/">Hadoop3.1.3安装教程：单机&amp;伪分布式配置</a>。</p><h1 id="安装Spark（Local模式）"><a href="#安装Spark（Local模式）" class="headerlink" title="安装Spark（Local模式）"></a>安装Spark（Local模式）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxf ~/下载/spark-2.4.0-bin-without-hadoop.tgz -C /usr/<span class="built_in">local</span>/</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span></span><br><span class="line">sudo mv ./spark-2.4.0-bin-without-hadoop/ ./spark</span><br><span class="line">sudo chown -R hadoop:hadoop ./spark          <span class="comment"># 此处的 hadoop 为你的用户名</span></span><br></pre></td></tr></table></figure><p>安装后，还需要修改Spark的配置文件spark-env.sh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/spark</span><br><span class="line">cp ./conf/spark-env.sh.template ./conf/spark-env.sh</span><br></pre></td></tr></table></figure><p>编辑spark-env.sh文件(vim ./conf/spark-env.sh)，在第一行添加以下配置信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_DIST_CLASSPATH=$(/usr/local/hadoop/bin/hadoop classpath)</span><br></pre></td></tr></table></figure><p>配置完成后就可以直接使用，不需要像Hadoop运行启动命令。<br>通过运行Spark自带的示例，验证Spark是否安装成功。执行时会输出非常多的运行信息，输出结果不容易找到，可以通过 grep 命令进行过滤（命令中的 2&gt;&amp;1 可以将所有的信息都输出到 stdout 中，否则由于输出日志的性质，还是会输出到屏幕中）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/spark</span><br><span class="line">bin/run-example SparkPi 2&gt;&amp;1 | grep <span class="string">&quot;Pi is&quot;</span></span><br></pre></td></tr></table></figure><p>过滤后的运行结果如下图示，这里我得到了π的15位小数近似值（这个程序每次运行结果是不一样的）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop@cuper-Inspiron-7591:/usr/<span class="built_in">local</span>/spark$ bin/run-example SparkPi 2&gt;&amp;1 | grep <span class="string">&quot;Pi is&quot;</span></span><br><span class="line">Pi is roughly 3.137155685778429</span><br></pre></td></tr></table></figure><h1 id="使用-Spark-Shell-编写代码"><a href="#使用-Spark-Shell-编写代码" class="headerlink" title="使用 Spark Shell 编写代码"></a>使用 Spark Shell 编写代码</h1><p>学习Spark程序开发，建议首先通过spark-shell交互式学习，加深Spark程序开发的理解。<br>Spark shell 提供了简单的方式来学习 API，也提供了交互的方式来分析数据。</p><h2 id="启动Spark-Shell"><a href="#启动Spark-Shell" class="headerlink" title="启动Spark Shell"></a>启动Spark Shell</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/spark</span><br><span class="line">bin/spark-shell</span><br></pre></td></tr></table></figure><p>启动spark-shell后，会自动创建名为sc的SparkContext对象和名为spark的SparkSession对象，如图：</p><p><img src="http://img.cuper.top/2020-07-22%2011-04-37%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><h2 id="加载text文件"><a href="#加载text文件" class="headerlink" title="加载text文件"></a>加载text文件</h2><p>spark创建sc，可以加载本地文件和HDFS文件创建RDD。这里用Spark自带的本地文件README.md文件测试。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> textFile = sc.textFile(<span class="string">&quot;file:///usr/local/spark/README.md&quot;</span>)</span><br></pre></td></tr></table></figure><p>加载HDFS文件和本地文件都是使用textFile，区别是添加前缀(hdfs://和file:///)进行标识。</p><p>加载完成后：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> textFile = sc.textFile(<span class="string">&quot;file:///usr/local/spark/README.md&quot;</span>)</span><br><span class="line">textFile: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = file:<span class="comment">///usr/local/spark/README.md MapPartitionsRDD[1] at textFile at &lt;console&gt;:24</span></span><br></pre></td></tr></table></figure><h2 id="简单RDD操作"><a href="#简单RDD操作" class="headerlink" title="简单RDD操作"></a>简单RDD操作</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; textFile.first()<span class="comment">//获取RDD文件textFile的第一行内容</span></span><br><span class="line">res0: <span class="type">String</span> = # <span class="type">Apache</span> <span class="type">Spark</span></span><br><span class="line"></span><br><span class="line">scala&gt; textFile.count()<span class="comment">//获取RDD文件textFile所有项的计数</span></span><br><span class="line">res1: <span class="type">Long</span> = <span class="number">104</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> lineWithSpark = textFile.filter(line =&gt; line.contains(<span class="string">&quot;Spark&quot;</span>))<span class="comment">//抽取含有“Spark”的行，返回一个新的RDD</span></span><br><span class="line">lineWithSpark: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = <span class="type">MapPartitionsRDD</span>[<span class="number">2</span>] at filter at &lt;console&gt;:<span class="number">25</span></span><br><span class="line"></span><br><span class="line">scala&gt; lineWithSpark.count()<span class="comment">//统计新的RDD的行数</span></span><br><span class="line">res2: <span class="type">Long</span> = <span class="number">19</span></span><br></pre></td></tr></table></figure><p>可以通过组合RDD操作进行组合，可以实现简易MapReduce操作：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; textFile.map(line =&gt; line.split(<span class="string">&quot; &quot;</span>).size).reduce((a, b) =&gt; <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b)<span class="comment">//找出文本中每行的最多单词数</span></span><br><span class="line">res3: <span class="type">Int</span> = <span class="number">16</span></span><br></pre></td></tr></table></figure><h2 id="退出Spark-Shell"><a href="#退出Spark-Shell" class="headerlink" title="退出Spark Shell"></a>退出Spark Shell</h2><p>输入:quit（<code>exit</code>好像不行），即可退出spark shell：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:quit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 安装 </tag>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop3.1.3安装教程：单机&amp;伪分布式配置</title>
      <link href="2020/07/21/Hadoop3.1.3_setup/"/>
      <url>2020/07/21/Hadoop3.1.3_setup/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>当开始着手实践 Hadoop 时，安装 Hadoop 就是第一步。感谢林子雨教授实验室提供的<a href="http://dblab.xmu.edu.cn/blog/">Hadoop系列完整教程</a>，让我不再纠结各种博客里的差错。本文相当于转发一下系列教程中的<a href="http://dblab.xmu.edu.cn/blog/2441-2/">Hadoop3.1.3安装教程_单机/伪分布式配置_Hadoop3.1.3/Ubuntu18.04(16.04)</a>，再附上一点本人安装过程中的记录，以备参考。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>原教程使用 <strong>Ubuntu 18.04 64位</strong> 作为系统环境，本人使用 <strong>Ubuntu 20.04 64位</strong>，两个环境在操作过程中无差异。</p><h1 id="创建hadoop用户"><a href="#创建hadoop用户" class="headerlink" title="创建hadoop用户"></a>创建hadoop用户</h1><p>如果安装 Ubuntu 的时候不是用的 “hadoop” 用户（一般肯定不是），那么需要增加一个名为 hadoop 的用户，在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m hadoop -s /bin/bash</span><br></pre></td></tr></table></figure><p>这条命令创建了可以登陆的 hadoop 用户，并使用 /bin/bash 作为 shell。</p><p>接着使用如下命令设置密码，按提示输入两次密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd hadoop</span><br></pre></td></tr></table></figure><p>可为 hadoop 用户增加管理员权限，方便部署，避免一些比较棘手的权限问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser hadoop sudo</span><br></pre></td></tr></table></figure><p>最后注销当前用户，返回登陆界面。在登陆界面中选择刚创建的 hadoop 用户进行登陆。登陆后用<code>sudo apt-get update</code>更新一下。</p><p>P.S.登陆hadoop进去是一个全新的界面（相当于新装好的系统刚进去的样子），不过装的软件和搭的环境还在，只不过之前在自己主目录下的文件需要到/home/原账户名这里找，然后你会发现有一个并列的/home/hadoop文件夹就是现在的主目录。</p><h1 id="安装SSH、配置SSH无密码登陆"><a href="#安装SSH、配置SSH无密码登陆" class="headerlink" title="安装SSH、配置SSH无密码登陆"></a>安装SSH、配置SSH无密码登陆</h1><p>集群、单节点模式都需要用到 SSH 登陆，Ubuntu 默认已安装了 SSH client，此外还需要安装 SSH server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>然后ssh登陆本机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh localhost</span><br></pre></td></tr></table></figure><p>此时可能会出现以下状况（选了yes之后也连接失败）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hadoop@cuper-Inspiron-7591:~$ ssh localhost</span><br><span class="line">The authenticity of host <span class="string">&#x27;localhost (127.0.0.1)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:KdaSrcKwo3oMh/O692SC2cA0XUMScgb/mSXHb3iEI3g.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no/[fingerprint])? </span></span><br><span class="line"><span class="string">Host key verification failed.</span></span><br></pre></td></tr></table></figure><p>参考<a href="https://blog.csdn.net/stpeace/article/details/79426471?utm_source=blogxgwz5">The authenticity of host ‘localhost (127.0.0.1)’ can’t be established的处理方法</a>，去编辑/etc/ssh/ssh_config这个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/ssh/ssh_config</span><br></pre></td></tr></table></figure><p>在文件最后面加上：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StrictHostKeyChecking no</span><br><span class="line">UserKnownHostsFile /dev/null</span><br></pre></td></tr></table></figure><p>加上后的末尾大概是这个样子的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SendEnv LANG LC_*</span><br><span class="line">HashKnownHosts yes</span><br><span class="line">GSSAPIAuthentication yes</span><br><span class="line">StrictHostKeyChecking no</span><br><span class="line">UserKnownHostsFile /dev/null</span><br></pre></td></tr></table></figure><p>保存之后重新连接ssh就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">hadoop@cuper-Inspiron-7591:~$ ssh localhost</span><br><span class="line">Warning: Permanently added <span class="string">&#x27;localhost&#x27;</span> (ECDSA) to the list of known hosts.</span><br><span class="line">hadoop@localhost<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string">Welcome to Ubuntu 20.04 LTS (GNU/Linux 5.4.0-40-generic x86_64)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> * Documentation:  https://help.ubuntu.com</span></span><br><span class="line"><span class="string"> * Management:     https://landscape.canonical.com</span></span><br><span class="line"><span class="string"> * Support:        https://ubuntu.com/advantage</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1 device has a firmware upgrade available.</span></span><br><span class="line"><span class="string">Run `fwupdmgr get-upgrades` for more information.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">91 updates can be installed immediately.</span></span><br><span class="line"><span class="string">0 of these updates are security updates.</span></span><br><span class="line"><span class="string">To see these additional updates run: apt list --upgradable</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The programs included with the Ubuntu system are free software;</span></span><br><span class="line"><span class="string">the exact distribution terms for each program are described in the</span></span><br><span class="line"><span class="string">individual files in /usr/share/doc/*/copyright.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by</span></span><br><span class="line"><span class="string">applicable law.</span></span><br></pre></td></tr></table></figure><p>但这样登陆是需要每次输入密码的，我们需要配置成SSH无密码登陆比较方便。首先用<code>exit</code>退出刚才的 ssh回到原先的终端窗口，退出时的终端反馈是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hadoop@cuper-Inspiron-7591:~$ <span class="built_in">exit</span></span><br><span class="line">注销</span><br><span class="line"></span><br><span class="line">Connection to localhost closed.</span><br></pre></td></tr></table></figure><p>然后利用 ssh-keygen 生成密钥，并将密钥加入到授权中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh/</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">cat ./id_rsa.pub &gt;&gt; ./authorized_keys</span><br></pre></td></tr></table></figure><p>终端反馈大概是这个样子，其中<code>ssh-keygen -t rsa</code>这条命令中的选项直接按回车默认即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">hadoop@cuper-Inspiron-7591:~$ <span class="built_in">cd</span> ~/.ssh/</span><br><span class="line">hadoop@cuper-Inspiron-7591:~/.ssh$ ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/home/hadoop/.ssh/id_rsa): </span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /home/hadoop/.ssh/id_rsa</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /home/hadoop/.ssh/id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxx hadoop@cuper-Inspiron-7591</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|    .o .o=      o|</span></span><br><span class="line"><span class="string">还挺牛逼，有二维码内味了</span></span><br><span class="line"><span class="string">|      o++  .     |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br><span class="line"><span class="string">hadoop@cuper-Inspiron-7591:~/.ssh$ cat ./id_rsa.pub &gt;&gt; ./authorized_keys</span></span><br><span class="line"><span class="string">hadoop@cuper-Inspiron-7591:~/.ssh$ </span></span><br></pre></td></tr></table></figure><h1 id="安装Java环境"><a href="#安装Java环境" class="headerlink" title="安装Java环境"></a>安装Java环境</h1><p>如果在原来的账户里已经装好了Java的话，是不需要再去下载JDK重新安装的。只需在本账户的.bashrc文件末尾添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_162</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><p>然后令其生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>使用<code>java -version</code>测试一下查看是否安装成功，如正常会返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hadoop@cuper-Inspiron-7591:~$ java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_191&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_191-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)</span><br></pre></td></tr></table></figure><h1 id="安装-Hadoop3-1-3"><a href="#安装-Hadoop3-1-3" class="headerlink" title="安装 Hadoop3.1.3"></a>安装 Hadoop3.1.3</h1><p>首先去<a href="https://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-3.1.3/hadoop-3.1.3.tar.gz">官网</a>安装hadoop-3.1.3.tar.gz，这里官网也提供了几个国内镜像源，安装速度会快一点。</p><p>选择将 Hadoop 安装至 /usr/local/ 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxf ~/下载/hadoop-3.1.3.tar.gz -C /usr/<span class="built_in">local</span>    <span class="comment"># 解压到/usr/local中</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span><br><span class="line">sudo mv ./hadoop-3.1.3/ ./hadoop            <span class="comment"># 将文件夹名改为hadoop</span></span><br><span class="line">sudo chown -R hadoop ./hadoop       <span class="comment"># 修改文件权限</span></span><br></pre></td></tr></table></figure><p>Hadoop 解压后即可使用。输入如下命令来检查 Hadoop 是否可用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/hadoop</span><br><span class="line">./bin/hadoop version</span><br></pre></td></tr></table></figure><p>成功则会显示 Hadoop 版本信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hadoop@cuper-Inspiron-7591:/usr/<span class="built_in">local</span>/hadoop$ ./bin/hadoop version</span><br><span class="line">Hadoop 3.1.3</span><br><span class="line">Source code repository https://gitbox.apache.org/repos/asf/hadoop.git -r ba631c436b806728f8ec2f54ab1e289526c90579</span><br><span class="line">Compiled by ztang on 2019-09-12T02:47Z</span><br><span class="line">Compiled with protoc 2.5.0</span><br><span class="line">From <span class="built_in">source</span> with checksum ec785077c385118ac91aadde5ec9799</span><br><span class="line">This <span class="built_in">command</span> was run using /usr/<span class="built_in">local</span>/hadoop/share/hadoop/common/hadoop-common-3.1.3.jar</span><br></pre></td></tr></table></figure><h1 id="Hadoop单机配置-非分布式"><a href="#Hadoop单机配置-非分布式" class="headerlink" title="Hadoop单机配置(非分布式)"></a>Hadoop单机配置(非分布式)</h1><p>Hadoop 默认模式为非分布式模式（本地模式），无需进行其他配置即可运行。非分布式即单 Java 进程，方便进行调试。</p><p>现在我们可以执行例子来感受下 Hadoop 的运行。Hadoop 附带了丰富的例子（运行 <code>./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.3.jar</code> 可以看到所有例子的介绍），包括 wordcount、terasort、join、grep 等（顺便简单翻译一下）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">hadoop@cuper-Inspiron-7591:/usr/<span class="built_in">local</span>/hadoop$ ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.3.jar</span><br><span class="line">An example program must be given as the first argument.<span class="comment">#必须给出一个示例程序作为第一个参数。</span></span><br><span class="line">Valid program names are:<span class="comment">#有效的程序名为：</span></span><br><span class="line">  aggregatewordcount: An Aggregate based map/reduce program that counts the words <span class="keyword">in</span> the input files.<span class="comment">#一个基于聚合的map/reduce程序，对输入文件中的单词进行计数。</span></span><br><span class="line">  aggregatewordhist: An Aggregate based map/reduce program that computes the histogram of the words <span class="keyword">in</span> the input files.<span class="comment">#一个基于聚合的map/reduce程序，用于计算输入文件中单词的直方图。</span></span><br><span class="line">  bbp: A map/reduce program that uses Bailey-Borwein-Plouffe to compute exact digits of Pi.<span class="comment">#一个map/reduce程序，使用Bailey-Borwein-Plouffe计算Pi的精确位数。</span></span><br><span class="line">  dbcount: An example job that count the pageview counts from a database.<span class="comment">#从数据库中统计页面视图计数的示例作业。</span></span><br><span class="line">  distbbp: A map/reduce program that uses a BBP-type formula to compute exact bits of Pi.<span class="comment">#一个map/reduce程序，使用BBP类型的公式计算Pi的精确位。</span></span><br><span class="line">  grep: A map/reduce program that counts the matches of a regex <span class="keyword">in</span> the input.<span class="comment">#一个map/reduce程序，计算输入中正则表达式的匹配项。</span></span><br><span class="line">  join: A job that effects a join over sorted, equally partitioned datasets<span class="comment">#对已排序、分区相等的数据集执行join的作业</span></span><br><span class="line">  multifilewc: A job that counts words from several files.<span class="comment">#从多个文件中计算字数的作业。</span></span><br><span class="line">  pentomino: A map/reduce tile laying program to find solutions to pentomino problems.<span class="comment">#一个map/reduce瓷砖铺设程序，以找到pentomino问题的解决方案。</span></span><br><span class="line">  pi: A map/reduce program that estimates Pi using a quasi-Monte Carlo method.<span class="comment">#使用准蒙特卡罗方法估计pi的map/reduce程序。</span></span><br><span class="line">  randomtextwriter: A map/reduce program that writes 10GB of random textual data per node.<span class="comment">#map/reduce程序，每个节点写入10GB的随机文本数据。</span></span><br><span class="line">  randomwriter: A map/reduce program that writes 10GB of random data per node.<span class="comment">#一个map/reduce程序，每个节点写入10GB的随机数据。</span></span><br><span class="line">  secondarysort: An example defining a secondary sort to the reduce.<span class="comment">#定义reduce的二级排序的示例。</span></span><br><span class="line">  sort: A map/reduce program that sorts the data written by the random writer.<span class="comment">#一个map/reduce程序，对随机写入的数据进行排序。</span></span><br><span class="line">  sudoku: A sudoku solver.<span class="comment">#数独</span></span><br><span class="line">  teragen: Generate data <span class="keyword">for</span> the terasort<span class="comment">#为terasort生成数据</span></span><br><span class="line">  terasort: Run the terasort<span class="comment">#运行terasort</span></span><br><span class="line">  teravalidate: Checking results of terasort<span class="comment">#检查terasort的结果</span></span><br><span class="line">  wordcount: A map/reduce program that counts the words <span class="keyword">in</span> the input files.<span class="comment">#一个对输入文件中的单词进行计数的map/reduce程序。</span></span><br><span class="line">  wordmean: A map/reduce program that counts the average length of the words <span class="keyword">in</span> the input files.<span class="comment">#一个map/reduce程序，计算输入文件中单词的平均长度。</span></span><br><span class="line">  wordmedian: A map/reduce program that counts the median length of the words <span class="keyword">in</span> the input files.<span class="comment">#一个map/reduce程序，用于计算输入文件中单词的中值长度。</span></span><br><span class="line">  wordstandarddeviation: A map/reduce program that counts the standard deviation of the length of the words <span class="keyword">in</span> the input files.<span class="comment">#一个map/reduce程序，计算输入文件中单词长度的标准偏差。</span></span><br></pre></td></tr></table></figure><p>在此我们选择运行 grep 例子，我们新建一个 input 文件夹，并将hadoop的配置文件作为输入文件复制到input中，把其中的所有文件作为输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/hadoop</span><br><span class="line">mkdir ./input</span><br><span class="line">cp ./etc/hadoop/*.xml ./input   <span class="comment"># 将配置文件作为输入文件</span></span><br></pre></td></tr></table></figure><p>复制后的input文件夹大致是这个样子：</p><p><img src="http://img.cuper.top/2020-07-21%2011-49-38%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p>筛选当中符合正则表达式 dfs[a-z.]+ 的单词并统计出现的次数，运行情况大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hadoop@cuper-Inspiron-7591:/usr/<span class="built_in">local</span>/hadoop$ ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.3.jar grep ./input ./output <span class="string">&#x27;dfs[a-z.]+&#x27;</span></span><br><span class="line">2020-07-21 11:49:52,083 INFO impl.MetricsConfig: loaded properties from hadoop-metrics2.properties</span><br><span class="line">2020-07-21 11:49:52,141 INFO impl.MetricsSystemImpl: Scheduled Metric snapshot period at 10 second(s).</span><br><span class="line">2020-07-21 11:49:52,141 INFO impl.MetricsSystemImpl: JobTracker metrics system started</span><br><span class="line"></span><br><span class="line">*******************省略一大段执行信息****************</span><br><span class="line">Shuffle Errors</span><br><span class="line">BAD_ID=0</span><br><span class="line">CONNECTION=0</span><br><span class="line">IO_ERROR=0</span><br><span class="line">WRONG_LENGTH=0</span><br><span class="line">WRONG_MAP=0</span><br><span class="line">WRONG_REDUCE=0</span><br><span class="line">File Input Format Counters </span><br><span class="line">Bytes Read=123</span><br><span class="line">File Output Format Counters </span><br><span class="line">Bytes Written=23</span><br></pre></td></tr></table></figure><p>最后输出结果到 output 文件夹中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop@cuper-Inspiron-7591:/usr/<span class="built_in">local</span>/hadoop$ cat ./output/*  <span class="comment"># 查看运行结果</span></span><br><span class="line">1dfsadmin  <span class="comment">#执行成功后输出了作业的相关信息，输出的结果是符合正则的单词 dfsadmin 出现了1次</span></span><br></pre></td></tr></table></figure><p>output文件夹大致是这个样子：</p><p><img src="http://img.cuper.top/2020-07-21%2012-05-47%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p><strong>注</strong>：Hadoop 默认不会覆盖结果文件，因此再次运行上面实例会提示出错，需要先将 <code>./output</code> 用<code>rm -r ./output</code>删除。</p><h1 id="Hadoop伪分布式配置"><a href="#Hadoop伪分布式配置" class="headerlink" title="Hadoop伪分布式配置"></a>Hadoop伪分布式配置</h1><p>Hadoop 可以在单节点上以伪分布式的方式运行，Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode，同时，读取的是 HDFS 中的文件。</p><p>Hadoop 的配置文件位于 /usr/local/hadoop/etc/hadoop/ 中，伪分布式需要修改2个配置文件 <strong>core-site.xml</strong> 和 <strong>hdfs-site.xml</strong> 。Hadoop的配置文件是 xml 格式，每个配置以声明 property 的 name 和 value 的方式来实现。</p><p>修改配置文件 <strong>core-site.xml</strong> ，将当中的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改为下面配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样的，修改配置文件 <strong>hdfs-site.xml</strong>，将当中的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><em>Hadoop配置文件说明</em></p><p>Hadoop 的运行方式是由配置文件决定的（运行 Hadoop 时会读取配置文件），因此如果需要从伪分布式模式切换回非分布式模式，需要删除 core-site.xml 中的配置项。</p><p>此外，伪分布式虽然只需要配置 fs.defaultFS 和 dfs.replication 就可以运行（官方教程如此），不过若没有配置 hadoop.tmp.dir 参数，则默认使用的临时目录为 /tmp/hadoo-hadoop，而这个目录在重启时有可能被系统清理掉，导致必须重新执行 format 才行。所以我们进行了设置，同时也指定 dfs.namenode.name.dir 和 dfs.datanode.data.dir，否则在接下来的步骤中可能会出错。</p></blockquote><p>配置完成后，执行 NameNode 的格式化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/hadoop</span><br><span class="line">./bin/hdfs namenode -format</span><br></pre></td></tr></table></figure><p>成功的话，会看到 “successfully formatted” 的提示，具体返回信息类似如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">hadoop@cuper-Inspiron-7591:/usr/<span class="built_in">local</span>/hadoop$ ./bin/hdfs namenode -format</span><br><span class="line">WARNING: /usr/<span class="built_in">local</span>/hadoop/logs does not exist. Creating.</span><br><span class="line">2020-07-21 13:01:34,335 INFO namenode.NameNode: STARTUP_MSG: </span><br><span class="line">/************************************************************</span><br><span class="line">STARTUP_MSG: Starting NameNode</span><br><span class="line">STARTUP_MSG:   host = cuper-Inspiron-7591/127.0.1.1</span><br><span class="line">STARTUP_MSG:   args = [-format]</span><br><span class="line">STARTUP_MSG:   version = 3.1.3</span><br><span class="line">******************省略一大段执行信息*********************</span><br><span class="line">2020-07-21 13:01:34,848 INFO common.Storage: Storage directory /usr/<span class="built_in">local</span>/hadoop/tmp/dfs/name has been successfully formatted.</span><br><span class="line">2020-07-21 13:01:34,871 INFO namenode.FSImageFormatProtobuf: Saving image file /usr/<span class="built_in">local</span>/hadoop/tmp/dfs/name/current/fsimage.ckpt_0000000000000000000 using no compression</span><br><span class="line">2020-07-21 13:01:34,924 INFO namenode.FSImageFormatProtobuf: Image file /usr/<span class="built_in">local</span>/hadoop/tmp/dfs/name/current/fsimage.ckpt_0000000000000000000 of size 393 bytes saved <span class="keyword">in</span> 0 seconds .</span><br><span class="line">2020-07-21 13:01:34,933 INFO namenode.NNStorageRetentionManager: Going to retain 1 images with txid &gt;= 0</span><br><span class="line">2020-07-21 13:01:34,935 INFO namenode.FSImage: FSImageSaver clean checkpoint: txid = 0 when meet shutdown.</span><br><span class="line">2020-07-21 13:01:34,935 INFO namenode.NameNode: SHUTDOWN_MSG: </span><br><span class="line">/************************************************************</span><br><span class="line">SHUTDOWN_MSG: Shutting down NameNode at cuper-Inspiron-7591/127.0.1.1</span><br><span class="line">************************************************************/</span><br></pre></td></tr></table></figure><p>接着开启 NameNode 和 DataNode 守护进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/hadoop</span><br><span class="line">./sbin/start-dfs.sh  <span class="comment">#start-dfs.sh是个完整的可执行文件，中间没有空格</span></span><br></pre></td></tr></table></figure><p>在这里反而出现了参考文章里的上一步提到的那个**ERROR: JAVA_HOME is not set and could not be found.**于是根据教程去hadoop的安装目录修改配置文件“/usr/local/hadoop/etc/hadoop/hadoop-env.sh”，在里面找到“export JAVA_HOME=${JAVA_HOME}”这行，但我找到的是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> JAVA_HOME=</span></span><br></pre></td></tr></table></figure><p>于是去掉注释再改上我的Java安装路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_191</span><br></pre></td></tr></table></figure><p>然后，再次运行守护进程（没有重启hadoop），warning可以不用管：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hadoop@cuper-Inspiron-7591:/usr/<span class="built_in">local</span>/hadoop$ ./sbin/start-dfs.sh</span><br><span class="line">Starting namenodes on [localhost]</span><br><span class="line">localhost: Warning: Permanently added <span class="string">&#x27;localhost&#x27;</span> (ECDSA) to the list of known hosts.</span><br><span class="line">Starting datanodes</span><br><span class="line">localhost: Warning: Permanently added <span class="string">&#x27;localhost&#x27;</span> (ECDSA) to the list of known hosts.</span><br><span class="line">Starting secondary namenodes [cuper-Inspiron-7591]</span><br><span class="line">cuper-Inspiron-7591: Warning: Permanently added <span class="string">&#x27;cuper-inspiron-7591&#x27;</span> (ECDSA) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>启动完成后，可以通过命令 <code>jps</code> 来判断是否成功启动，若成功启动则会列出如下进程: “NameNode”、”DataNode” 和 “SecondaryNameNode”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hadoop@cuper-Inspiron-7591:/usr/<span class="built_in">local</span>/hadoop$ jps</span><br><span class="line">15953 NameNode</span><br><span class="line">16130 DataNode</span><br><span class="line">16344 SecondaryNameNode</span><br><span class="line">17100 Jps</span><br></pre></td></tr></table></figure><p>如果 SecondaryNameNode 没有启动，请运行 sbin/stop-dfs.sh 关闭进程，然后再次尝试启动尝试。如果没有 NameNode 或 DataNode ，那就是配置不成功，请仔细检查之前步骤，或通过查看启动日志排查原因。</p><p>成功启动后，可以访问 Web 界面 <a href="http://localhost:9870/">http://localhost:9870</a> 查看 NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件：</p><p><img src="http://img.cuper.top/2020-07-21%2013-19-25%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><h1 id="运行Hadoop伪分布式实例"><a href="#运行Hadoop伪分布式实例" class="headerlink" title="运行Hadoop伪分布式实例"></a>运行Hadoop伪分布式实例</h1><p>上面的单机模式，grep 例子读取的是本地数据，伪分布式读取的则是 HDFS 上的数据。要使用 HDFS，首先需要在 HDFS 中创建用户目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -mkdir -p /user/hadoop</span><br></pre></td></tr></table></figure><p>接着将 ./etc/hadoop 中的 xml 文件作为输入文件复制到分布式文件系统中，即将 /usr/local/hadoop/etc/hadoop 复制到分布式文件系统中的 /user/hadoop/input 中。我们使用的是 hadoop 用户，并且已创建相应的用户目录 /user/hadoop ，因此在命令中就可以使用相对路径如 input，其对应的绝对路径就是 /user/hadoop/input:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -mkdir input</span><br><span class="line">./bin/hdfs dfs -put ./etc/hadoop/*.xml input</span><br></pre></td></tr></table></figure><p>复制完成后，可以通过<code>./bin/hdfs dfs -ls input</code>命令查看文件列表，列表情况大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hadoop@cuper-Inspiron-7591:/usr/<span class="built_in">local</span>/hadoop$ ./bin/hdfs dfs -ls input</span><br><span class="line">Found 9 items</span><br><span class="line">-rw-r--r--   1 hadoop supergroup       8260 2020-07-21 13:23 input/capacity-scheduler.xml</span><br><span class="line">-rw-r--r--   1 hadoop supergroup       1075 2020-07-21 13:23 input/core-site.xml</span><br><span class="line">-rw-r--r--   1 hadoop supergroup      11392 2020-07-21 13:23 input/hadoop-policy.xml</span><br><span class="line">-rw-r--r--   1 hadoop supergroup       1133 2020-07-21 13:23 input/hdfs-site.xml</span><br><span class="line">-rw-r--r--   1 hadoop supergroup        620 2020-07-21 13:23 input/httpfs-site.xml</span><br><span class="line">-rw-r--r--   1 hadoop supergroup       3518 2020-07-21 13:23 input/kms-acls.xml</span><br><span class="line">-rw-r--r--   1 hadoop supergroup        682 2020-07-21 13:23 input/kms-site.xml</span><br><span class="line">-rw-r--r--   1 hadoop supergroup        758 2020-07-21 13:23 input/mapred-site.xml</span><br><span class="line">-rw-r--r--   1 hadoop supergroup        690 2020-07-21 13:23 input/yarn-site.xml</span><br></pre></td></tr></table></figure><p>伪分布式运行 MapReduce 作业的方式跟单机模式相同，区别在于伪分布式读取的是HDFS中的文件（可以将单机步骤中创建的本地 input 文件夹、输出结果 output 文件夹都删掉来验证这一点）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.3.jar grep input output <span class="string">&#x27;dfs[a-z.]+&#x27;</span></span><br></pre></td></tr></table></figure><p>运行这个程序的结果和单机模式的类似，输出一大串的执行信息，然后使用以下命令查看运行结果（查看的是位于 HDFS 中的输出结果）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -cat output/*</span><br></pre></td></tr></table></figure><p>输出结果如下（注意到刚才我们已经更改了配置文件，所以运行结果不同）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hadoop@cuper-Inspiron-7591:/usr/<span class="built_in">local</span>/hadoop$ ./bin/hdfs dfs -cat output/*</span><br><span class="line">2020-07-21 13:26:48,459 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = <span class="literal">false</span>, remoteHostTrusted = <span class="literal">false</span></span><br><span class="line">1dfsadmin</span><br><span class="line">1dfs.replication</span><br><span class="line">1dfs.namenode.name.dir</span><br><span class="line">1dfs.datanode.data.dir</span><br></pre></td></tr></table></figure><p>将运行结果取回到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -r ./output    <span class="comment"># 先删除本地的 output 文件夹（如果存在）</span></span><br><span class="line">./bin/hdfs dfs -get output ./output     <span class="comment"># 将 HDFS 上的 output 文件夹拷贝到本机</span></span><br><span class="line">cat ./output/*</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：Hadoop 运行程序时，输出目录不能存在（不是本地的output），否则会提示错误 “org.apache.hadoop.mapred.FileAlreadyExistsException: Output directory hdfs://localhost:9000/user/hadoop/output already exists” ，因此若要再次执行，需要执行如下命令删除 output 文件夹:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -rm -r output    <span class="comment"># 删除 output 文件夹</span></span><br></pre></td></tr></table></figure><p>然后这个程序执行就结束了，若要关闭 Hadoop，则运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/stop-dfs.sh</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：下次启动 hadoop 时，无需进行 NameNode 的初始化，只需要运行 <code>./sbin/start-dfs.sh</code> 就可以。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 安装 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记（一）——杂七杂八的tips</title>
      <link href="2020/07/10/Java-tips1/"/>
      <url>2020/07/10/Java-tips1/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>前几天突然接到一个用Java复现Python代码的活，把我这个Java零基础的人折磨得要命。借此契机入门Java的同时也先记一下某一些特定的tips，方便以后查阅吧。</p><h1 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> start = (<span class="keyword">int</span>)Math.round(Float.parseFloat(start_video_locations.get(index2).toString()))</span><br><span class="line"><span class="comment">//start_video_locations为Object类型的变量</span></span><br></pre></td></tr></table></figure><h1 id="List的去重"><a href="#List的去重" class="headerlink" title="List的去重"></a>List的去重</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List course_ids = (List) course_ids_col.stream().distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h1 id="List的排序"><a href="#List的排序" class="headerlink" title="List的排序"></a>List的排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list_name);</span><br></pre></td></tr></table></figure><h1 id="获取list长度"><a href="#获取list长度" class="headerlink" title="获取list长度"></a>获取list长度</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> list_length = list.size();</span><br></pre></td></tr></table></figure><h1 id="object类型的小数转成double"><a href="#object类型的小数转成double" class="headerlink" title="object类型的小数转成double"></a>object类型的小数转成double</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> score = Double.valueOf(String.valueOf(ques_df.row(<span class="number">0</span>).get(<span class="number">3</span>)));</span><br><span class="line"><span class="comment">//这里ques_df.row(0).get(3)是一个Object类型的小数</span></span><br></pre></td></tr></table></figure><h1 id="object类型字符串转成string"><a href="#object类型字符串转成string" class="headerlink" title="object类型字符串转成string"></a>object类型字符串转成string</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String viewed_video_id =(String) viewed_video_ids.get(count);</span><br><span class="line"><span class="comment">//viewed_video_ids.get(count)这里拿到的是一个object类型的字符串</span></span><br></pre></td></tr></table></figure><h1 id="double类型转成string"><a href="#double类型转成string" class="headerlink" title="double类型转成string"></a>double类型转成string</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pass = String.valueOf(pass_total);</span><br></pre></td></tr></table></figure><h1 id="double数据强制转成int"><a href="#double数据强制转成int" class="headerlink" title="double数据强制转成int"></a>double数据强制转成int</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="keyword">new</span> Double(video_lengths.get(<span class="number">0</span>).toString()).intValue();</span><br><span class="line"><span class="comment">//video_lengths.get(0)是object类型的小数</span></span><br></pre></td></tr></table></figure><h1 id="for循环遍历列表List"><a href="#for循环遍历列表List" class="headerlink" title="for循环遍历列表List"></a>for循环遍历列表List</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object course_index:course_indexs)&#123;&#125;</span><br></pre></td></tr></table></figure><p>用Python的话是下面这个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> course_index <span class="keyword">in</span> course_indexs</span><br></pre></td></tr></table></figure><h1 id="获取变量类型"><a href="#获取变量类型" class="headerlink" title="获取变量类型"></a>获取变量类型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(object_name.getClass().getTypeName())</span><br></pre></td></tr></table></figure><h1 id="判断两个字符串是否相等"><a href="#判断两个字符串是否相等" class="headerlink" title="判断两个字符串是否相等"></a>判断两个字符串是否相等</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string1.equals(string2);</span><br><span class="line"><span class="comment">//相等返回true，否则返回false</span></span><br></pre></td></tr></table></figure><h1 id="对一个List获取某个指定索引的元素值"><a href="#对一个List获取某个指定索引的元素值" class="headerlink" title="对一个List获取某个指定索引的元素值"></a>对一个List获取某个指定索引的元素值</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.get(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//这里获取了下标为10的值，即数组概念中的list[10]，可换成其他int型数字</span></span><br></pre></td></tr></table></figure><h1 id="两个int类型的变量相除获得一个double型的结果"><a href="#两个int类型的变量相除获得一个double型的结果" class="headerlink" title="两个int类型的变量相除获得一个double型的结果"></a>两个int类型的变量相除获得一个double型的结果</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> avg_rep_d = Double.valueOf(total_rep)/Double.valueOf(viewed_video_number);</span><br></pre></td></tr></table></figure><h1 id="double型小数保留n位后转成string格式保存"><a href="#double型小数保留n位后转成string格式保存" class="headerlink" title="double型小数保留n位后转成string格式保存"></a>double型小数保留n位后转成string格式保存</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String avg_rep = String.format(<span class="string">&quot;%.2f&quot;</span>, avg_rep_d);</span><br><span class="line"><span class="comment">//这里保留了2位小数，2可以换成任意位数</span></span><br></pre></td></tr></table></figure><h1 id="一个方法（函数）里传回多个返回值的笨方法"><a href="#一个方法（函数）里传回多个返回值的笨方法" class="headerlink" title="一个方法（函数）里传回多个返回值的笨方法"></a>一个方法（函数）里传回多个返回值的笨方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List <span class="title">get_per_vtotal_vcompl</span><span class="params">(DataFrame df)</span></span>&#123;</span><br><span class="line"><span class="comment">//………………略………………</span></span><br><span class="line">    String per_vtotal = String.format(<span class="string">&quot;%.4f&quot;</span>, per_vtotal_d);</span><br><span class="line">    String per_vcompl = String.format(<span class="string">&quot;%.4f&quot;</span>, per_vcompl_d);</span><br><span class="line">    List vtotal_vcompl_list = Arrays.asList(per_vtotal,per_vcompl);</span><br><span class="line">    <span class="keyword">return</span> vtotal_vcompl_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后主方法里调用这个方法：</span></span><br><span class="line">List vtotal_vcompl_list = get_per_vtotal_vcompl(df);</span><br><span class="line"><span class="comment">//获得list中第一个返回值</span></span><br><span class="line">String per_vtotal = vtotal_vcompl_list.get(<span class="number">0</span>).toString();</span><br><span class="line"><span class="comment">//获得list中第二个返回值</span></span><br><span class="line">String per_vcompl = vtotal_vcompl_list.get(<span class="number">1</span>).toString();</span><br></pre></td></tr></table></figure><h1 id="Date类型数据两种样式与String的两两转换"><a href="#Date类型数据两种样式与String的两两转换" class="headerlink" title="Date类型数据两种样式与String的两两转换"></a>Date类型数据两种样式与String的两两转换</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object转String</span></span><br><span class="line">String end_time = end_localtimes.get(index1).toString();</span><br><span class="line">String start_time = start_localtimes.get(index2).toString();</span><br><span class="line"><span class="comment">//构建日期样式</span></span><br><span class="line">SimpleDateFormat usual_format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">SimpleDateFormat green_format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;EEE MMM dd HH:mm:ss z yyyy&quot;</span>,Locale.US);</span><br><span class="line"><span class="comment">//String转格林时间样式的Date</span></span><br><span class="line">Date end_time_green = green_format.parse(end_time);</span><br><span class="line">Date start_time_green = green_format.parse(start_time);</span><br><span class="line"><span class="comment">//格林时间样式的Date变量录入的同时转成普通时间格式的String</span></span><br><span class="line">String end_time_str = usual_format.format(end_time_green);</span><br><span class="line">String start_time_str = usual_format.format(start_time_green);</span><br><span class="line"><span class="comment">//String转Date</span></span><br><span class="line">Date end_time_usual = usual_format.parse(end_time_str);</span><br><span class="line">Date start_time_usual = usual_format.parse(start_time_str);</span><br><span class="line"><span class="comment">//.getTime()用于比较时间先后</span></span><br><span class="line"><span class="keyword">if</span>(end_time_usual.getTime() &lt; start_time_usual.getTime())&#123;</span><br><span class="line">video_pause = video_pause + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类似于Python中pandas的DataFrame的一个包"><a href="#类似于Python中pandas的DataFrame的一个包" class="headerlink" title="类似于Python中pandas的DataFrame的一个包"></a>类似于Python中pandas的DataFrame的一个包</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> joinery.DataFrame;</span><br></pre></td></tr></table></figure><p><a href="http://cardillo.github.io/joinery/v1.9/api/reference/joinery/DataFrame.html#mean()">官方文档</a></p><h2 id="把某一列类型强制转换"><a href="#把某一列类型强制转换" class="headerlink" title="把某一列类型强制转换"></a>把某一列类型强制转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">video_df = video_df.convert(String.class);<span class="comment">//这里转换的第一列，后面要转换某一列的话其他列的实参要填上null，表示置之不顾</span></span><br></pre></td></tr></table></figure><h2 id="按某个值筛选部分数据"><a href="#按某个值筛选部分数据" class="headerlink" title="按某个值筛选部分数据"></a>按某个值筛选部分数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataFrame course_df = video_df.select(<span class="keyword">new</span> DataFrame.Predicate&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">apply</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; row)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> course_id.equals(row.get(<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><p>这里用Python的话是下面的一句话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">course_df = video_df[video_df[<span class="string">&#x27;course_id&#x27;</span>]==course_id]</span><br></pre></td></tr></table></figure><p>佛了。</p><h2 id="获取整个df的长度（行数）"><a href="#获取整个df的长度（行数）" class="headerlink" title="获取整个df的长度（行数）"></a>获取整个df的长度（行数）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> length = df.length();</span><br></pre></td></tr></table></figure><h2 id="获取df各列的数据类型"><a href="#获取df各列的数据类型" class="headerlink" title="获取df各列的数据类型"></a>获取df各列的数据类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(df.types());</span><br></pre></td></tr></table></figure><h2 id="获取某一列的所有值组成一个ObjectList并强制转换成StringList"><a href="#获取某一列的所有值组成一个ObjectList并强制转换成StringList" class="headerlink" title="获取某一列的所有值组成一个ObjectList并强制转换成StringList"></a>获取某一列的所有值组成一个ObjectList并强制转换成StringList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; question_ids = (List&lt;String&gt;)(List)course_df.col(<span class="string">&quot;question_id&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="获取某一行数据，组成一个list"><a href="#获取某一行数据，组成一个list" class="headerlink" title="获取某一行数据，组成一个list"></a>获取某一行数据，组成一个list</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List row = df.row(index);</span><br><span class="line"><span class="comment">//index为某一行的行数</span></span><br></pre></td></tr></table></figure><h1 id="After"><a href="#After" class="headerlink" title="After"></a>After</h1><p>就这样入坑Java，还氪了《核心技术》和《Haed First》这两本书，希望不会半途而废吧。这个杂七杂八的tips以后可能未完待续。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在终端以命令行形式编译带第三方jar包的Java程序</title>
      <link href="2020/07/07/java_dos/"/>
      <url>2020/07/07/java_dos/</url>
      
        <content type="html"><![CDATA[<blockquote><p>eclipse爬</p></blockquote><p>背景：在<strong>一个</strong>.java文件里import了一个第三方包，然后从网上下载了它的.jar文件。不管.java文件和.jar文件放在什么地方，以下命令皆适用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac -cp package_name.jar class_name.java</span><br><span class="line">java -cp .:package_name.jar class_name</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>-cp和-classpath是一样的功能，-cp是简写。</li><li>若两个文件不在同一个地方，记得视终端所在位置而定是否需要写上.jar或.java文件的绝对路径。</li><li>java命令中的<code>.</code>代表当前路径（这里假设终端在.java文件处打开），而冒号<code>:</code>（假设为Linux系统，Windows系统改为分号<code>;</code>）表示多个路径之间的间隔，在引用多个.jar包和.jar包与主程序生成的.class时必须用到。</li></ul><p>参考文章：<a href="https://blog.csdn.net/u013476542/article/details/53707102?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase">java -cp -classpath 引用多个jar的方法</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编译 </tag>
            
            <tag> jar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用apt方式在Ubuntu中直接安装Sublime Text</title>
      <link href="2020/07/06/apt_sublime/"/>
      <url>2020/07/06/apt_sublime/</url>
      
        <content type="html"><![CDATA[<p>由于apt与Ubuntu的绝配，Sublime Text官方提供了一种懒人专用的安装方法：<a href="http://www.sublimetext.com/docs/3/linux_repositories.html#apt">官方文档</a>，apt-get之后就不用再去设置什么路径。其余Linux版本也可以参考文档里后面的内容。</p><p><strong>注意：去过 <a href="https://download.sublimetext.com/">https://download.sublimetext.com/</a> 这个网址下载过安装包的应该都知道下载速度奇慢无比，建议在科学上网环境下进行以下操作，最后apt下载的是一个大概9M大小的归档。</strong></p><p>安装步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装GPG密钥:</span></span><br><span class="line">wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保apt设置为使用https源</span></span><br><span class="line">sudo apt-get install apt-transport-https</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择要使用的版本（以下两个二选一）</span></span><br><span class="line"><span class="comment"># 稳定版</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://download.sublimetext.com/ apt/stable/&quot;</span> | sudo tee /etc/apt/sources.list.d/sublime-text.list</span><br><span class="line"><span class="comment"># 开发版</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://download.sublimetext.com/ apt/dev/&quot;</span> | sudo tee /etc/apt/sources.list.d/sublime-text.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新apt源并安装Sublime Text</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sublime-text</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装 </tag>
            
            <tag> Sublime Text </tag>
            
            <tag> apt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据技术综述</title>
      <link href="2020/07/03/big_data_preview/"/>
      <url>2020/07/03/big_data_preview/</url>
      
        <content type="html"><![CDATA[<h1 id="1-大数据概述"><a href="#1-大数据概述" class="headerlink" title="1 大数据概述"></a>1 大数据概述</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>巨量数据集合，指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。</p><h2 id="1-2-特征（4V）"><a href="#1-2-特征（4V）" class="headerlink" title="1.2 特征（4V）"></a>1.2 特征（4V）</h2><ul><li><strong>Volume：</strong>数据的超大规模</li><li><strong>Variety：</strong>数据来源多样性与异构性</li><li><strong>Velocity：</strong>数据的高处理速度</li><li><strong>Value：</strong>数据价值密度低</li></ul><h2 id="1-3-大数据思维"><a href="#1-3-大数据思维" class="headerlink" title="1.3 大数据思维"></a>1.3 大数据思维</h2><ul><li>要相关，不要因果。大数据时代认为没有必要非得知道现象背后的原因，而是要让数据自己“发声”。</li><li>要全体，不要抽样。大数据时代认为要分析与某事物相关的所有数据，而非少量的数据样本。</li><li>要效率，允许不精确，要注重效率，而不再追求精确。</li></ul><h1 id="2-大数据技术体系"><a href="#2-大数据技术体系" class="headerlink" title="2 大数据技术体系"></a>2 大数据技术体系</h1><blockquote><p><a href="https://blog.csdn.net/qq_25062299/article/details/95592877?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.nonecase">图片来源</a></p></blockquote><p><img src="http://img.cuper.top/image/lab%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%94%9F%E6%80%81%E4%BD%93%E7%B3%BB2.png" alt="大数据技术生态体系2"></p><h2 id="2-1-数据来源"><a href="#2-1-数据来源" class="headerlink" title="2.1 数据来源"></a>2.1 数据来源</h2><blockquote><p><a href="https://blog.csdn.net/liangyihuai/article/details/54864952?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">参考文章1</a><br><a href="https://blog.csdn.net/qq_25353433/article/details/81451310?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">参考文章2</a></p></blockquote><h3 id="2-1-1-结构化数据"><a href="#2-1-1-结构化数据" class="headerlink" title="2.1.1 结构化数据"></a>2.1.1 结构化数据</h3><p>结构化的数据是指可以使用<strong>关系型数据库</strong>表示和存储，表现为<strong>二维形式的数据</strong>。一般特点是：数据以行为单位，一行数据表示一个实体的信息，每一行数据的属性是相同的。</p><p>结构化数据的存储和排列很有规律，便于查询和修改等操作，但扩展性不高。</p><h3 id="2-1-2-半结构化数据"><a href="#2-1-2-半结构化数据" class="headerlink" title="2.1.2 半结构化数据"></a>2.1.2 半结构化数据</h3><p>半结构化数据是结构化数据的一种形式，它并不符合关系型数据库或其他数据表的形式关联起来的数据模型结构，但包含<strong>相关标记</strong>，用来分隔语义元素以及对记录和字段进行分层。因此，它也被称为自描述的结构，扩展性良好。</p><p>半结构化数据，属于同一类实体可以有不同的属性，即使他们被组合在一起，<strong>这些属性的顺序并不重要</strong>。</p><p>常见的半结构数据有XML、JSON、日志文件、Email等。</p><h3 id="2-1-3-非结构化数据"><a href="#2-1-3-非结构化数据" class="headerlink" title="2.1.3 非结构化数据"></a>2.1.3 非结构化数据</h3><p>没有固定结构的数据，包括各种文档、图片、视频/音频等。这类数据一般直接整体进行存储，而且一般存储为二进制的数据格式。</p><h3 id="2-1-4-概念辨析"><a href="#2-1-4-概念辨析" class="headerlink" title="2.1.4 概念辨析"></a>2.1.4 概念辨析</h3><ul><li><p>结构化、半结构化、非结构化的分类依据是数据格式。</p></li><li><p>严格来说，结构化与半结构化数据都是有基本固定结构模式的数据</p></li><li><p>半结构与非结构化数据与大数据之间只是有领域重叠的关系，本质讲两者并无必然联系。</p></li></ul><h2 id="2-2-数据传输"><a href="#2-2-数据传输" class="headerlink" title="2.2 数据传输"></a>2.2 数据传输</h2><h3 id="2-2-1-Sqoop"><a href="#2-2-1-Sqoop" class="headerlink" title="2.2.1 Sqoop"></a>2.2.1 Sqoop</h3><blockquote><p><a href="https://www.cnblogs.com/qingyunzong/p/8807252.html#_label4_1">参考文章1</a><br><a href="https://www.jianshu.com/p/ec9003d8918c">参考文章2</a><br><a href="http://sqoop.apache.org/">官网</a><br><a href="http://mirrors.hust.edu.cn/apache/sqoop/">镜像源</a></p></blockquote><p>Sqoop主要用于在Hadoop与传统的关系型数据库间进行数据的传递，是连接关系型数据库和Hadoop的桥梁，主要有两个方面（导入和导出）：</p><ul><li><p>将关系型数据库的数据导入到Hadoop及其相关的系统中，如 Hive和HBase</p></li><li><p>将数据从Hadoop系统里抽取并导出到关系型数据库</p></li></ul><p>其本质是一个命令行工具，用于迁移数据，工作机制是将导入或导出命令翻译成MapReduce程序来实现的。</p><h3 id="2-2-2-Flume"><a href="#2-2-2-Flume" class="headerlink" title="2.2.2 Flume"></a>2.2.2 Flume</h3><blockquote><p> <a href="http://flume.apache.org/">官网</a><br> <a href="https://www.bilibili.com/video/av65541678?from=search&seid=13455141829682550307">教学视频</a><br> <a href="https://blog.csdn.net/lagoon_lala/article/details/86764176?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase#Flume%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">参考文章1</a><br> <a href="https://blog.csdn.net/helloemk/article/details/84867048?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">参考文章2</a></p></blockquote><p>Flume是一个分布式的、高可靠的、高可用的将大批量的不同数据源的日志数据收集、聚合、移动到数据中心（HDFS）进行存储的系统，即是<strong>日志采集和汇总</strong>的工具。Flume支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接收方（可定制）的能力。架构如下：<br><img src="http://img.cuper.top/image/labFlume.png" alt="Flume"></p><ul><li><strong>Source</strong>：用于采集收据，Source是产生数据流的地方官，同时Source会将产生的数据流传输到Channel。</li><li><strong>Channel</strong>：用于桥接Source和Sink，类似于一个队列。</li><li><strong>Sink</strong>：从Channel收集数据，将数据写到目标源（可以是下一个source，也可以是HDFS或者HBase）。</li><li><strong>Event</strong>：是Flume数据传输的基本单元，以时间的形式讲过数据从源头传送到目的地。</li><li><strong>Agent</strong>：JVM中一个独立的Flume进程，包含组件Source、Channel、Sink。</li></ul><h3 id="2-2-3-Kafka"><a href="#2-2-3-Kafka" class="headerlink" title="2.2.3 Kafka"></a>2.2.3 Kafka</h3><blockquote><p><a href="http://kafka.apachecn.org/">官方中文文档</a><br><a href="https://www.bilibili.com/video/av65544753?from=search&seid=12535568434906893507">教学视频</a><br><a href="https://blog.csdn.net/xlgen157387/article/details/77266719?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase">参考文章</a><br><a href="https://www.w3cschool.cn/apache_kafka/">中文教程</a></p></blockquote><p>Kafka是一个分布式、支持分区的、多副本的、基于ZooKeeper协调的分布式消息系统，主要应用场景是日志收集系统和消息系统。架构如下：</p><p><img src="http://img.cuper.top/image/labKafka%E8%AF%A6%E7%BB%86%E6%9E%B6%E6%9E%84.jpg" alt="Kafka详细架构"></p><ul><li><strong>Producer</strong>：消息生产者，是能够发布消息到Topic的任何对象，向Broker发送消息。</li><li><strong>Consumer</strong>：消息消费者，可以订阅一个或多个话题，并从Broker拉数据，从而消费这些已发布的消息。</li><li><strong>Broker</strong>：一台Kafka服务器就是一个Broker，一个集群由多个Broker组成，一个Broker可以容纳多个Topic。</li><li><strong>Topic</strong>：是特定类型的消息流，<strong>生产者和消费者面向的都是一个topic</strong>。</li></ul><h2 id="2-3-数据存储"><a href="#2-3-数据存储" class="headerlink" title="2.3 数据存储"></a>2.3 数据存储</h2><h3 id="2-3-1-HDFS"><a href="#2-3-1-HDFS" class="headerlink" title="2.3.1 HDFS"></a>2.3.1 HDFS</h3><blockquote><p><a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsUserGuide.html">官方文档</a><br><a href="https://blog.csdn.net/sjmz30071360/article/details/79877846?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159376416919195265907685%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159376416919195265907685&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-79877846.first_rank_ecpm_v3_pc_rank_v2&utm_term=HDFS">参考文章</a><br><a href="https://www.bilibili.com/video/BV164411Z7cR?p=15">教学视频1</a><br><a href="https://www.bilibili.com/video/BV1cW411r7c5?p=48">教学视频2</a></p></blockquote><p>HDFS（Hadoop Distributed File System）分布式文件系统，是分布式计算中<strong>数据存储管理</strong>的基础，是Hadoop Core项目的核心子项目。HDFS用于存储文件，通过目录树来定位文件；它是分布式的，由很多服务器联合起来实现其功能，集群中的服务器有各自的角色。HDFS的设计适合一次写入、多次读出的场景，且不支持文件的修改。适合用来做数据分析，并不适合用来做网盘应用。架构如下：</p><p><img src="http://img.cuper.top/image/labHDFS%E7%BB%84%E6%88%90%E6%9E%B6%E6%9E%84.png" alt="HDFS组成架构"></p><ul><li><strong>Client</strong>：客户端，负责上传文件时的切分，与NameNode交互以获取文件的位置信息，与DataNode交互以读取或者写入数据，并提供一些命令来管理HDFS或访问HDFS。</li><li><strong>NameNode</strong>：作为一个管理者管理HDFS的名称空间、数据块（Block）映射信息，配置副本策略并处理客户端读写请求。</li><li><strong>DataNode</strong>：在NameNode下达命令后执行实际的操作，存储了实际的数据块并执行数据块的读/写操作。</li><li><strong>Secondary NameNode</strong>：定期合并主Namenode的namespace image和edit log， 避免edit log过大。它会维护一个合并后的namespace image副本， 可用于在Namenode完全崩溃时恢复数据。</li></ul><h3 id="2-3-2-HBase"><a href="#2-3-2-HBase" class="headerlink" title="2.3.2 HBase"></a>2.3.2 HBase</h3><blockquote><p><a href="https://hbase.apache.org/">官网</a><br><a href="https://blog.csdn.net/woshiwanxin102213/article/details/17584043?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159376706819725222414602%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159376706819725222414602&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-17584043.first_rank_ecpm_v3_pc_rank_v2&utm_term=HBase">参考文章1</a><br><a href="https://blog.csdn.net/nosqlnotes/article/details/79647096?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">参考文章2</a><br><a href="https://www.bilibili.com/video/av65548392?from=search&seid=759279005217475156">教学视频</a><br><a href="https://www.w3cschool.cn/hbase_doc/">中文教程</a></p></blockquote><p>HBase是一个分布式的、可扩展、支持海量存储的面向列的开源<strong>NoSQL</strong>数据库。HBase不同于一般的关系型数据库，它是一个适合于非结构化数据存储的数据库。HBase基于Google BigTable模型开发的，构建在HDFS上，利用MapReduce来处理海量数据，作为一个典型的<strong>key/value</strong>系统，是Apache Hadoop生态系统中的重要一员。架构如下：</p><p><img src="http://img.cuper.top/image/labHBase%E6%9E%B6%E6%9E%84.png" alt="HBase架构"></p><ul><li><strong>ZooKeeper</strong>：HBase通过ZooKeeper来做Master的高可用、RegionServer的监控、元数据的入口以及集群配置的维护等工作。</li><li><strong>Master</strong>：为RegionServer分配Region、维护整个集群的负载均衡、维护集群的元数据信息、发现失效的Region，并将失效的Region分配到正常的RegionServer上、当RegionSever失效的时候，协调对应Hlog的拆分。</li><li><strong>RegionServer</strong>：直接对接用户的读写请求，管理Master为其分配的Region、处理来自客户端的读写请求、负责和底层HDFS的交互，存储数据到HDFS、负责Region变大以后的拆分、负责Storefile的合并工作。</li></ul><h2 id="2-4-资源管理"><a href="#2-4-资源管理" class="headerlink" title="2.4 资源管理"></a>2.4 资源管理</h2><h3 id="2-4-1-YARN"><a href="#2-4-1-YARN" class="headerlink" title="2.4.1 YARN"></a>2.4.1 YARN</h3><blockquote><p><a href="http://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/YARN.html">官方文档</a><br><a href="https://blog.csdn.net/qq_33624952/article/details/79341034?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">参考文章1</a><br><a href="https://blog.csdn.net/weixin_34409357/article/details/94715132?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159376892719725211908012%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159376892719725211908012&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-94715132.first_rank_ecpm_v3_pc_rank_v2&utm_term=yarn">参考文章2</a></p></blockquote><p>YARN（Yet Another Resource Negotiator，另一种资源协调者）是一种新的Hadoop<strong>资源管理器</strong>，它是一个<strong>通用资源管理系统和调度平台</strong>，可为上层应用提供统一的资源管理和调度，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。目前可以支持多种计算框架运行在YARN上，比如MapReduce，Strom，Spark，Flink等。与MapReduce的关系可以理解为，MapReduce只是运行在YARN上的一个应用程序，如果把YARN看作Android，则MapReduce只是一个App。架构如下：</p><p><img src="http://hadoop.apache.org/docs/r2.6.5/hadoop-yarn/hadoop-yarn-site/yarn_architecture.gif"></p><ul><li><strong>ResourceManager</strong>：负责所有应用程序之间资源分配。</li><li><strong>NodeManager</strong>：负责Containers，监视其资源使用情况（CPU，内存，磁盘，网络）并将其报告给 ResourceManager。</li><li><strong>ApplicationMaster</strong>：负责协调来自ResourceManager的资源，并与NodeManager一起执行和监视任务。</li></ul><h2 id="2-5-数据计算"><a href="#2-5-数据计算" class="headerlink" title="2.5 数据计算"></a>2.5 数据计算</h2><h3 id="2-5-1-MapReduce"><a href="#2-5-1-MapReduce" class="headerlink" title="2.5.1 MapReduce"></a>2.5.1 MapReduce</h3><blockquote><p><a href="https://static.usenix.org/publications/library/proceedings/osdi04/tech/full_papers/dean/dean.pdf">论文原文</a><br><a href="http://hadoop.apache.org/docs/stable/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html">官方文档</a><br><a href="https://blog.csdn.net/Little_Fire/article/details/80605233?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159376965319724811823054%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159376965319724811823054&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-80605233.first_rank_ecpm_v3_pc_rank_v2&utm_term=mapreduce">参考文章1</a><br><a href="https://blog.csdn.net/qq_35078688/article/details/83240661">参考文章2</a><br><a href="https://blog.csdn.net/bingduanlbd/article/details/51924398?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">参考文章3</a></p></blockquote><p>MapReduce是一个分布式的离线计算框架，用于海量数据的并行运算，是Hadoop数据分析的核心，仅适用于离线数据处理或批处理。MapReduce的处理过程分为两个步骤：Map和Reduce。Map阶段对输入的数据进行并行处理，处理结果传给Reduce完成最后的汇总。MapReduce框架使得编程人员在不会分布式并行编程的情况下，将编写的业务逻辑代码运行在分布式系统上，开发人员可以将绝大部分的工作集中于业务逻辑上的开发，具体的计算只需要交给框架即可。</p><p><img src="http://img.cuper.top/image/labmapreduce.png" alt="mapreduce"></p><h3 id="2-5-2-Spark"><a href="#2-5-2-Spark" class="headerlink" title="2.5.2 Spark"></a>2.5.2 Spark</h3><blockquote><p><a href="http://spark.apache.org/">官网</a><br><a href="https://blog.csdn.net/youbitch1/article/details/89925790?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">参考文章1</a><br><a href="https://blog.csdn.net/qq_17677907/article/details/88685705">参考文章2</a><br><a href="https://www.bilibili.com/video/av62992342?from=search&seid=6784944762132058487">教学视频</a><br><a href="https://www.w3cschool.cn/spark/">中文教程</a></p></blockquote><p>Spark是基于MapReduce算法实现的分布式计算，拥有MapReduce所具有的优点，但不同于MR的是，Job中间输出和结果可以保存在内存中，从而不再需要读写 HDFS，因此Spark能更好地适用于<strong>数据挖掘与机器学习等需要迭代的算法</strong>中，高效地支持更多计算模式，包括交互式查询和流处理。 Spark是MapReduce的替代方案，是对Hadoop的补充，而且兼容HDFS、Hive，可融入Hadoop的生态系统，以弥补MapReduce的不足。以下为Spark的生态系统组成：</p><p><img src="http://img.cuper.top/image/labSpark%E7%BB%84%E6%88%90.png" alt="Spark组成"></p><ul><li><strong>Spark Core</strong>：Spark Core包含Spark的基本功能，如内存计算、任务调度、部署模式、故障恢复、存储管理等。Spark建立在统一的抽象RDD（弹性分布式数据集，是分布式内存的一个抽象概念，提供了一种高度受限的共享内存模型）之上，使其可以以基本一致的方式应对不同的大数据处理场景。</li><li><strong>Spark SQL</strong>：Spark SQL允许开发人员直接处理RDD，同时也可查询Hive、HBase等外部数据源。Spark SQL的一个重要特点是其能够统一处理关系表和RDD，使得开发人员可以轻松地使用SQL命令进行查询，并进行更复杂的数据分析。</li><li><strong>Spark Streaming</strong>：支持高吞吐量、可容错处理的实时流数据处理，其核心思路是将流式计算分解成一系列短小的批处理作业。</li><li><strong>MLlib</strong>：MLlib提供了常用机器学习算法的实现，包括聚类、分类、回归、协同过滤等。</li><li><strong>GraphX</strong>：GraphX是Spark中用于图计算的API。</li></ul><h3 id="2-5-3-Storm"><a href="#2-5-3-Storm" class="headerlink" title="2.5.3 Storm"></a>2.5.3 Storm</h3><blockquote><p><a href="http://storm.apache.org/">官网</a><br><a href="https://www.w3cschool.cn/apache_storm/">中文教程</a><br><a href="http://www.tianshouzhi.com/api/tutorials/storm">参考博客</a><br><a href="https://blog.csdn.net/wangshuminjava/article/details/86517973">参考文章</a></p></blockquote><p>Storm是一个免费开源、分布式、高容错的<strong>实时计算系统</strong>，令持续不断的流计算变得容易，弥补了Hadoop批处理所不能满足的实时要求。分布式实时计算强调实时性，常用于实时性要求较高的地方，提供了大吞吐量的实时计算能力。通过数据入口获取每条到来的数据，在一条数据到达系统的时候，立即会在内存中进行相应的计算；Storm适合要求实时性较高的数据分析场景。架构如下：</p><p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20160127/1453825806872000933.png"></p><ul><li><strong>Nimbus</strong>：负责在集群分发任务(Topology)的代码以及监控等。</li><li><strong>Supervisor</strong>：并不是自己直接执行任务。在接受到一个任务的时候，会启动一个或多个进程来处理任务。</li><li><strong>ZooKeeper</strong>：Storm主要使用ZooKeeper来协调一个集群中的状态信息，比如任务的分配情况，worker的状态，supervisor之间的nimbus的拓扑度量。nimbus和supervisor节点之间的通信主要是结合 ZooKeeper 的状态变更通知和监控通知来处理的。</li></ul><h3 id="2-5-4-Hive"><a href="#2-5-4-Hive" class="headerlink" title="2.5.4 Hive"></a>2.5.4 Hive</h3><blockquote><p><a href="https://hive.apache.org/">官方文档</a><br><a href="https://www.bilibili.com/video/av65556024?from=search&seid=14922409626561581253">教学视频</a><br><a href="https://www.cnblogs.com/qingyunzong/p/8707885.html">参考文章</a><br><a href="https://www.yiibai.com/hive">中文教程</a></p></blockquote><p>Hive是基于Hadoop的一个<strong>数据仓库工具</strong>，可以将结构化的数据文件映射为一张数据库表，并提供简单的SQL查询功能，可以将SQL语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。<br>Hive依赖于HDFS存储数据，将HQL转换成MapReduce执行，所以说Hive是基于Hadoop的一个数据仓库工具，实质就是一款基于HDFS的MapReduce<strong>计算框架</strong>，对存储在HDFS中的数据进行分析和管理。架构如下：<br><img src="http://img.cuper.top/image/labHive.png" alt="Hive"></p><h3 id="2-5-5-Mahout"><a href="#2-5-5-Mahout" class="headerlink" title="2.5.5 Mahout"></a>2.5.5 Mahout</h3><blockquote><p><a href="http://mahout.apache.org/">官网</a><br><a href="https://blog.csdn.net/aaronhadoop/article/details/24577221?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase">参考文章1</a><br><a href="https://www.cnblogs.com/ahu-lichang/p/7073836.html">参考文章2</a></p></blockquote><p>Mahout是一个<strong>算法库</strong>，集成了很多算法。Apache Mahout提供一些可扩展的<strong>机器学习领域经典算法的实现</strong>，旨在帮助开发人员更加方便快捷地创建智能应用程序。通过使用Apache Hadoop库，Mahout可以有效地扩展到<strong>Hadoop集群</strong>。最大的优点就是基于Hadoop实现，把很多以前运行于单机上的算法转化为了MapReduce模式，这样大大提升了算法可处理的数据量和处理性能。当前Mahout支持主要的4个用例：</p><ul><li>推荐挖掘：搜集用户动作并以此给用户推荐可能喜欢的事物。</li><li>聚集：收集文件并进行相关文件分组。</li><li>分类：从现有的分类文档中学习，寻找文档中的相似特征，并为无标签的文档进行正确的归类。</li><li>频繁项集挖掘：将一组项分组，并识别哪些个别项会经常一起出现。</li></ul><h2 id="2-6-数据平台协调与调度"><a href="#2-6-数据平台协调与调度" class="headerlink" title="2.6 数据平台协调与调度"></a>2.6 数据平台协调与调度</h2><h3 id="2-6-1-ZooKeeper"><a href="#2-6-1-ZooKeeper" class="headerlink" title="2.6.1 ZooKeeper"></a>2.6.1 ZooKeeper</h3><blockquote><p><a href="https://zookeeper.apache.org/">官网</a><br><a href="https://blog.csdn.net/java_66666/article/details/81015302">参考文章</a></p></blockquote><p>ZooKeeper是一个开源的分布式的、为分布式应用提供协调服务的Apache子项目，是一个<strong>分布式服务框架</strong>，是Hadoop、HBase和其他分布式框架使用的有组织服务的标准。主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。简单来说<strong>ZooKeeper=文件系统+监听通知机制</strong>。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><h1 id="3-大数据生态圈"><a href="#3-大数据生态圈" class="headerlink" title="3 大数据生态圈"></a>3 大数据生态圈</h1><h2 id="3-1-生态圈解析"><a href="#3-1-生态圈解析" class="headerlink" title="3.1 生态圈解析"></a>3.1 生态圈解析</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/63180892">图片来源&amp;参考文章</a></p></blockquote><p><img src="https://pic2.zhimg.com/v2-6e4352e9c9a3a3c7b15716c051165d75_r.jpg"></p><p>蓝色部分是Hadoop生态系统组件，黄色部分是Spark生态组件，虽然他们是两种不同的大数据处理框架，但它们不是互斥的，Spark与Hadoop中的MapReduce是一种相互共生的关系。Hadoop提供了Spark许多没有的功能，比如分布式文件系统，而Spark提供了实时内存计算，速度非常快。</p><h2 id="3-2-技术发展趋势"><a href="#3-2-技术发展趋势" class="headerlink" title="3.2 技术发展趋势"></a>3.2 技术发展趋势</h2><ul><li>Spark在崛起，Hadoop和Storm中的一些组件在消退。</li><li>HQL未来可能会被Spark SQL替代，现在很多企业都是HQL和Spark SQL两种工具共存，当Spark SQL逐步成熟的时候，就有可能替换HQL。</li><li>MapReduce也有可能被Spark替换，但目前Spark还不够成熟稳定。</li><li>Hadoop中的算法库Mahout正被Spark中的算法库MLib所替代。</li><li>由于Spark和Hadoop天衣无缝的结合，Spark在逐步的走向成熟和稳定，其生态组件也在逐步地完善，因此Storm出于不是Hadoop生态中的一员，会逐步被挤压而走向衰退。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 综述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyclustering模块中K-Medoids算法和Elbow（肘部）法则的应用</title>
      <link href="2020/06/28/kmedoids&amp;elbow/"/>
      <url>2020/06/28/kmedoids&amp;elbow/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>最近在做数据分析相关研究时需要用到K-Medoids算法对数据进行聚类，然后在平时常用的Python的<code>sklearn.cluster</code>库模块中没有找到这个算法函数，于是想着找一下别的库。首先是发现了一位研究数据分析的博主的一份笔记：<a href="https://www.cnblogs.com/feffery/p/8595315.html">K-medoids聚类算法原理简介&amp;Python与R的实现</a>，在文末评论里他提到博文中用的<code>pyclust</code>模块不维护了，然后推荐了<code>pyclustering</code>模块和其<a href="https://pyclustering.github.io/docs/0.9.3/html/d0/dd3/classpyclustering_1_1cluster_1_1kmedoids_1_1kmedoids.html">参考文档</a>。为加深自己的理解，特此对文档做一份学习笔记。</p><h1 id="K-Medoids文档渣翻与应用"><a href="#K-Medoids文档渣翻与应用" class="headerlink" title="K-Medoids文档渣翻与应用"></a>K-Medoids文档渣翻与应用</h1><p><strong>pyclustering.cluster.kmedoids.kmedoids</strong>：一个用于表征K-Medoids算法的类</p><h2 id="公共类成员函数"><a href="#公共类成员函数" class="headerlink" title="公共类成员函数"></a>公共类成员函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self, data, initial_index_medoids, tolerance=<span class="number">0.001</span>, ccore=<span class="literal">True</span>, kwargs</span>)</span></span><br><span class="line"><span class="function"># <span class="title">K</span>-<span class="title">Medoids</span>聚类算法的构造初始化</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">process</span> (<span class="params">self</span>)</span></span><br><span class="line"><span class="function"># 根据<span class="title">K</span>-<span class="title">Medoids</span>算法的规则进行聚类分析</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">predict</span> (<span class="params">self, points</span>)</span></span><br><span class="line"><span class="function"># 对于每个点计算离它距离最近的簇</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">get_clusters</span> (<span class="params">self</span>)</span></span><br><span class="line"># 返回已分配好群集的列表,每个群集包含数据列表中对象的索引</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_medoids</span> (<span class="params">self</span>)</span></span><br><span class="line"><span class="function"># 返回由输入数据中的索引表示的已分配群集的<span class="title">medoid</span>列表</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">get_cluster_encoding</span> (<span class="params">self</span>)</span></span><br><span class="line"><span class="function"># 返回指示如何对群集进行编码的群集结果表示类型</span></span><br></pre></td></tr></table></figure><p>这里对每个函数的注释仅是简单翻译了一下官方文档里的那句话，对函数的详细使用和分析可结合下面详细说明中代码样例里我注释的笔记来理解。</p><h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><p>该算法与K-Means相比对异常值的敏感性较低。K-Medoids与K-Medians的主要区别在于，K-Medoids使用输入数据空间中的已有点作为每个簇的中心点，但K-Medians中的中心点可以是不真实的对象（而不是从输入数据空间中选取已有点）。</p><p>下面是官方给出的一个聚类样例，在代码中加入了一些本人做的笔记注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyclustering.cluster.kmedoids <span class="keyword">import</span> kmedoids</span><br><span class="line"><span class="keyword">from</span> pyclustering.cluster <span class="keyword">import</span> cluster_visualizer</span><br><span class="line"><span class="keyword">from</span> pyclustering.utils <span class="keyword">import</span> read_sample</span><br><span class="line"><span class="keyword">from</span> pyclustering.samples.definitions <span class="keyword">import</span> FCPS_SAMPLES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入待聚类的样本点。</span></span><br><span class="line"><span class="comment"># 这里我打印了一下这些数据，整个sample就是一个二维的列表（甚至没有用到numpy包），共有800行（也就是800个数据点），每一行是一个长度为2的列表（就是TWO_DIAMONDS二维数据），列表中的两个数的数据类型为float。导入自己数据进行聚类时可参考这个格式。</span></span><br><span class="line">sample = read_sample(FCPS_SAMPLES.SAMPLE_TWO_DIAMONDS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定随机的初始中心点索引。</span></span><br><span class="line"><span class="comment"># 这里中心点的数据类型是一个int类型的列表，列表中每个值代表每一类中心点的索引。注意该列表的长度已经代表了你要聚类的类别个数，也就是说len(initial_medoids)=k。</span></span><br><span class="line">initial_medoids = [<span class="number">1</span>, <span class="number">500</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建K-Medoids算法的实例。</span></span><br><span class="line"><span class="comment"># 这里就创建了kmedoids类的一个对象，__init__函数被调用，这里传入了前两个参数，后面的参数保持默认状态。</span></span><br><span class="line">kmedoids_instance = kmedoids(sample, initial_medoids)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行聚类分析并获取聚类结果。</span></span><br><span class="line">kmedoids_instance.process()</span><br><span class="line">clusters = kmedoids_instance.get_clusters()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印分配好的聚类结果。</span></span><br><span class="line"><span class="comment"># 这里的clusters为一个k（本示例k=2）行列表，每一行列表里嵌套一个索引列表，列表里是对应簇中所有点的索引值（int型）。</span></span><br><span class="line">print(clusters)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印各簇中心点。</span></span><br><span class="line"><span class="comment"># 此段代码官方示例中没有，是我自己为了看一下get_medoids()函数而加的，得到的结果是medoids为一个长度为k的列表，每个元素对应每个簇的中心点的索引值（int型）。</span></span><br><span class="line">medoids = kmedoids_instance.get_medoids()</span><br><span class="line">print(medoids)</span><br><span class="line"></span><br><span class="line"><span class="comment">#聚类的可视化，用了模块里的自带功能。</span></span><br><span class="line">visualizer = cluster_visualizer()</span><br><span class="line">visualizer.append_clusters(clusters, sample)</span><br><span class="line">visualizer.show()</span><br></pre></td></tr></table></figure><p>各点之间距离的计算方法可以由kmedoids类对象初始化里的参数“Metric”指定。需要注意的是<code>kmedoids(metric=metric)</code>传入的metric是一个distance_metric类对象，而这个类对象是<code>pyclustering</code>模块里的另一个定义的类（<a href="https://pyclustering.github.io/docs/0.9.3/html/df/df9/classpyclustering_1_1utils_1_1metric_1_1distance__metric.html">详细文档</a>），调用的时候需要import一下。可选择的距离类型参考type_metric的<a href="https://pyclustering.github.io/docs/0.9.3/html/da/d3a/classpyclustering_1_1utils_1_1metric_1_1type__metric.html">文档</a>，官方选用了MINKOWSKI距离作为示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入相关模块</span></span><br><span class="line"><span class="keyword">from</span> pyclustering.utils.metric <span class="keyword">import</span> distance_metric, type_metric</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Minkowski距离度量方法，并设置相关的degree参数为&#x27;2&#x27;</span></span><br><span class="line">metric = distance_metric(type_metric.MINKOWSKI, degree=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在创建K-Medoids类对象时附上metric参数</span></span><br><span class="line">kmedoids_instance = kmedoids(sample, initial_medoids, metric=metric)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的活就跟之前的一样了</span></span><br><span class="line">kmedoids_instance.process()</span><br><span class="line">clusters = kmedoids_instance.get_clusters()</span><br></pre></td></tr></table></figure><p>下面这个就体现了K-Medoids算法相比于K-Means的一个优越性所在：可适用类别（categorical）类型的特征。因为K-Means每次计算质心取的均值可能不是一个真实的点，所以对原始数据有要求为数据点类型，能够映射到对应维度的一个空间里的具体位置中，即要求数据点处在一个欧氏空间之中。然而并不是所有的数据都能满足这样的要求，这里K-Medoids就解决了这个问题（<a href="http://blog.pluskid.org/?p=40">参考文章</a>），在算法里重新计算中心点时只需要点与点之间的距离即可，因此其适用范围可扩散到各种各样的数据，前提是只要你可以正确计算出每个元素之间的距离即可。<code>pyclustering.cluster.kmedoids</code>里即可使用距离矩阵代替点序列来提高性能。为此，在创建K-Medoids类对象时要使用data_type这个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若用pyclustering自带的计算距离功能，这里需要先导入相关模块。</span></span><br><span class="line"><span class="keyword">from</span> pyclustering.utils <span class="keyword">import</span> calculate_distance_matrix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算样本数据的距离矩阵。</span></span><br><span class="line"><span class="comment"># 这里read_sample里传入的参数其实可以是本地数据文件地址或上面示例里的模块自带样本数据，暂时先改一下跟上面示例一样用自带数据。</span></span><br><span class="line"><span class="comment"># sample = read_sample(path_to_sample)</span></span><br><span class="line">sample = read_sample(FCPS_SAMPLES.SAMPLE_TWO_DIAMONDS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里calculate_distance_matrix返回的matrix是一个800×800的二维列表（模拟数据点为800个），每个元素类型为float，是一个对称型矩阵，自行计算距离矩阵时记得注意一下数据格式。然后数值越大代表两点距离越大，也即代表两点差异性越大，注意不要和相似度矩阵搞反了。</span></span><br><span class="line">matrix = calculate_distance_matrix(sample)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建K-Medoids类对象时把data_type这个参数设为&#x27;distance_matrix&#x27;。</span></span><br><span class="line">kmedoids_instance = kmedoids(matrix, initial_medoids, data_type=<span class="string">&#x27;distance_matrix&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的活也跟之前的一样了。</span></span><br><span class="line">kmedoids_instance.process()</span><br><span class="line">clusters = kmedoids_instance.get_clusters()</span><br><span class="line">medoids = kmedoids_instance.get_medoids()</span><br></pre></td></tr></table></figure><h2 id="构造和析构函数文档"><a href="#构造和析构函数文档" class="headerlink" title="构造和析构函数文档"></a>构造和析构函数文档</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pyclustering</span>.<span class="title">cluster</span>.<span class="title">kmedoids</span>.<span class="title">kmedoids</span>.<span class="title">__init__</span>(<span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">    self,</span></span></span><br><span class="line"><span class="function"><span class="params"> data,</span></span></span><br><span class="line"><span class="function"><span class="params"> initial_index_medoids,</span></span></span><br><span class="line"><span class="function"><span class="params"> tolerance = <span class="number">0.001</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"> ccore = <span class="literal">True</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"> kwargs </span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><table><thead><tr><th>参数名</th><th>含义</th></tr></thead><tbody><tr><td>data</td><td>（list型）输入数据，表征点（对象）的列表，每个点的表征格式都应为列表或元组。</td></tr><tr><td>initial_index_medoids</td><td>（list型）初始中心点的索引（输入数据中点的索引）。</td></tr><tr><td>tolerance</td><td>（double型）算法停止条件：如果在重新计算簇的中心点中，新旧中心点的距离变化的最大值小于这个tolerance，则算法停止运算。默认值为0.001。</td></tr><tr><td>ccore</td><td>（bool型）如果指定CCORE库（C++的pyclustering库）的话，则用于代替Python代码进行聚类。</td></tr><tr><td>**kwargs</td><td>任意关键字参数（可用参数：’metric’, ‘data_type’, ‘itermax’）。</td></tr></tbody></table><p><strong>关键字参数：</strong></p><ul><li>metric (distance_metric型): 用于计算两点之间距离的计算方法，默认为EUCLIDEAN_SQUARE。</li><li>data_type (string型): 输入样本数据的数据类型，有两种：’points’, ‘distance_matrix’，默认为’points’。</li><li>itermax (uint型): 聚类分析的最大迭代次数，默认为200。</li></ul><h2 id="成员函数文档"><a href="#成员函数文档" class="headerlink" title="成员函数文档"></a>成员函数文档</h2><p>成员函数中<code>get_cluster_encoding(),get_clusters(),get_medoids(),process()</code>都在前面示例代码里提到了，而且原文档中这里的介绍也比较简单就不再重复。在这里重点介绍一下<code>predict()</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pyclustering</span>.<span class="title">cluster</span>.<span class="title">kmedoids</span>.<span class="title">kmedoids</span>.<span class="title">predict</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    self,</span></span></span><br><span class="line"><span class="function"><span class="params"> points </span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure><p>用于计算对于每个点的最近聚类簇。</p><p><strong>参数</strong></p><p>[in]points(array_like型): 已计算好最近邻聚类簇的点集。</p><p><strong>返回值</strong></p><p>  (list型) 对于每个点的最近邻聚类簇的列表形式。每个聚类簇用索引来表示。如果<code>process()</code>方法在此之前未被调用的话会返回一个空集。</p><p>一个样例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyclustering.cluster.kmedoids <span class="keyword">import</span> kmedoids</span><br><span class="line"><span class="keyword">from</span> pyclustering.samples.definitions <span class="keyword">import</span> SIMPLE_SAMPLES</span><br><span class="line"><span class="keyword">from</span> pyclustering.utils <span class="keyword">import</span> read_sample</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入模拟数据，这里用了SAMPLE_SIMPLE3这种生成方式。</span></span><br><span class="line">sample = read_sample(SIMPLE_SAMPLES.SAMPLE_SIMPLE3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设k=4，设了４个初始中心点。</span></span><br><span class="line">initial_medoids = [<span class="number">4</span>, <span class="number">12</span>, <span class="number">25</span>, <span class="number">37</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建kmedoids聚类对象。</span></span><br><span class="line">kmedoids_instance = kmedoids(sample, initial_medoids)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行聚类分析。</span></span><br><span class="line">kmedoids_instance.process()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对以下两个点计算出最近邻的聚类簇</span></span><br><span class="line"><span class="comment"># 这里可以看到points就是用了与sample格式相同的数据点，然后输入predict()方法中，返回的是一个长度等于points中数据点个数的列表，列表中的每个值是聚类簇的索引，比如这里的取值范围就是0-3，代表对应points中位置的那个点应该属于哪个已聚好的类，其实就是相当于一个分类器。</span></span><br><span class="line">points = [[<span class="number">0.35</span>, <span class="number">0.5</span>], [<span class="number">2.5</span>, <span class="number">2.0</span>]]</span><br><span class="line">closest_clusters = kmedoids_instance.predict(points)</span><br><span class="line">print(closest_clusters)</span><br></pre></td></tr></table></figure><h1 id="Elbow法则的应用"><a href="#Elbow法则的应用" class="headerlink" title="Elbow法则的应用"></a>Elbow法则的应用</h1><p>对k值的取值一直是K-Means、K-Medoids等划分类聚类算法的一个关键问题，而Elbow法则是最常用的一种方法。在研究<code>pyclustering</code>文档时无意中发现里面还有<code>pyclustering.cluster.elbow</code>这个模块，于是打算尝试一下把这个封装好的Elbow法则结合到上面的K-Medoids算法中。</p><h2 id="pyclustering-cluster-elbow文档解析"><a href="#pyclustering-cluster-elbow文档解析" class="headerlink" title="pyclustering.cluster.elbow文档解析"></a>pyclustering.cluster.elbow文档解析</h2><p>具体的分析内容均写在下面的代码注释里了：</p><h3 id="公共类成员函数-1"><a href="#公共类成员函数-1" class="headerlink" title="公共类成员函数"></a>公共类成员函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self, data, kmin, kmax, kwargs</span>)</span></span><br><span class="line"><span class="function"># 构造<span class="title">Elbow</span>方法。</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">process</span> (<span class="params">self</span>)</span></span><br><span class="line"><span class="function"># 执行分析以找出适当数量的群集。</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">get_amount</span> (<span class="params">self</span>)</span></span><br><span class="line"><span class="function"># 返回由<span class="title">Elbow</span>法则得出的<span class="title">k</span>值。</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">get_wce</span> (<span class="params">self</span>)</span></span><br><span class="line"><span class="function"># 返回一个列表，每个元素是(<span class="params">kmin, kmin + <span class="number">1</span>, ..., kmax - <span class="number">1</span></span>)这个范围里不同的<span class="title">k</span>取值所对应的误差函数的值。也就是可以绘制那条肘部法则折线图的取值。</span></span><br></pre></td></tr></table></figure><h3 id="详细说明与代码示例"><a href="#详细说明与代码示例" class="headerlink" title="详细说明与代码示例"></a>详细说明与代码示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyclustering.cluster.kmeans <span class="keyword">import</span> kmeans, kmeans_visualizer</span><br><span class="line"><span class="keyword">from</span> pyclustering.cluster.center_initializer <span class="keyword">import</span> kmeans_plusplus_initializer</span><br><span class="line"><span class="keyword">from</span> pyclustering.cluster.elbow <span class="keyword">import</span> elbow <span class="comment">#导入elbow模块</span></span><br><span class="line"><span class="keyword">from</span> pyclustering.utils <span class="keyword">import</span> read_sample</span><br><span class="line"><span class="keyword">from</span> pyclustering.samples.definitions <span class="keyword">import</span> SIMPLE_SAMPLES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采样数据和前面一样。</span></span><br><span class="line">sample = read_sample(SIMPLE_SAMPLES.SAMPLE_SIMPLE3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Elbow方法实例，设K从1取到9（kmax-1）。</span></span><br><span class="line">kmin, kmax = <span class="number">1</span>, <span class="number">10</span></span><br><span class="line">elbow_instance = elbow(sample, kmin, kmax)</span><br><span class="line"><span class="comment"># 这里需要提一下elbow初始化函数里的一个任意关键字参数：initializer，是初始质心的取值方法，有kmeans_plusplus_initializer和random_center_initializer两种，前者是K-Means++里的方法，后者是经典的随机取点，默认取值是kmeans_plusplus_initializer，若要改为随机取点参照下面这行代码。</span></span><br><span class="line"><span class="comment">#elbow_instance = elbow(sample, kmin, kmax, initializer=random_center_initializer)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行输入的数据并获得分析的结果。</span></span><br><span class="line">elbow_instance.process()</span><br><span class="line"><span class="comment"># 返回的是一个int型数据，代表在Elbow法则的判别下得出的最有可能的k取值。</span></span><br><span class="line">amount_clusters = elbow_instance.get_amount()</span><br><span class="line"><span class="comment"># 返回的是一个列表，保存了每个k值对应的误差函数的值。</span></span><br><span class="line">wce = elbow_instance.get_wce()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是利用K-Means算法依据前面得出的K值进行的聚类。</span></span><br><span class="line"><span class="comment"># 初始化质心调用了center_initializer模块中的K-Means++式的初始化方式。</span></span><br><span class="line">centers = kmeans_plusplus_initializer(sample, amount_clusters, amount_candidates=kmeans_plusplus_initializer.FARTHEST_CENTER_CANDIDATE).initialize()</span><br><span class="line"><span class="comment"># 后面的步骤就跟K-Medoids差不多，同一个库里的接口设置得还比较相似。</span></span><br><span class="line">kmeans_instance = kmeans(sample, centers)</span><br><span class="line">kmeans_instance.process()</span><br><span class="line">clusters = kmeans_instance.get_clusters()</span><br><span class="line">centers = kmeans_instance.get_centers()</span><br><span class="line">kmeans_visualizer.show_clusters(sample, clusters, centers)</span><br></pre></td></tr></table></figure><h2 id="把elbow模块应用到K-Medoids中"><a href="#把elbow模块应用到K-Medoids中" class="headerlink" title="把elbow模块应用到K-Medoids中"></a>把elbow模块应用到K-Medoids中</h2><p>研究过elbow模块里的源代码可以发现elbow里的误差函数是由K-Means算法里的结果计算出来的，因此由此得出的K值应该是适用于K-Means里的K值，而并不一定适用于K-Medoids里。不过为了探索一下这个难得封装好的elbow法则在K-Medoids里的应用，我尝试了一下利用K-Means确定的K值来做K-Medoids聚类，代码及注释放在下面。</p><p>需要注意的一点是初始化中心点时，调用了<code>pyclustering.cluster.center_initializer</code>模块中的K-Means++式初始化方法，而该模块中的<code>initialize()</code>函数有一个bool型的参数return_index，若为True则返回初始化中心点的索引（可用于<code>pyclustering</code>模块的K-Medoids算法中），否则默认为False，返回初始化中心点的数值数组（用于<code>pyclustering</code>模块的K-Means算法中）。在下面的代码中我分别用centers_data和centers_index两个变量接收两个不同格式的返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyclustering.cluster.kmeans <span class="keyword">import</span> kmeans, kmeans_visualizer</span><br><span class="line"><span class="keyword">from</span> pyclustering.cluster.kmedoids <span class="keyword">import</span> kmedoids</span><br><span class="line"><span class="keyword">from</span> pyclustering.cluster.center_initializer <span class="keyword">import</span> kmeans_plusplus_initializer</span><br><span class="line"><span class="keyword">from</span> pyclustering.cluster.elbow <span class="keyword">import</span> elbow</span><br><span class="line"><span class="keyword">from</span> pyclustering.utils <span class="keyword">import</span> read_sample</span><br><span class="line"><span class="keyword">from</span> pyclustering.samples.definitions <span class="keyword">import</span> SIMPLE_SAMPLES</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">sample = read_sample(SIMPLE_SAMPLES.SAMPLE_SIMPLE3)</span><br><span class="line"></span><br><span class="line">kmin, kmax = <span class="number">1</span>, <span class="number">10</span></span><br><span class="line">elbow_instance = elbow(sample, kmin, kmax)</span><br><span class="line">elbow_instance.process()</span><br><span class="line"></span><br><span class="line">amount_clusters = elbow_instance.get_amount()  <span class="comment"># 得到K值</span></span><br><span class="line">wce = elbow_instance.get_wce()  <span class="comment"># 得到误差函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化质心返回数值</span></span><br><span class="line">centers_data = kmeans_plusplus_initializer(sample, amount_clusters,</span><br><span class="line">                                      amount_candidates=kmeans_plusplus_initializer.FARTHEST_CENTER_CANDIDATE).initialize()</span><br><span class="line"><span class="comment"># 初始化质心返回质心索引</span></span><br><span class="line">centers_index = kmeans_plusplus_initializer(sample, amount_clusters,</span><br><span class="line">                                      amount_candidates=kmeans_plusplus_initializer.FARTHEST_CENTER_CANDIDATE).initialize(return_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面分别进行K-Means和K-Medoids算法，并打印聚类结果进行对比</span></span><br><span class="line"><span class="comment"># K-Means</span></span><br><span class="line">kmeans_instance = kmeans(sample, centers_data)</span><br><span class="line">kmeans_instance.process()</span><br><span class="line">kmeans_clusters = kmeans_instance.get_clusters()</span><br><span class="line">kmeans_centers = kmeans_instance.get_centers()</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> kmeans_centers:</span><br><span class="line">print(row)</span><br><span class="line">print(<span class="string">&#x27;*********K-Means结果*********&#x27;</span>)</span><br><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> cluster <span class="keyword">in</span> kmeans_clusters:</span><br><span class="line">print(<span class="string">&quot;第%d类个数：%d&quot;</span>%(i,<span class="built_in">len</span>(cluster)))</span><br><span class="line">i+=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># K-Medoids</span></span><br><span class="line">kmedoids_instance = kmedoids(sample, centers_index, itermax=<span class="number">10000</span>)</span><br><span class="line">kmedoids_instance.process()</span><br><span class="line">kmedoids_clusters = kmedoids_instance.get_clusters()</span><br><span class="line">kmedoids_medoids = kmedoids_instance.get_medoids()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> kmedoids_medoids:</span><br><span class="line">print(sample[item])</span><br><span class="line">print(<span class="string">&#x27;*********K-Medoids结果*********&#x27;</span>)</span><br><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> cluster <span class="keyword">in</span> kmedoids_clusters:</span><br><span class="line">print(<span class="string">&quot;第%d类个数：%d&quot;</span>%(i,<span class="built_in">len</span>(cluster)))</span><br><span class="line">i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘出K值与误差函数值的折线图</span></span><br><span class="line">x=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line">plt.plot(x,wce)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;K&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">plt.xticks(x)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>代码中的sample变量可更改为任意符合格式的数据。我用我自己的一些研究数据尝试了一下，总的来说从聚类后各类别的数量上来看，K-Means和K-Medoids聚类的结果相差并不大。<strong>因此从我自己数据的角度来看，把elbow模块用在K-Medoids算法之前帮忙确定K值这个做法不会产生太大问题，但毕竟这种做法在逻辑上严谨来说是说不通，需要具体数据具体分析。</strong>在反复运行程序时出现变化的因素有：</p><ul><li>在<code>elbow_instance.process()</code>过程中由于K-Means算法本身的随机性，重复运行程序有可能会得出不同的K值。</li><li>在<code>kmeans_plusplus_initializer().initialize()</code>初始化中心点时，由于K-Means++算法本身在概率上的随机性，重复运行程序有可能会得出不同的初始化中心点。</li><li>在<code>kmeans_instance.process()</code>和<code>kmedoids_instance.process()</code>过程中，由于算法本身的随机性，重复运行程序可能会出现每一类的数目有稍微变化的情况。然后针对前面“K-Means和K-Medoids聚类的结果相差并不大”，出现的特例在于有可能对于一个K值，K-Means（K-Medoids）的聚类结果是每个类别数目较为平均可观，但是K-Medoids（K-Means）的聚类结果中有某一类或数类里只有1个或几个元素（就是明显的无意义分类）。这种情况在反复运行程序过程中不会经常出现，但本人也碰到有出现过的情况，这个取决于数据本身的分布特征以及前面确定K值和初始化质心等工作的质量。</li></ul><h1 id="After"><a href="#After" class="headerlink" title="After"></a>After</h1><p>有意向进一步研究一下elbow模块的源代码，仿照一下写一个用K-Medoids算法得出误差函数的elbow模块，把elbow法则真正结合到K-Medoids模块算法中。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 聚类 </tag>
            
            <tag> K-Medoids </tag>
            
            <tag> Elbow法则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Ubuntu19.10直接升级到20.04LTS</title>
      <link href="2020/05/31/upgrade_Ubuntu_20.04LTS/"/>
      <url>2020/05/31/upgrade_Ubuntu_20.04LTS/</url>
      
        <content type="html"><![CDATA[<p>2020年4月23日，代号为“Focal Fossa”的Ubuntu 20.04 LTS的最终稳定版本<a href="http://releases.ubuntu.com/20.04/">发布</a>。作为第八个LTS版本，Ubuntu 20.04 LTS将在之后一段时间内作为最大的版本存在 ，其重大更新和改进将在2030年前终止，而Ubuntu 19.10生命周期将在今年7月结束。</p><p>有一说一，作为一个用了半年19.10的人，我个人感觉20.04变化不大——但19毕竟比较短命所以还是升级到LTS比较好。问题是这半年里我在19.10中配了一大堆环境。因此，每次一想不开就重装系统熟练得都可以开店了的我第一次尝试了在系统中直接升级，特此记录一下操作的步骤。</p><p><strong>注意：任何升级操作之前请备份好原系统中的重要文件！</strong></p><p><strong>P.S.系统直接升级到20.04仅适用于Ubuntu 18.04 LTS和Ubuntu 19.10，其他版本请先升级为这两个版本之后再进行升级。以下演示步骤的系统环境为19.10版本，18.04中的界面稍有区别但过程基本相同。</strong></p><p>首先，一步到位的方式就是开机之后系统刚好给你弹出一个这个窗口，无脑点升级即可搞定：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB4c58bdb0a5f4b79a538336e059ea94b0?method=download&shareKey=3ba637738c3982ff330e8f6d1c831990" alt="更新"></p><p>但在系统不自动检测新版本的情况下，需要我们自己手动操作几步：</p><p>首先在终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do-release-upgrade -d</span><br></pre></td></tr></table></figure><p>强制系统向Ubuntu服务器查询有关版本的信息，以查看需要升级的内容，有可能会返回上面的软件更新器的内容以供你进行系统升级，但大多数情况是这样的：</p><p><img src="http://img.cuper.top/image/update-ubuntu%E6%89%BE%E4%B8%8D%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88LTS.png" alt="i"></p><p>这时候一般是由于现有系统还存在需要升级的软件所导致，需要去应用中手动打开软件更新器：</p><p><img src="http://img.cuper.top/image/update-ubuntu2020-05-21%2017-16-38%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="i"></p><p>等待其自动检测需要升级的软件：</p><p><img src="http://img.cuper.top/image/update-ubuntu2020-05-21%2017-18-14%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="i"></p><p>在没有把这些软件升级完成之前，软件更新器不会提供系统升级的接口。进行升级之前你可以先检测一下网络连接的情况，终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 2 fossbytes.com</span><br></pre></td></tr></table></figure><p>返回如下证明互联网连接正常：</p><p><img src="http://img.cuper.top/image/update-ubuntucheck%20internet.png" alt="i"></p><p>由此可选择“立即安装”，开始把这些软件升级：</p><p><img src="http://img.cuper.top/image/update-ubuntu2020-05-21%2017-48-07%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="i"></p><p>升级完成后按照指示重启电脑：</p><p><img src="http://img.cuper.top/image/update-ubuntu2020-05-21%2017-52-10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="i"></p><p>重启完成后，再次打开软件更新器，它将首先检测是否还有软件需要升级，没有检测到的情况下会自动检测可升级的系统版本，于是梦想中的那个升级接口出现了，意味着你的系统已准备好将Ubuntu升级到下一个最新的版本：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB4c58bdb0a5f4b79a538336e059ea94b0?method=download&shareKey=3ba637738c3982ff330e8f6d1c831990" alt="更新"></p><p>在选择升级之前，官方升级视频给出的注意事项（keep in mind）如下：</p><ul><li>一个良好的互联网连接状态（A GOOD INTERNET CONNECTION）</li><li>备份好你的重要数据（BACKUP YOUR IMPORTANT DATA）</li><li>第三方源在升级过程中将被禁用（THIRD PARTY REPOSITORIES WILL BE DISABLED）</li><li>升级后将无法降级回到旧的版本（CAN’T DOWNGRADE TO THE OLDER VERSION）</li></ul><p>确认了这些注意事项后，点选“升级”，打开新世界的大门：</p><p><img src="http://img.cuper.top/image/update-ubuntu2020-05-21%2018-03-01%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="i"></p><p>升级过程中也会弹出提示禁用第三方源：</p><p><img src="http://img.cuper.top/image/update-ubuntu2020-05-21%2018-03-44%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="i"></p><p>然后这个窗口会存在于升级安装过程的始终，展示目前的进度：</p><p><img src="http://img.cuper.top/image/update-ubuntu2020-05-21%2018-03-59%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="h"></p><p>具体的下载速度取决于你自己的网速以及设定的下载源。在升级新的软件包和清理过程中会弹出一些让你确认的窗口，最好展开每一项的内容看一下（我本人对mendeley软件无所谓就直接让它卸载了，这里需要确认一下你被卸载的软件是否备份好重要的数据）：</p><p><img src="http://img.cuper.top/image/update-ubuntu2020-05-21%2018-05-12%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="i"></p><p>这里的步骤走完之后将会提示重启系统：</p><p><img src="http://img.cuper.top/image/update-ubuntu2020-05-21%2018-27-20%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="i"></p><p>这时如果先打开一下文件夹可以看到logo和界面已经是20.04的样子了：</p><p><img src="http://img.cuper.top/image/update-ubuntu2020-05-21%2018-26-01%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="i"></p><p>选择现在重启，完成后将进入全新的登陆界面：</p><p><img src="http://img.cuper.top/image/update-ubuntuIMG_20200521_183100%5B1%5D.jpg" alt="i"></p><p>进入系统后在终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><p>可查看现在的系统版本，显示Ubuntu20.04LTS即为升级成功：</p><p><img src="http://img.cuper.top/image/update-ubuntu2020-05-21%2018-32-05%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="k"></p><p>或直接进入系统设置里查看：</p><p><img src="http://img.cuper.top/image/update-ubuntu2020-05-21%2018-34-20%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="i"></p><p>就这样，升级完成。欢迎来到Ubuntu 20.04 LTS这个全新的世界。</p><p>参考教程：</p><ul><li><a href="https://linux.cn/article-12085-1.html">如何将 Ubuntu 18.04 LTS/19.10 升级到 Ubuntu 20.04 beta（内有官方系统演示视频和升级操作视频）</a></li><li><a href="https://www.linuxidc.com/Linux/2020-03/162584.htm">如何将Ubuntu 18.04升级到Ubuntu 20.04</a></li><li><a href="https://baijiahao.baidu.com/s?id=1664544641979784440&wfr=spider&for=pc">如何从Ubuntu 18.04或19.10升级到Ubuntu 20.04 LTS？</a></li><li><a href="https://imcn.me/html/y2020/36098.html">如何立即升级到Ubuntu 20.04（Beta）</a></li><li><a href="https://forum.ubuntu.org.cn/viewtopic.php?f=77&t=490988&sid=32b90534789bed50d2dc671913dd9eef">如何升级到 Ubuntu 20.04</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Python连接Hive所需库的安装步骤</title>
      <link href="2020/05/26/Python_to_Hive/"/>
      <url>2020/05/26/Python_to_Hive/</url>
      
        <content type="html"><![CDATA[<p>在Python中，类比于pymysql包连接MySQL数据库，可以利用impala包的impala.dbapi连接Hive数据库，建立起来的连接和游标<code>cursor.execute(sql)</code>之后，后续查询操作基本上与pymysql相似。所需要的库的安装过程如下：</p><p>参考：</p><ul><li><a href="https://www.lizenghai.com/archives/29306.html">python 安装impala包</a></li><li><a href="https://blog.csdn.net/weixin_30379531/article/details/101941287?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-1">python安装thrift-sasl提示缺少sasl.h文件</a></li></ul><p>安装环境：Ubuntu20.04 LTS</p><p>按以下步骤来安装即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pip install six</span><br><span class="line">pip install bit_array</span><br><span class="line">pip install thriftpy</span><br><span class="line">apt-get install python-dev libsasl2-dev gcc</span><br><span class="line">pip install thrift_sasl</span><br><span class="line">pip install impyla</span><br></pre></td></tr></table></figure><p>其中<code>apt-get install python-dev libsasl2-dev gcc</code>是为了解决在<code>pip install thrift_sasl</code>中需要编译而缺少相应软件产生的如下报错（Windows系统可参考<a href="https://www.cnblogs.com/free-easy0000/p/9638982.html">这里</a>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">Looking <span class="keyword">in</span> indexes: https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">Collecting thrift_sasl</span><br><span class="line">  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/73/d3/588654faef5511afadc1a091d32fcdbb24ae5f2d90b380874aee68a717f9/thrift_sasl-0.4.2.tar.gz</span><br><span class="line">Collecting thrift&gt;=0.10.0 (from thrift_sasl)</span><br><span class="line">  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/97/1e/3284d19d7be99305eda145b8aa46b0c33244e4a496ec66440dac19f8274d/thrift-0.13.0.tar.gz (59kB)</span><br><span class="line">     |████████████████████████████████| 61kB 684kB/s </span><br><span class="line">Collecting sasl&gt;=0.2.1 (from thrift_sasl)</span><br><span class="line">  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/8e/2c/45dae93d666aea8492678499e0999269b4e55f1829b1e4de5b8204706ad9/sasl-0.2.1.tar.gz</span><br><span class="line">Collecting six&gt;=1.13.0 (from thrift_sasl)</span><br><span class="line">  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/65/eb/1f97cb97bfc2390a276969c6fae16075da282f5058082d4cb10c6c5c1dba/six-1.14.0-py2.py3-none-any.whl</span><br><span class="line">Building wheels <span class="keyword">for</span> collected packages: thrift-sasl, thrift, sasl</span><br><span class="line">  Building wheel <span class="keyword">for</span> thrift-sasl (setup.py) ... <span class="keyword">done</span></span><br><span class="line">  Created wheel <span class="keyword">for</span> thrift-sasl: filename=thrift_sasl-0.4.2-cp37-none-any.whl size=4010 sha256=d9aff46bdb4423f147da5e2809198b9feff9d54259b627c6b6d716640b3cc842</span><br><span class="line">  Stored <span class="keyword">in</span> directory: /root/.cache/pip/wheels/92/22/93/59527f7435acb500da2c80d4eb038377e752009fa47e842fba</span><br><span class="line">  Building wheel <span class="keyword">for</span> thrift (setup.py) ... <span class="keyword">done</span></span><br><span class="line">  Created wheel <span class="keyword">for</span> thrift: filename=thrift-0.13.0-cp37-cp37m-linux_x86_64.whl size=414111 sha256=113f6ddd0744dea046e5d8764c5858c9d397ca9d910004719662e6ccda1c9792</span><br><span class="line">  Stored <span class="keyword">in</span> directory: /root/.cache/pip/wheels/dc/f4/14/0cd659ffc6431d0a24534f04087f6239494daf4fb3531c542a</span><br><span class="line">  Building wheel <span class="keyword">for</span> sasl (setup.py) ... error</span><br><span class="line">  ERROR: Command errored out with <span class="built_in">exit</span> status 1:</span><br><span class="line">   <span class="built_in">command</span>: /home/cuper/anaconda3/bin/python -u -c <span class="string">&#x27;import sys, setuptools, tokenize; sys.argv[0] = &#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;/tmp/pip-install-zp2a5lr8/sasl/setup.py&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;; __file__=&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;/tmp/pip-install-zp2a5lr8/sasl/setup.py&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;;f=getattr(tokenize, &#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;open&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;, open)(__file__);code=f.read().replace(&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;\r\n&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;, &#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;\n&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;);f.close();exec(compile(code, __file__, &#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;exec&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;))&#x27;</span> bdist_wheel -d /tmp/pip-wheel-fc4awf9y --python-tag cp37</span><br><span class="line">       cwd: /tmp/pip-install-zp2a5lr8/sasl/</span><br><span class="line">  Complete output (30 lines):</span><br><span class="line">  running bdist_wheel</span><br><span class="line">  running build</span><br><span class="line">  running build_py</span><br><span class="line">  creating build</span><br><span class="line">  creating build/lib.linux-x86_64-3.7</span><br><span class="line">  creating build/lib.linux-x86_64-3.7/sasl</span><br><span class="line">  copying sasl/__init__.py -&gt; build/lib.linux-x86_64-3.7/sasl</span><br><span class="line">  running egg_info</span><br><span class="line">  writing sasl.egg-info/PKG-INFO</span><br><span class="line">  writing dependency_links to sasl.egg-info/dependency_links.txt</span><br><span class="line">  writing requirements to sasl.egg-info/requires.txt</span><br><span class="line">  writing top-level names to sasl.egg-info/top_level.txt</span><br><span class="line">  reading manifest file <span class="string">&#x27;sasl.egg-info/SOURCES.txt&#x27;</span></span><br><span class="line">  reading manifest template <span class="string">&#x27;MANIFEST.in&#x27;</span></span><br><span class="line">  writing manifest file <span class="string">&#x27;sasl.egg-info/SOURCES.txt&#x27;</span></span><br><span class="line">  copying sasl/saslwrapper.cpp -&gt; build/lib.linux-x86_64-3.7/sasl</span><br><span class="line">  copying sasl/saslwrapper.h -&gt; build/lib.linux-x86_64-3.7/sasl</span><br><span class="line">  copying sasl/saslwrapper.pyx -&gt; build/lib.linux-x86_64-3.7/sasl</span><br><span class="line">  running build_ext</span><br><span class="line">  building <span class="string">&#x27;sasl.saslwrapper&#x27;</span> extension</span><br><span class="line">  creating build/temp.linux-x86_64-3.7</span><br><span class="line">  creating build/temp.linux-x86_64-3.7/sasl</span><br><span class="line">  gcc -pthread -B /home/cuper/anaconda3/compiler_compat -Wl,--sysroot=/ -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -Isasl -I/home/cuper/anaconda3/include/python3.7m -c sasl/saslwrapper.cpp -o build/temp.linux-x86_64-3.7/sasl/saslwrapper.o</span><br><span class="line">  cc1plus: warning: <span class="built_in">command</span> line option ‘-Wstrict-prototypes’ is valid <span class="keyword">for</span> C/ObjC but not <span class="keyword">for</span> C++</span><br><span class="line">  In file included from sasl/saslwrapper.cpp:254:</span><br><span class="line">  sasl/saslwrapper.h:22:10: fatal error: sasl/sasl.h: 没有那个文件或目录</span><br><span class="line">     22 | <span class="comment">#include &lt;sasl/sasl.h&gt;</span></span><br><span class="line">        |          ^~~~~~~~~~~~~</span><br><span class="line">  compilation terminated.</span><br><span class="line">  error: <span class="built_in">command</span> <span class="string">&#x27;gcc&#x27;</span> failed with <span class="built_in">exit</span> status 1</span><br><span class="line">  ----------------------------------------</span><br><span class="line">  ERROR: Failed building wheel <span class="keyword">for</span> sasl</span><br><span class="line">  Running setup.py clean <span class="keyword">for</span> sasl</span><br><span class="line">Successfully built thrift-sasl thrift</span><br><span class="line">Failed to build sasl</span><br><span class="line">ERROR: astroid 2.3.1 requires typed-ast&lt;1.5,&gt;=1.4.0; implementation_name == <span class="string">&quot;cpython&quot;</span> and python_version &lt; <span class="string">&quot;3.8&quot;</span>, <span class="built_in">which</span> is not installed.</span><br><span class="line">ERROR: astroid 2.3.1 has requirement six==1.12, but you<span class="string">&#x27;ll have six 1.14.0 which is incompatible.</span></span><br><span class="line"><span class="string">Installing collected packages: six, thrift, sasl, thrift-sasl</span></span><br><span class="line"><span class="string">  Found existing installation: six 1.12.0</span></span><br><span class="line"><span class="string">    Uninstalling six-1.12.0:</span></span><br><span class="line"><span class="string">      Successfully uninstalled six-1.12.0</span></span><br><span class="line"><span class="string">  Running setup.py install for sasl ... error</span></span><br><span class="line"><span class="string">    ERROR: Command errored out with exit status 1:</span></span><br><span class="line"><span class="string">     command: /home/cuper/anaconda3/bin/python -u -c &#x27;</span>import sys, setuptools, tokenize; sys.argv[0] = <span class="string">&#x27;&quot;&#x27;</span><span class="string">&quot;&#x27;/tmp/pip-install-zp2a5lr8/sasl/setup.py&#x27;&quot;</span><span class="string">&#x27;&quot;&#x27;</span>; __file__=<span class="string">&#x27;&quot;&#x27;</span><span class="string">&quot;&#x27;/tmp/pip-install-zp2a5lr8/sasl/setup.py&#x27;&quot;</span><span class="string">&#x27;&quot;&#x27;</span>;f=getattr(tokenize, <span class="string">&#x27;&quot;&#x27;</span><span class="string">&quot;&#x27;open&#x27;&quot;</span><span class="string">&#x27;&quot;&#x27;</span>, open)(__file__);code=f.read().replace(<span class="string">&#x27;&quot;&#x27;</span><span class="string">&quot;&#x27;\r\n&#x27;&quot;</span><span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;&quot;&#x27;</span><span class="string">&quot;&#x27;\n&#x27;&quot;</span><span class="string">&#x27;&quot;&#x27;</span>);f.close();<span class="built_in">exec</span>(compile(code, __file__, <span class="string">&#x27;&quot;&#x27;</span><span class="string">&quot;&#x27;exec&#x27;&quot;</span><span class="string">&#x27;&quot;&#x27;</span>))<span class="string">&#x27; install --record /tmp/pip-record-fm0zp25n/install-record.txt --single-version-externally-managed --compile</span></span><br><span class="line"><span class="string">         cwd: /tmp/pip-install-zp2a5lr8/sasl/</span></span><br><span class="line"><span class="string">    Complete output (30 lines):</span></span><br><span class="line"><span class="string">    running install</span></span><br><span class="line"><span class="string">    running build</span></span><br><span class="line"><span class="string">    running build_py</span></span><br><span class="line"><span class="string">    creating build</span></span><br><span class="line"><span class="string">    creating build/lib.linux-x86_64-3.7</span></span><br><span class="line"><span class="string">    creating build/lib.linux-x86_64-3.7/sasl</span></span><br><span class="line"><span class="string">    copying sasl/__init__.py -&gt; build/lib.linux-x86_64-3.7/sasl</span></span><br><span class="line"><span class="string">    running egg_info</span></span><br><span class="line"><span class="string">    writing sasl.egg-info/PKG-INFO</span></span><br><span class="line"><span class="string">    writing dependency_links to sasl.egg-info/dependency_links.txt</span></span><br><span class="line"><span class="string">    writing requirements to sasl.egg-info/requires.txt</span></span><br><span class="line"><span class="string">    writing top-level names to sasl.egg-info/top_level.txt</span></span><br><span class="line"><span class="string">    reading manifest file &#x27;</span>sasl.egg-info/SOURCES.txt<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    reading manifest template &#x27;</span>MANIFEST.in<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    writing manifest file &#x27;</span>sasl.egg-info/SOURCES.txt<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    copying sasl/saslwrapper.cpp -&gt; build/lib.linux-x86_64-3.7/sasl</span></span><br><span class="line"><span class="string">    copying sasl/saslwrapper.h -&gt; build/lib.linux-x86_64-3.7/sasl</span></span><br><span class="line"><span class="string">    copying sasl/saslwrapper.pyx -&gt; build/lib.linux-x86_64-3.7/sasl</span></span><br><span class="line"><span class="string">    running build_ext</span></span><br><span class="line"><span class="string">    building &#x27;</span>sasl.saslwrapper<span class="string">&#x27; extension</span></span><br><span class="line"><span class="string">    creating build/temp.linux-x86_64-3.7</span></span><br><span class="line"><span class="string">    creating build/temp.linux-x86_64-3.7/sasl</span></span><br><span class="line"><span class="string">    gcc -pthread -B /home/cuper/anaconda3/compiler_compat -Wl,--sysroot=/ -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -Isasl -I/home/cuper/anaconda3/include/python3.7m -c sasl/saslwrapper.cpp -o build/temp.linux-x86_64-3.7/sasl/saslwrapper.o</span></span><br><span class="line"><span class="string">    cc1plus: warning: command line option ‘-Wstrict-prototypes’ is valid for C/ObjC but not for C++</span></span><br><span class="line"><span class="string">    In file included from sasl/saslwrapper.cpp:254:</span></span><br><span class="line"><span class="string">    sasl/saslwrapper.h:22:10: fatal error: sasl/sasl.h: 没有那个文件或目录</span></span><br><span class="line"><span class="string">       22 | #include &lt;sasl/sasl.h&gt;</span></span><br><span class="line"><span class="string">          |          ^~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">    compilation terminated.</span></span><br><span class="line"><span class="string">    error: command &#x27;</span>gcc<span class="string">&#x27; failed with exit status 1</span></span><br><span class="line"><span class="string">    ----------------------------------------</span></span><br><span class="line"><span class="string">ERROR: Command errored out with exit status 1: /home/cuper/anaconda3/bin/python -u -c &#x27;</span>import sys, setuptools, tokenize; sys.argv[0] = <span class="string">&#x27;&quot;&#x27;</span><span class="string">&quot;&#x27;/tmp/pip-install-zp2a5lr8/sasl/setup.py&#x27;&quot;</span><span class="string">&#x27;&quot;&#x27;</span>; __file__=<span class="string">&#x27;&quot;&#x27;</span><span class="string">&quot;&#x27;/tmp/pip-install-zp2a5lr8/sasl/setup.py&#x27;&quot;</span><span class="string">&#x27;&quot;&#x27;</span>;f=getattr(tokenize, <span class="string">&#x27;&quot;&#x27;</span><span class="string">&quot;&#x27;open&#x27;&quot;</span><span class="string">&#x27;&quot;&#x27;</span>, open)(__file__);code=f.read().replace(<span class="string">&#x27;&quot;&#x27;</span><span class="string">&quot;&#x27;\r\n&#x27;&quot;</span><span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;&quot;&#x27;</span><span class="string">&quot;&#x27;\n&#x27;&quot;</span><span class="string">&#x27;&quot;&#x27;</span>);f.close();<span class="built_in">exec</span>(compile(code, __file__, <span class="string">&#x27;&quot;&#x27;</span><span class="string">&quot;&#x27;exec&#x27;&quot;</span><span class="string">&#x27;&quot;&#x27;</span>))<span class="string">&#x27; install --record /tmp/pip-record-fm0zp25n/install-record.txt --single-version-externally-managed --compile Check the logs for full command output.</span></span><br></pre></td></tr></table></figure><p>安装完成后测试Python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> impala.dbapi <span class="keyword">import</span> connect</span><br></pre></td></tr></table></figure><p>无报错证明安装成功，即可实现通过Python连接Hive数据库。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HBase </tag>
            
            <tag> Python </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你听，江水流过人家吵着要上岸【多图预警】</title>
      <link href="2020/05/21/kyrj/"/>
      <url>2020/05/21/kyrj/</url>
      
        <content type="html"><![CDATA[<blockquote><p>仙湖边有船<br>微光照彼岸<br>我是这船上客<br>它陪我渡孤单</p></blockquote><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>2020年5月16日的早上，刚醒来的我像过去两天里拿起手机的第一反应一样登上学院的官网，不同的是，这一次刷出了<a href="http://ei.hust.edu.cn/info/1150/5235.htm">成绩的公示</a>。看到自己名字后面备注中的“计划内待录取”，又睡了回去……</p><p>过去的一年里，为了不毒奶自己，我无数次忍住了在各种社交网站上发一些与考研相关的动态的欲望，很多张记录了某个时刻的照片和截图只静静躺在自己手机的相册里，心想着要一直低调到录取的那一天。现在这一天来了，不写点什么好像不太对得起过去这接近一年的时光和记忆。不想被乌烟瘴气的微博污染，又不想折腾一个微信公众号还要重操旧业搞排版，于是想起了由于严重的拖延症在本科搁置了差不多三年的想要搭个博客的计划，干脆就把这些活一并干完了。</p><p>这篇文章可以说是一个过去一年里我缺失的朋友圈的合集，也整合了一些曾经忍不住发了出来的动态，就以这种图文的形式把2019年6月后至今的这段时间串联起来，方便日后自己的回顾。</p><h1 id="热夏"><a href="#热夏" class="headerlink" title="热夏"></a>热夏</h1><p>考研的故事通常从一年的春天开始，但是这里第一个标题是热夏，就是因为我懒。</p><p>大三的下学期一开学，我的书架上就专门腾出了一个格子放了这些书：</p><ul><li>张宇数二的27讲+1000题</li><li>李永乐复习全书+660+真题（我哪来的信心刷完张宇还能刷李永乐）</li><li>肖秀荣精讲精练+讲真题+1000题</li><li>英二的黄皮书×2（当时淘宝买回来不知道英二从10年开始，在生活区拆迁前夕逛那家清仓打折的盗版书店时发现一个类似的以为是10年之前的题，结果又买了一本一模一样的（主要是贪便宜））</li><li>丁晓钟的英一（参考了知乎上一个帖子的<a href="https://zhuanlan.zhihu.com/p/61462432">建议</a>）</li></ul><p><strong>完完全全的考研版冲动消费。</strong></p><h2 id="6月"><a href="#6月" class="headerlink" title="6月"></a>6月</h2><p>OK，然后因为一堆上课+考试+华工杯+（mainly）自己万恶的拖延症，除了3月份随大流开启了下面这个风靡一时的流利阅读之外，在张宇线代9讲里写下第一笔的时候是6月3日了（是的还脑抽了一下感觉线代简单先去复习线代了，结果开始看高数已经7月中旬了）。<br><img src="http://img.cuper.top/image/kaoyanIMG_20200520_235203[1].jpg"><br>然后刚去了两天图书馆真真正正写了几道题之后，无线通信基础的闭卷考试和硬件课设又来了，考研复习的优先顺序被我排到了这两件事之后，所以6月份的进度也约等于0。</p><p>最大的工作就是关注了一堆考研公众号并且全部放上了星标，起码资讯方面没有落后了：</p><img src="http://img.cuper.top/image/kaoyanScreenshot_2020-06-30-20-42-06-399_com.tencent.mm.jpg" alt="Screenshot_2020-06-30-20-42-06-399_com.tencent.mm" style="zoom:33%;" /><img src="http://img.cuper.top/image/kaoyanScreenshot_2020-06-30-20-41-57-583_com.tencent.mm.jpg" alt="Screenshot_2020-06-30-20-41-57-583_com.tencent.mm" style="zoom:33%;" /><img src="http://img.cuper.top/image/kaoyanScreenshot_2020-06-30-20-41-42-707_com.tencent.mm.jpg" alt="Screenshot_2020-06-30-20-41-42-707_com.tencent.mm" style="zoom:33%;" /><p>还有微博的一个专门的分组：</p><img src="http://img.cuper.top/image/kaoyan微信图片_20200731222802.jpg" alt="微信图片_20200731222802" style="zoom: 33%;" /><p>虽然如此，6月份还在抽空跑出去浪，跑去看了一个漫威展：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190606_154541[1].jpg"></p><p>还有空去拍喻家湖和聚餐：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190614_185615[1].jpg"></p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190619_221728[1].jpg"></p><p>然后还迷上了刷剧和做台词截图，从此养成了睡前必须看一集剧/番/综艺的习惯直到考前几天，所以经常会出现寝室里最早上床的我最晚睡着的情况。</p><p><img src="http://img.cuper.top/image/kaoyan1560309670064[1].jpg"></p><h2 id="7月"><a href="#7月" class="headerlink" title="7月"></a>7月</h2><p>然后到了7月份，搞完课设之后没几天就是去南京生产实习了。本来心想着赶紧抓紧这几天先在学校把线代看一半，结果没做几道题就要出发了。出发前有一天去麦当劳还中奖了——本来是薯条买一送一结果单点的板烧也送了一个：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190702_184943[1].jpg"></p><p>然后就背了一大堆的书去南京了。说是生产实习其实就是天天坐一个会议室里听课（读ppt），基本上就是全员把老师的声音当BGM然后在下面自习。感谢他们虽然晚上下班了还把教室开给我们可以自习到十点多再走，不然我就要在这种憨憨宾馆的这种环境里学习了：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190719_212811[1].jpg"></p><p>当然这是学完回来顺路买了夜宵之后的桌子。另外感谢宾馆附近丰富的夜宵供应源，让我在短短两周时间里胖了接近10斤，从此回到学校怎么跑步也减不下来就放弃抵抗了。</p><p>P.S.南京的夜景是真的好看：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190713_193922[1].jpg"></p><p>还有一个值得一提的里程碑就是在实习单位楼下开的瑞幸终于把我引入坑了，从此等到9月份韵苑的瑞幸开了之后几乎日均一杯。</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190711_145128[1].jpg"></p><p>然后就回到了学校，7月已经过半了。在南京复完了线代但是高数刚开始一两章的我肯定不敢就这样回家给自己放暑假，于是开启了每天锁死在图书馆的生活——持续到考前了。从此，手机里的图书馆随手拍多了起来：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190727_194122[1].jpg"></p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190728_185446[1].jpg"></p><p>从这张7月30日的随手拍里可以回忆起当时的进度：18讲看到第7讲一元积分（就这？）。顺带一提当时的情况是政治和专业课完全未开工，英语从01年的英语一开始每天<strong>只</strong>做一道阅读题（单词都还没专门背过），就是一心想着先赶完一轮数学之后回家给自己放两周暑假。</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190730_173716[1].jpg"></p><p>期间还被人碰坏了小南瓜的右边后视镜和自己蹭碎了左边的，我感觉这一年换的后视镜加起来够换一个电瓶了。</p><img src="http://img.cuper.top/image/kaoyan5472a61ca3e28d3d[3].jpg" style="zoom: 33%;" /><p><img src="http://img.cuper.top/image/kaoyanIMG_20190731_162003[1].jpg"></p><p>再期间火了哪吒这部电影，又忍不住跑去刷了首映。</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190726_233006[1].jpg"></p><h2 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h2><p>8月3日，终于看完了高数18讲最后一讲的这一天，并且买好了两天后回家的车票。这天傍晚吃完晚饭如释重负（虽然只是简单地过了一轮数学）跑去西操闲逛，坐在草地上拍了一下晚霞。</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190803_191143-01[1].jpeg"></p><p>然后就回家了。总而言之，这半个月的冲刺法复习换来的就是一份自欺欺人的安稳两周暑假。回家还带上了专业课的书和1000题，结果到头来在家两周就是每天听了个流利阅读。感觉再这样下去会出事，所以赶紧买了8.20的票回到了学校。</p><p>回校之后的头10天可以算是有史以来干劲最大的10天，一是自己立了一个flag，打算在这10天把那本《十天搞定考研词汇乱序版》的第一阶段冲了；二是10天后的8月30日，在两三个月前早早买了这一天谢春花演唱会的票——不加把劲先学一阵子怎么好意思去见春花是吧。</p><p>然后这10天基本上花了大半天的时间来背单词，还有信号也开始从考纲的第一个考点开始慢慢往前挪了，数学倒是进度不大，只把之前第一轮的笔记找了出来重新整理了一遍。</p><p>这10天的精神食粮：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190829_190620[1].jpg"></p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190829_181516-01[1].jpeg"></p><p>真·食粮（天天特价是星期二、五、六的精神寄托）：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190822_133953[1].jpg"></p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190827_182813.jpg" alt="IMG_20190827_182813"></p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190903_184134.jpg" alt="IMG_20190903_184134"></p><p>终于到了8月30日这一天，感谢春花给最后四个月冲刺的我注入了一剂强心剂：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190830_213223.jpg"></p><p>顺利和春花合影（虽然via<a href="https://weibo.com/3478459251/I4FJKuQz5?type=repost#_rnd1594820375819">她微博</a>）：</p><p><img src="http://img.cuper.top/image/kaoyan14c751f9bc9615e853e8d41edd199697.jpg"></p><p>就这样，每天早上一到图书馆就闷着头背两个小时单词、晚上点着灯按照艾宾浩斯曲线再过一遍的10天结束了，告别了这个热夏，对专业课和数学第二轮发起猛攻的秋酿来了。</p><p><img src="http://img.cuper.top/image/kaoyanqq_pic_merged_1567009680065[1].jpg"></p><h1 id="秋酿"><a href="#秋酿" class="headerlink" title="秋酿"></a>秋酿</h1><h2 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h2><p>9月是始航的月份——对于开学刚回到学校的人来说。热闹是他们的，不关坐在图书馆的我事。但是保研的骚动蔓延到整个年级就离谱，比如每天回到寝室就要对着自己被<strong>公开处刑</strong>的成绩单：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190904_220935.jpg" alt="IMG_20190904_220935"></p><p>在9月12日迎来了100天的倒计时：</p><img src="http://img.cuper.top/image/kaoyanmmexport1568294982456.jpg" alt="mmexport1568294982456" style="zoom:33%;" /><p>顺便show一下我用到了今年四月份的考研主题吧：</p><img src="http://img.cuper.top/image/kaoyanScreenshot_2019-09-12-01-49-38-860_com.miui.home.png" alt="Screenshot_2019-09-12-01-49-38-860_com.miui.home" style="zoom: 33%;" /><p>但就算是大四上还是有课的，所以时不时也会在东九五楼登高远眺感叹一下人生（和这破池塘）：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190908_180929.jpg" alt="IMG_20190908_180929"></p><p>也会趁机跑去东园吃一下久违的东边最好吃的饭（这半年简直快把西边吃吐了）：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190912_191027.jpg" alt="IMG_20190912_191027"></p><p>中秋节的前夕家里寄来了月饼又是一份强心剂了：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190910_001211.jpg" alt="IMG_20190910_001211"></p><p>然后还有远在腾讯的某1遗计送饼，这个中秋节也不算孤军奋战：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190913_212326.jpg" alt="IMG_20190913_212326"></p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190913_214259-01.jpeg" alt="IMG_20190913_214259-01"></p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190914_225853_1.jpg" alt="IMG_20190914_225853_1"></p><p>虽然还是有很酸的变相被激励的时候:)——</p><img src="http://img.cuper.top/image/kaoyanqq_pic_merged_1568554377619.jpg" alt="qq_pic_merged_1568554377619" style="zoom: 50%;" /><p>9月24日预报名开始，一大早磨了半天挤不进去的报名官网在中午吃完饭回来的路上终于用手机报名成功了：</p><img src="http://img.cuper.top/image/kaoyanScreenshot_2019-09-24-13-52-09-797_com.mmbox.xbrowser.pro.png" alt="Screenshot_2019-09-24-13-52-09-797_com.mmbox.xbrowser.pro" style="zoom: 33%;" /><p>然后在9月28日，保研的同学纷纷上<strong>同一个官网</strong>确认保研资格。拉上了<a href="https://blog.lfalive.top/">Lfalive</a>和<a href="http://www.bolun.xyz/">Bolun</a>这两个当时感觉可能明年要考研的（结果现在还真在复习的）去呷哺搓了一顿鸳鸯红锅，一辣解千愁（搞得保研的是这桌上的人一样）：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20190928_122925.jpg" alt="IMG_20190928_122925"></p><h2 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h2><p>然后就进入十月份了。第一天是70周年大庆的日子，在大家都出门浪或者呆在寝室看阅兵时，我在几乎空无一日的东九独占了一个放映厅，顺便把肖秀荣拿出来沾沾喜气：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191001_102455.jpg" alt="IMG_20191001_102455"></p><p>10月2日久违地去光谷浪了一波，顺便当作那天的政治复习任务搞定了：</p><p><img src="http://img.cuper.top/image/kaoyan%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200803211539111.jpg" alt="微信图片_20200803211539111"></p><p>接下来就是越来越冷的深秋和越来越慌的进度了，甚至慌到想秋招找个offer留一条后路，于是就有了一次广州一日游：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191011_111234.jpg" alt="IMG_20191011_111234"></p><p>但回来还是要闷着头往前走，在看飞鸟的综艺中截了两张图来自我鼓励一下：</p><p><img src="http://img.cuper.top/image/kaoyan1571245867803.jpg" alt="1571245867803"></p><p><img src="http://img.cuper.top/image/kaoyan1571245820803.jpg" alt="1571245820803"></p><p>还有Clannad里椋的话：</p><p><img src="http://img.cuper.top/image/kaoyan1572579023867.jpg" alt="1572579023867"></p><p>不过这个确实是在针对我（还好踢了一场0比0）：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20200729_221707.jpg" alt="IMG_20200729_221707"></p><p>在闭关修炼没刷完、精讲精练没看完、信号只过完一轮的情况下，就让秋酿到此结束了。</p><h1 id="知寒"><a href="#知寒" class="headerlink" title="知寒"></a>知寒</h1><h2 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h2><p>11月1日，倒计时50天了。</p><img src="http://img.cuper.top/image/kaoyanmmexport1572610224792.jpg" alt="mmexport1572610224792" style="zoom: 33%;" /><p>然后第一个周末，从暑假就开始眼馋的天气之子上映了，于是又忍不住去刷了首映：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191103_214544.jpg" alt="IMG_20191103_214544"></p><p>在11月9号还费了半天时间考了一门课的结课考试——之所以说是半天而不是一两周的复习，就是还好是开卷。考完了本科四年最后一门有结课笔试的课程之后的一个纪念：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191109_162556%20(2).jpg" alt="IMG_20191109_162556"></p><p>然后进行了网上确认（还好我科靠谱不用现场排队）：</p><img src="http://img.cuper.top/image/kaoyanIMG_20200729_215010.jpg" alt="IMG_20200729_215010" style="zoom: 25%;" /><p>少有的无意中把图书馆上的桌面拍了下来（⑧多说了爷的青春）：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191115_132815%20(2).jpg" alt="IMG_20191115_132815"></p><p>在某一天刮风下雨的夜里凌乱：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191117_210048.jpg" alt="IMG_20191117_210048"></p><p>在又湿又冷的傍晚最治愈的就是喻园的重庆小面了：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191124_185333.jpg" alt="IMG_20191124_185333"></p><p>说到吃的就不得不提装修后新开的百景园一&amp;二楼，在最后冲刺的两个月几乎就是完全的精神依靠，上午刷完一套数学后中午坐在暖暖的二楼吃一顿自助：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191117_114743.jpg" alt="IMG_20191117_114743"></p><p>然后晚上再在一楼粤菜窗口整一个双拼：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191130_120233%20(2).jpg" alt="IMG_20191130_120233"></p><p>顺带一提，上面写着的肠粉等到我考完试离开学校的前一晚才有（也是没想到离校之后的下一顿百景园会隔那么久）：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191130_120048.jpg" alt="IMG_20191130_120048"></p><p>当时火了一时的2017-2019的变化放在考研话题里太草了：</p><p><img src="http://img.cuper.top/image/kaoyan-59f9c6528a4c12a4.jpg" alt="-59f9c6528a4c12a4"></p><p>然后终于到了肖八肖四的时刻，但是没想到会突然这么多人给我点赞（感恩的心.mp3）：<br><img src="http://img.cuper.top/image/kaoyanIMG_20200729_214430.jpg" alt="IMG_20200729_214430"></p><p>这个坑逼小白甚至让我告别了一个群：</p><img src="http://img.cuper.top/image/kaoyanIMG_20200729_214936.jpg" alt="IMG_20200729_214936" style="zoom: 33%;" /><p>隔了一年半的十大也撞在了最后冲刺的时候：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191128_181932%20(2).jpg" alt="IMG_20191128_181932"></p><h2 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h2><p>在每天一套数学和信号真题的高强度作战之下，终于来到了最后一个月。</p><p>首先是在考研群里看到一个竞争对手的发言，心想我都是跟一群什么人在battle：</p><img src="http://img.cuper.top/image/kaoyan-cfcad06f9b5fefa.png" alt="-cfcad06f9b5fefa" style="zoom: 33%;" /><p>然后是如期而至的金色银杏，但是没有像往年那样的工夫去花好久找角度凹造型，就只能在7点的寒冬早晨路过绝望坡的时候拐进去拍一张以作2019年份的打卡：</p><p><img src="http://img.cuper.top/image/kaoyan1596030048130-01.jpeg" alt="1596030048130-01"></p><p>在冬日里温暖人心的还是在大冷天里跟hxdm吃香锅配冰阔落：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191207_185038.jpg" alt="IMG_20191207_185038"></p><p>老六的第六座金球还真是一个强大的精神动力：<br><img src="http://img.cuper.top/image/kaoyanb00122fc036e84d9e2da0deff4b37e33.jpg" alt="b00122fc036e84d9e2da0deff4b37e33"></p><p>坚持一下：<br><img src="http://img.cuper.top/image/kaoyan1a1f50f9920875e7ced4a60daec69e73.jpg" alt="1a1f50f9920875e7ced4a60daec69e73"></p><p>最后两周在图书馆楼梯间背肖四的情况：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20200729_214906.jpg" alt="IMG_20200729_214906"></p><p>在背大题的同时也为选择题发愁，这里安利一下腿姐的评论区，简直全员人才：</p><p><img src="http://img.cuper.top/image/kaoyan6fb9760f7fdbcaa20ab19a6be66e750b.jpg" alt="6fb9760f7fdbcaa20ab19a6be66e750b"></p><p><img src="http://img.cuper.top/image/kaoyanfe560d3e472e438b3557f4a3ba276179%20(2).jpg" alt="fe560d3e472e438b3557f4a3ba276179"></p><p><img src="http://img.cuper.top/image/kaoyan2f618093ebdc7d77053577c2dcd7da5d.jpg" alt="2f618093ebdc7d77053577c2dcd7da5d"></p><p><img src="http://img.cuper.top/image/kaoyanbd10b05e375c2605ae2cb33e6b6b8f61%20(3).jpg" alt="bd10b05e375c2605ae2cb33e6b6b8f61"></p><p>在考研倒数3天的18号星期三，为了一个结课报告在下午跑了一趟东九（被分在考研前那堂课pre也是没谁了），下课的时候竟然撞上了这一年冬天的武汉初雪。虽然不大，下了一会就全融了，但毕竟<em>瑞雪兆丰年</em>吧：</p><blockquote><p>你看 秋月温柔撕破了花瓣<br>却只为迎着暮冬大雪纷飞时贪玩</p></blockquote><p><img src="http://img.cuper.top/image/kaoyanIMG_20200731_215109.jpg" alt="IMG_20200731_215109"></p><p>还有永远相信考研群里最后几天总会蹦出一些你从未接触过的知识点：</p><p><img src="http://img.cuper.top/image/kaoyan-3e3af190e370b0e1.jpg" alt="-3e3af190e370b0e1"></p><p>然后在星期四的下午，离考试不到2天的时候发生了最意难平的事，首先在中操碰到三哥的就是那天下午训练完的我们院队。如果没有考研，跟三哥的这些合影里面应该有我的身影：</p><p><img src="http://img.cuper.top/image/kaoyan27180a3a63515c12%20(2).jpg" alt="27180a3a63515c12"></p><p><img src="http://img.cuper.top/image/kaoyan1a5356862b2e5cc1%20(2).jpg" alt="1a5356862b2e5cc1"></p><p><img src="http://img.cuper.top/image/kaoyan45c3ebf8ly1ga2d9b31nnj21400s0h2c.jpg" alt="45c3ebf8ly1ga2d9b31nnj21400s0h2c"></p><p>顺便传送一下三哥时隔两个月为了一场华科的野球更的两条微博：<a href="https://weibo.com/1170467832/Ilxk9xDFy?type=repost">Post1</a>&amp;<a href="https://weibo.com/1170467832/IlE08kMuv?type=repost">Post2</a>（还好今年看到三哥进我科当体育生了，等一波未来的华科野球之王）</p><p>然后来到了最后不安分的倒数1天，下午看考场顺便在里面自习了一个多小时做了几道英语阅读：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191220_143619.jpg" alt="IMG_20191220_143619"></p><p>是一个装修好半年了我都没在里面自习过一次的一个全新的A栋教室（主场优势荡然无存）：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191220_143956%20(2).jpg" alt="IMG_20191220_143956"></p><p>要坐在这种桌子椅子都带轮的地方考试我就没懂，一着急就把桌子往前推了咋办：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191220_163203_1%20(2).jpg" alt="IMG_20191220_163203_1"></p><p><img src="http://img.cuper.top/image/kaoyanScreenshot_2019-12-20-17-03-29-854_com.tencent.mm%20(2).jpg" alt="Screenshot_2019-12-20-17-03-29-854_com.tencent.mm"></p><p>然后就到了封考场的时间，再回来这里就要来真的了：<br><img src="http://img.cuper.top/image/kaoyanIMG_20191220_163719.jpg" alt="IMG_20191220_163719"></p><img src="http://img.cuper.top/image/kaoyanmmexport1576818360677.png" alt="mmexport1576818360677" style="zoom: 25%;" /><p>在考研前一晚吃饭的时候有空随手刷刷微博是准不亏的，或者是大赚（其实是ABD，还选错了还特意看完了徐涛的解答加深了印象）：</p><img src="http://img.cuper.top/image/kaoyan微信图片_20200731222809.jpg" alt="微信图片_20200731222809" style="zoom:50%;" /><p>最后一晚听到主图的闭馆BGM，拍下了伴了我这半年的桌子和两袋书：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191220_214834%20(2).jpg" alt="IMG_20191220_214834"></p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191220_214850%20(2).jpg" alt="IMG_20191220_214850"></p><p>考前那天晚上竟然隔了好几年终于又一次失眠了——困是真的困，睡也是真的睡不着。每次闭眼大半个小时又拿起手机看一下，迷迷糊糊真正睡着已经快到3点了。还好考研这事劲儿大，强打精神考完了第一天的科目，起码没在考试过程中打瞌睡。</p><p>肖老崩了也成了我们这一届的梗了：</p><p><img src="http://img.cuper.top/image/kaoyan2ac02ce8446697b76f63893eda5374a5.jpg" alt="2ac02ce8446697b76f63893eda5374a5"></p><p>那天晚上坐到东十二教室里是真的不行了，昏昏欲睡地看着宇哥一年一度的告别视频（有一说一没上一年那个“分手快乐”有内味）：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20200731_213032.jpg" alt="IMG_20200731_213032"></p><p>原定的那一晚梳理的数学知识点没看完，间接导致第二天的雪崩（所以<strong>真的不要把太多希望依靠在考前那一晚</strong>）。</p><p>第二天考完后在考场里磨磨蹭蹭地收拾东西，记录一下这片战场吧：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191222_170448.jpg" alt="IMG_20191222_170448"></p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191222_170450.jpg" alt="IMG_20191222_170450"></p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191222_170516%20(2).jpg" alt="IMG_20191222_170516"></p><p><img src="http://img.cuper.top/image/kaoyan%E8%80%83%E5%9C%BA.jpg"></p><p>正好那天还是冬至，于是晚餐就一个人在茶咖这样将就一下吧：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191222_185939.jpg" alt="IMG_20191222_185939"></p><p>还有到的时间刚刚好的一份足球周刊快递（那一晚又回到东九A栋我是没想到的）：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20191222_192920%20(2).jpg" alt="IMG_20191222_192920"></p><p>在23号零点的钟声响起时，彻底和初试say goodbye了。</p><h1 id="春酒"><a href="#春酒" class="headerlink" title="春酒"></a>春酒</h1><p>然后初试过后，该发的票圈发，该看的球看，该打的游戏打，就没多少可以再发在这里的了。真正忍住告诫自己一定不能奶自己的就是初试成绩出来的时候。期间湖北省教育局在9点公布三门公共课成绩，华科研招网在10点公布总成绩。这打的一个时间差还让我处刑两次，先在床上刚醒来查了三门公共课的成绩：</p><p><img src="http://img.cuper.top/image/kaoyan-9e7181823e39cc1.jpg" alt="-9e7181823e39cc1"></p><p>再在吃早饭时满怀期待地查信号：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20200221_104326.jpg" alt="IMG_20200221_104326"></p><img src="http://img.cuper.top/image/kaoyan-1670a87e077d0fd0.png" alt="-1670a87e077d0fd0" style="zoom:33%;" /><p>对的，我就是300+那个。</p><p>初试与复试之间的毕设论文查重，顺利毕业了：</p><p><img src="http://img.cuper.top/image/kaoyanmmexport1589205613376.jpg" alt="mmexport1589205613376"></p><p>复试的心理评测：</p><img src="http://img.cuper.top/image/kaoyan2f4b814b6f06698f.png" alt="2f4b814b6f06698f" style="zoom: 67%;" /><p>记住今年这个赌博式的复试抽题（结果最后抽到了一道没复到的压根不会的、还有一道不用复习本来就会的常识）：</p><p><img src="http://img.cuper.top/image/kaoyan-6c6dd6ebbb1783e4.png" alt="-6c6dd6ebbb1783e4"></p><p>最后的成绩：</p><p><img src="http://img.cuper.top/image/kaoyan76afbb2d656f9685.png" alt="76afbb2d656f9685"></p><p>流淌的江水终于上岸了。</p><h1 id="After"><a href="#After" class="headerlink" title="After"></a>After</h1><p>然后这篇博客开坑了两个多月后，终于收到了录取通知书，把最后一张缺的图片补上了：</p><p><img src="http://img.cuper.top/image/kaoyanIMG_20200803_122536.jpg" alt="IMG_20200803_122536"></p><p>首先感谢<a href="https://blog.lfalive.top/">Lfalive</a>和<a href="http://www.bolun.xyz/">Bolun</a>这两个hxd几乎每天陪我泡图书馆、吃百景园和飙喻园大道，“一人ぼっちじゃないんだよ”，也祝愿他们今年如愿以偿一战成硕。</p><p>然后感谢所有支持过、关心过、鼓励过我的人，哪怕只有聊天记录里的短短一句话、一个表情包，都是一份源源不断的动力。</p><p>最后祝在不平凡的今年里毕业的我们毕业快乐、江湖再会，祝愿已经奔赴职场闯荡的人一帆风顺、早日暴富，祝愿决心今年二战的人功不唐捐、顺利上岸，祝愿继续深造的人灵感涌现、研途顺利，祝愿明年的毕业生心想事成、得偿所愿。</p><p>用毕业论文致谢的最后一段作为本文同样的结尾：</p><p><strong>向所有人说一声谢谢，也希望如今受疫情影响的生活早日恢复正常，期待与所有人再次相会的那一天。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Blog</title>
      <link href="2020/05/20/Hello-Blog/"/>
      <url>2020/05/20/Hello-Blog/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“Hello World”</p></blockquote><p>致谢：</p><ul><li><a href="https://lfalive.top/">Lfalive</a>和<a href="http://www.bolun.xyz/">薄论</a>的推荐</li><li>来自<a href="https://jerryc.me/">Jerryc</a>的<a href="https://demo.jerryc.me/">Butterfly</a>主题</li></ul><p>参考教程：</p><ul><li><a href="https://demo.jerryc.me/">Butterfly文档</a></li><li><a href="https://blog.csdn.net/qq_37210523/article/details/80909983?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">Hexo+github搭建博客教程</a></li><li><a href="https://sspai.com/post/25137">Markdown教程</a></li></ul><p>希望在这个博客里记录未来更真实的生活。</p><p><img src="http://img.cuper.top/GOAT.jpg" alt="Messi"></p><p>注：本博客封面头图via微博<a href="https://weibo.com/3787649505/IFb2B5Cho?type=repost#_rnd1590508512907">@千葉幽羽bili</a>，个人头像via微博<a href="https://weibo.com/3381398980/IDqAZnYwH?filter=hot&root_comment_id=0&type=comment#_rnd1595245071615">@卷卷的自然卷0</a>，本文章插图及网页图标viaLOFTER<a href="https://pumapuma.lofter.com/post/1f1c64b9_1c65afd7f">@pumapuma</a>，均非商业用途，侵删。</p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
